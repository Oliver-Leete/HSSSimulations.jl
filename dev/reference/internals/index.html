<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Private Internals · Powder Model Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Powder Model Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/1_full_tut/">1 Full Build</a></li><li><a class="tocitem" href="../../tutorials/2_basic_tut/">2 Warm-up and Cool-down only</a></li><li><a class="tocitem" href="../../tutorials/3_material_tut/">3 A Melt Rate Based Material Model</a></li><li><a class="tocitem" href="../../tutorials/4_res_tut/">4 Saving More Results</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/">Main API</a></li><li><a class="tocitem" href="../api_adv/">Advanced API</a></li><li><a class="tocitem" href="../BoundaryExamples/">HSS Boundary</a></li><li><a class="tocitem" href="../PostProcessing/">Post proccessing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../internal_api/">Internal APIs</a></li><li class="is-active"><a class="tocitem" href>Private Internals</a><ul class="internal"><li><a class="tocitem" href="#Boundary"><span>Boundary</span></a></li><li><a class="tocitem" href="#Solver"><span>Solver</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Patterns</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulate Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Materials</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Models</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Results</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Loads and Load Sets</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundaries</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Types</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solvers</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/HSSBoundary/">HSS Boundary</a></li><li><a class="tocitem" href="../MaterialExamples/">Material examples</a></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li></ul></li><li><a class="tocitem" href="../../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Private Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Private Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/src/reference/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><p>Documentation for any things not exported from modules.</p><h2 id="Boundary"><a class="docs-heading-anchor" href="#Boundary">Boundary</a><a id="Boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.updateInds!" href="#HSSSimulations.Boundary.updateInds!"><code>HSSSimulations.Boundary.updateInds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateInds!(indStruct::Indices, recoatDist, resSize, ghost)
</code></pre><p>Updates an indices struct during a load step. Used to update the real and imaginary nodes during recoat of the powder layer based on the <code>recoatDist</code> (how far through the layer the powder has been deposited in number of nodes into the simulation area).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Boundary/indices.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.innerLoop!" href="#HSSSimulations.Boundary.innerLoop!"><code>HSSSimulations.Boundary.innerLoop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerLoop!(Tᵗ⁻¹, T, params, ind, gdist, κ)
</code></pre><p>The inner loop of <a href="../internal_api/#HSSSimulations.Boundary.padWithGhost!"><code>padWithGhost!</code></a>. This exists for no reason other than as a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions">function barrier</a> to allow for the compiler to know the type of <code>params</code> for better dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Boundary/ghosts.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.boundaryTemp" href="#HSSSimulations.Boundary.boundaryTemp"><code>HSSSimulations.Boundary.boundaryTemp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundaryTemp(ϕ⃗, T, κ, gdist) -&gt; Any
</code></pre><p>Calculates a temperature for a ghost cell that will give the heat flux density (ϕ⃗, in wm⁻²) to a node with a temperature of T. <code>gdist</code> is the distance between the ghost and real node in meters, eg. for a z boundary it would be <code>Δz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Boundary/ghosts.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.σ" href="#HSSSimulations.Boundary.σ"><code>HSSSimulations.Boundary.σ</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Stefan-Boltzmann constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Boundary/boundary.jl#L40-L42">source</a></section></article><h2 id="Solver"><a class="docs-heading-anchor" href="#Solver">Solver</a><a id="Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.fdmSolver!" href="#HSSSimulations.Solver.fdmSolver!"><code>HSSSimulations.Solver.fdmSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fdmSolver!(cts, indᵣ, G)
</code></pre><p>Uses the explicit time step finite difference heat form of the heat equation to calculate the new results using ghost cell boundary conditions.</p><p>In simple terms this takes the avarage for all nodes for the one around the one being calculated (from the previous time step), and uses the difference between that and the temperature of the current node (for the previous time step) multiplied by the fourier number <code>Fo</code> to calculate the temperature of that node for the current timestep. This is done for all nodes. As ghost nodes are used, this function is the same for all nodes and doesn&#39;t need special logic for boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/timeSolve.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.timeSolver!" href="#HSSSimulations.Solver.timeSolver!"><code>HSSSimulations.Solver.timeSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timeSolver!(
    cts::AbstractResult,
    pts::AbstractResult,
    ls::LoadStep,
    G::GVars
)
</code></pre><p>Solves a timestep by calculating new material propeties, setting ghost node boundary conditions, using an explicit finited difference method and then conditionally recoating the poweder (if the load specifies). The results are stored in the Results struct cr that is passed into the function.</p><p><strong>Arguments</strong></p><ul><li><code>cts</code> : The struct that will be used to store the results from this solver.</li><li><code>pts</code> : The results struct with the results from the previous step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/timeSolve.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.nanfiller!" href="#HSSSimulations.Solver.nanfiller!"><code>HSSSimulations.Solver.nanfiller!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nanfiller!(cts, indᵢ)
</code></pre><p>Fills non real cells with NaNs instead of the undef value there currently. Using NaN instead of zero both allows for a check to see if the cell has been initialised and makes them not show up in plots.</p><p>This needs to be called on all loads (not just recoat loads) as on the loads before recoat there are still imaginary nodes that need filling (for pretty plotting).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/timeSolve.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.loadSolver!" href="#HSSSimulations.Solver.loadSolver!"><code>HSSSimulations.Solver.loadSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadSolver!(
    ls::LoadStep,
    results,
    G::GVars
) -&gt; AbstractResult
</code></pre><p>Solves a single load and returns an array of the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/loadSolve.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.makeDescription" href="#HSSSimulations.Solver.makeDescription"><code>HSSSimulations.Solver.makeDescription</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeDescription(problem::Problem) -&gt; Any
</code></pre><p>Primaraly used for the show method for the Problem struct, but seperated into it&#39;s own function so the same formatting can be used for making a string to save to the results file. This is useful for having a summary of the simulation setup attached to the results for quick reference (The full problem struct is also saved, but that requires loading the results in a julia instance to read properly).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/problemSolve.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.startMetadata" href="#HSSSimulations.Solver.startMetadata"><code>HSSSimulations.Solver.startMetadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">startMetadata(problem, file)
</code></pre><p>Adds metadata to the results file. The data added here is stuff that is available at the start of the simulation, such as the problem description, the problem input and the start time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/problemSolve.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.finishMetadata" href="#HSSSimulations.Solver.finishMetadata"><code>HSSSimulations.Solver.finishMetadata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finishMetadata(G::GVars, file)
</code></pre><p>Adds metadata to the results file. The data added here is stuff that is not available until the end of the simulation, such as the melt max array, the results index array and the simulation end time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/e31567de6b75688663fcc70d15a43d89337660a7/src/Solver/problemSolve.jl#L186">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internal_api/">« Internal APIs</a><a class="docs-footer-nextpage" href="../../howtos/howto_ink/">Ink Patterns »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 19 June 2023 15:22">Monday 19 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
