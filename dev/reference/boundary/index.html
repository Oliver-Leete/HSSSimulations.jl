<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Model · High Speed Sintering Simulations</title><meta name="title" content="Boundary Model · High Speed Sintering Simulations"/><meta property="og:title" content="Boundary Model · High Speed Sintering Simulations"/><meta property="twitter:title" content="Boundary Model · High Speed Sintering Simulations"/><meta name="description" content="Documentation for High Speed Sintering Simulations."/><meta property="og:description" content="Documentation for High Speed Sintering Simulations."/><meta property="twitter:description" content="Documentation for High Speed Sintering Simulations."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">High Speed Sintering Simulations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Modelling of HSS (and related technologies)</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/intro/">Tutorial Introduction</a></li><li><a class="tocitem" href="../../tutorials/1_full_tut/">Tutorial 1: Full Build</a></li><li><a class="tocitem" href="../../tutorials/2_basic_tut/">Tutorial 2: Warm-up and Cool-down only</a></li><li><a class="tocitem" href="../../tutorials/3_material_tut/">Tutorial 3: A Melt Rate Based Material Model</a></li><li><a class="tocitem" href="../../tutorials/4_res_tut/">Tutorial 4: Saving More Results</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../api/">Main API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../adv_intro/">Advanced API Introduction</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../res/">Simulation Results</a></li><li><a class="tocitem" href="../material/">Material Model</a></li><li class="is-active"><a class="tocitem" href>Boundary Model</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Load-Sets"><span>Load Sets</span></a></li><li><a class="tocitem" href="#Loads"><span>Loads</span></a></li><li><a class="tocitem" href="#Boundary"><span>Boundary</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../hssbound/">HSS Boundary</a></li><li><a class="tocitem" href="../solver/">Solver</a></li><li><a class="tocitem" href="../postprocessing/">Post Processing</a></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_intro/">Recipes Introduction</a></li><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Pattern Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulating Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Material Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Model Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Result Type Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Load Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundary Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Type Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solver Recipes</a></li></ul></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li><li><a class="tocitem" href="../../doc_index/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Boundary Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/src/reference/boundary.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-Model"><a class="docs-heading-anchor" href="#Boundary-Model">Boundary Model</a><a id="Boundary-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Model" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary" href="#HSSSimulations.Boundary"><code>HSSSimulations.Boundary</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The functions for calculating the ghost nodes needed to solve the boundary conditions. Basic boundary conditions are also included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/HSSSimulations.jl#L88-L91">source</a></section></article><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.AbstractProblemParams" href="#HSSSimulations.Types.AbstractProblemParams"><code>HSSSimulations.Types.AbstractProblemParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractProblemParams &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>The <code>Problem</code> struct contains a field called boundary that is of this type. The purpose of this field is to store any boundary condition inputs that changes over the course of a build, such as the air temperature in the machine. As this is an abstract type a new struct can be made, that is a subtype of AbstractProblemParams, to contain the required variables for a given simulation. An example of this is given in <code>HSSParams</code>.</p><p>Any new subtype will need it&#39;s own boundaries written (the examples given are only meant to work with the <code>HSSParams</code> example).</p><p>See the <a href="../../howtos/howto_param/#Problem-Parameters-Recipes">Problem Parameters Recipes</a> for some insperation for implementing your own.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/boundaryTypes.jl#L197">source</a></section></article><h2 id="Load-Sets"><a class="docs-heading-anchor" href="#Load-Sets">Load Sets</a><a id="Load-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Sets" title="Permalink"></a></h2><p>These are not actually memebers of the <a href="#HSSSimulations.Boundary"><code>Boundary</code></a> module, but they are an integral part of how the boundary conditions are set up for a simulation so they are included here instead of in the <a href="../solver/#HSSSimulations.Solver"><code>Solver</code></a> documentation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.AbstractLoadSet" href="#HSSSimulations.Types.AbstractLoadSet"><code>HSSSimulations.Types.AbstractLoadSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLoadSet &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>This struct holds the information for a load set, primarily the list of loads to be solved, but also some extra bits. Subtypes should implement a method for the <code>Solver.loadSetSolver!</code> function.</p><p>A simulation problem contains a list of load sets that are solved in order. Load sets of different types can be combined to create more complex build behavour. For example, the default HSS load sets include one fixed load set, for preheating; one layer load set, for all of the layers in the build; and another fixed load set, for cooldown after the build.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/boundaryTypes.jl#L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.loadSetSolver!" href="#HSSSimulations.Solver.loadSetSolver!"><code>HSSSimulations.Solver.loadSetSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadSetSolver!(
    loadSet&lt;:AbstractLoadSet
    initResult::AbstractResult,
    layerNum::Int,
    prob::Problem{T,Gh,Mp,R,OR,B},
) where {T&lt;:Any,Gh&lt;:Any,Mp&lt;:Any,R&lt;:Any,OR&lt;:Any,B&lt;:Any}</code></pre><p>This function is run once for each <code>LoadSet</code> passed in to the problem, and dispatched on the type of that load set. For basic load sets, like <a href="../api/#HSSSimulations.Solver.FixedLoadSet"><code>FixedLoadSet</code></a>, it should basically just pass the arguments on to the <a href="#HSSSimulations.Solver.innerLoadSetSolver!"><code>innerLoadSetSolver!</code></a> function, the one exception being the list of loads being passed in instead of the <a href="#HSSSimulations.Types.AbstractLoadSet"><code>AbstractLoadSet</code></a> struct. For more complicated load sets, like <a href="../api/#HSSSimulations.Solver.LayerLoadSet"><code>LayerLoadSet</code></a>, this should include the logic used for that load set. For <a href="../api/#HSSSimulations.Solver.LayerLoadSet"><code>LayerLoadSet</code></a> this is a loop that loops over the list of loads once for each layer, incrementing the layer number as it goes.</p><p>For examples see the source code for the two default implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/loadSetSolve.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{FixedLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{FixedLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.Solver.loadSetSolver!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadSetSolver!(
    loadSet::FixedLoadSet,
    initResult::AbstractResult,
    layerNum::Int64,
    prob::Problem{T, Gh, Mp, R, OR, B}
)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/loadSetSolve.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{LayerLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{LayerLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.Solver.loadSetSolver!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadSetSolver!(
    loadSet::LayerLoadSet,
    initResult::AbstractResult,
    initLayerNum::Int64,
    prob::Problem{T, Gh, Mp, R, OR, B}
) -&gt; Tuple{AbstractResult, Int64}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/loadSetSolve.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.innerLoadSetSolver!" href="#HSSSimulations.Solver.innerLoadSetSolver!"><code>HSSSimulations.Solver.innerLoadSetSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerLoadSetSolver!(
    loads::Vector{Load},
    initResult::AbstractResult,
    layerNum,
    prob::Problem;
    name,
    isRecoatLoadSet,
    prevLayerNum
)
</code></pre><p>Solves a load set of a problem, iterating over and solving the loads in the given load set in order. The results for a load is saved to the file after solving it.</p><p>If the list of loads passed given include powder deposition, the <code>recoat</code> kwarg should be set to true, with the <code>layerNum</code> set to the thickness of the powder bed in layers that is desired at the end of the loads. If this is more than one layer thicker than the previous value, then the previous values should also be passed in to <code>prevLayerNum</code>.</p><p>It also helps to provide a unique name. This is the name that will be used to store the results from runnning the list of loads in the output file, and also will be used as the label in the progress meter. If no name is given then the current time is used instead. If the name given is not unique then you will get a run time error when it tries to save results to a place that is already taken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/loadSetSolve.jl#L87">source</a></section></article><h2 id="Loads"><a class="docs-heading-anchor" href="#Loads">Loads</a><a id="Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Loads" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.Load-Tuple{}" href="#HSSSimulations.Types.Load-Tuple{}"><code>HSSSimulations.Types.Load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Types.Load(;
    name=&quot;default&quot;, tₗ=1, skip=1,
    x₁=SymetryBoundary, x₂=SymetryBoundary,
    y₁=SymetryBoundary, y₂=SymetryBoundary,
    z₁=SymetryBoundary, z₂=SymetryBoundary,
)</code></pre><p>Default constructor for <a href="#HSSSimulations.Types.Load"><code>Types.Load</code></a>. All of the boundaries defaults to symetry boundaries (see <a href="#HSSSimulations.Boundary.SymetryBoundary"><code>Boundary.SymetryBoundary</code></a>). See <a href="#HSSSimulations.Boundary.ConductionBoundary"><code>Boundary.ConductionBoundary</code></a> and <a href="#HSSSimulations.Boundary.ConvectionBoundary"><code>Boundary.ConvectionBoundary</code></a>, for some more built in loads. And <a href="../hssbound/#HSS-Boundary">HSS Boundary</a> for more complicated loads.</p><p>The <code>z₂</code> load is run before any others, so any calculations that need to be done first should be put there, such as recoating.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Load(; name=&quot;test&quot;, tₗ=1, skip=1, x₁=ConductionBoundary, y₂=ConvectionBoundary)
  x₁ : ConductionBoundary
  x₂ : SymetryBoundary
  y₁ : SymetryBoundary
  y₂ : ConvectionBoundary
  z₁ : SymetryBoundary
  z₂ : SymetryBoundary
  name : test
  tₗ : 1.0
  skip : 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/loads.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.Load" href="#HSSSimulations.Types.Load"><code>HSSSimulations.Types.Load</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Load{X₁&lt;:AbstractBoundary, X₂&lt;:AbstractBoundary, Y₁&lt;:AbstractBoundary, Y₂&lt;:AbstractBoundary, Z₁&lt;:AbstractBoundary, Z₂&lt;:AbstractBoundary} &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p><strong>Fields</strong></p><ul><li><p><code>x₁::Type{X₁} where X₁&lt;:AbstractBoundary</code>: The boundary condition for the start of the x axis (<code>[1,:,:]</code>)</p></li><li><p><code>x₂::Type{X₂} where X₂&lt;:AbstractBoundary</code>: The boundary condition for the end of the x axis (<code>[end,:,:]</code>)</p></li><li><p><code>y₁::Type{Y₁} where Y₁&lt;:AbstractBoundary</code>: The boundary condition for the start of the y axis (<code>[:,1,:]</code>)</p></li><li><p><code>y₂::Type{Y₂} where Y₂&lt;:AbstractBoundary</code>: The boundary condition for the end of the y axis (<code>[:,end,:]</code>)</p></li><li><p><code>z₁::Type{Z₁} where Z₁&lt;:AbstractBoundary</code>: The boundary condition for the start of the z axis (<code>[:,:,1]</code>)</p></li><li><p><code>z₂::Type{Z₂} where Z₂&lt;:AbstractBoundary</code>: The boundary condition for the end of the z axis (<code>[:,:,end]</code>)</p></li><li><p><code>name::String</code>: Used to annotate the results</p></li><li><p><code>tₗ::Float64</code>: The duration of the load in seconds</p></li><li><p><code>skip::Int64</code>: The distance between results to save (see <a href="../../explanation/faqs/#Why-We-Skip-Some-Results">Why We Skip Some Results</a>)</p></li></ul><p>Each of the boundaries given must satisfy <code>Boundary isa Type{T} where T &lt;: AbstractBoundary</code>. This is to say that they should be the type itself, not an instance of that type. Additionally it should be a subtype of <a href="#HSSSimulations.Types.AbstractBoundary"><code>AbstractBoundary</code></a> and meet all of the requirements outlined in the that documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the <code>Load</code> is in a <a href="#HSSSimulations.Types.AbstractLoadSet"><code>BuildLoadSet</code></a> then one of the boundaries in one of the loads in the set should call the recoating logic so that new powder is actuall being layed down. This should always be done in the z₂ boundary, as it is a special case that ensures the indicies are updated for all other boundaries.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/boundaryTypes.jl#L111">source</a></section></article><h2 id="Boundary"><a class="docs-heading-anchor" href="#Boundary">Boundary</a><a id="Boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate" href="#HSSSimulations.Types.boundaryHeatTransferRate"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, i, p&lt;:AbstractBoundary) -&gt; ϕ⃗::Float64</code></pre><p>Used to calculate the heat flux denstity (ϕ⃗, in wm⁻²) into the model at a node on the relavant face for a given boundary condition. They are run per node, for each node on the face. The function should return a single numeric value that represents the heat flux density into the model.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>     : The temperature of the node for which the ghost node is being calculated</li><li><code>i</code>     : The cartesian index of the node for which the ghost node is being calculated</li><li><code>p</code>     : The boundary struct for the current boundary (see <a href="#HSSSimulations.Types.AbstractBoundary"><code>AbstractBoundary</code></a>)</li></ul><p>See the implementations of this for examples, and <a href="../../howtos/howto_bound/#Boundary-Recipes">Boundary Recipes</a> for some additional examples along with the relevant boundary structs.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A positive heat flow equates to heat flowing into the model and negative out of the model.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As this is run for every node on the face every time step, try to avoid complex computations. Where possible, put them in the constructor of the <a href="#HSSSimulations.Types.AbstractBoundary"><code>AbstractBoundary</code></a> instead, as that is only run once per face per timestep.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/boundaryTypes.jl#L83-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.AbstractBoundary" href="#HSSSimulations.Types.AbstractBoundary"><code>HSSSimulations.Types.AbstractBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subtypes of this define a boundary for a single face of the model. An instance of the subtype is created per boundary each time step.</p><p>The fields of the subtype should contain all of the information needed to calculate the heatflow on that boundary (except for the information already passed in to <code>Types.boundaryHeatTransferRate</code>).</p><p>Each subtype of this should have a constructor that satisfies the following signature:</p><pre><code class="nohighlight hljs">&lt;Boundary&gt;(pts::AbstractResult, cts::AbstractResult, prob::Problem, ls::LoadStep)</code></pre><p><strong>Arguments</strong></p><ul><li><code>pts</code>  : The results from the previous timestep. See <code>Result</code></li><li><code>cts</code>  : The results from the current timestep. See <code>Result</code></li><li><code>prob</code> : The &#39;global&#39; variables of the simulation. See <a href="../types/#HSSSimulations.Types.Problem"><code>Problem</code></a></li><li><code>ls</code>   : The per load step variables. See <a href="../types/#HSSSimulations.Types.LoadStep"><code>Types.LoadStep</code></a></li></ul><p>For examples see the default subtypes, and their constructors. <a href="../../howtos/howto_bound/#Boundary-Recipes">Boundary Recipes</a> has examples of some of the extra things that can be done with new <code>AbstractBoundary</code>s.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The constructor for z₂ is the only one that is run before the indices lists are set for that load. So any updating of the indices, such as that done by <code>recoating!</code>, should be done in that boundary constructor.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>cts.T</code> is unknown when this function is called, use the temperature from the previous time step insted (<code>pts.T</code>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/boundaryTypes.jl#L49-L80">source</a></section></article><h3 id="Symmetry"><a class="docs-heading-anchor" href="#Symmetry">Symmetry</a><a id="Symmetry-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.SymetryBoundary" href="#HSSSimulations.Boundary.SymetryBoundary"><code>HSSSimulations.Boundary.SymetryBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SymetryBoundary &lt;: AbstractBoundary</code></pre><p>A boundary for a face that has no heatflow (such as a face on a symetrical boundary). Used as the default boundary in <a href="#HSSSimulations.Types.Load"><code>Types.Load</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SymetryBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SymetryBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(
    _,
    _,
    _::SymetryBoundary
) -&gt; Float64
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L110">source</a></section></article><h3 id="Conduction"><a class="docs-heading-anchor" href="#Conduction">Conduction</a><a id="Conduction-1"></a><a class="docs-heading-anchor-permalink" href="#Conduction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.ConductionBoundary" href="#HSSSimulations.Boundary.ConductionBoundary"><code>HSSSimulations.Boundary.ConductionBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConductionBoundary &lt;: AbstractBoundary</code></pre><p>A boundary for a face that has a source of contact conductive heat flow.</p><p><strong>Fields</strong></p><ul><li><p><code>temp::Float64</code>: Temperature of object being contacted</p></li><li><p><code>coef::Float64</code>: Coefficient of contact conduction</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConductionBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConductionBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, _, p::ConductionBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.conductionFlow" href="#HSSSimulations.Boundary.conductionFlow"><code>HSSSimulations.Boundary.conductionFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conductionFlow(T1, T2, h)
</code></pre><p>Calculates a heat flux density (ϕ⃗, in wm⁻²) for a given contact conduction coefficient, h, between points at temperature T1 (the node on the boundary) and T2 (the wall in contact with the node).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L7">source</a></section></article><h3 id="Convection"><a class="docs-heading-anchor" href="#Convection">Convection</a><a id="Convection-1"></a><a class="docs-heading-anchor-permalink" href="#Convection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.ConvectionBoundary" href="#HSSSimulations.Boundary.ConvectionBoundary"><code>HSSSimulations.Boundary.ConvectionBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvectionBoundary &lt;: AbstractBoundary</code></pre><p>A boundary for a face that has a source of convective heat flow.</p><p><strong>Fields</strong></p><ul><li><p><code>temp::Float64</code>: Air temperature</p></li><li><p><code>coef::Float64</code>: Convection coefficient</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConvectionBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConvectionBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, _, p::ConvectionBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.convectionFlow" href="#HSSSimulations.Boundary.convectionFlow"><code>HSSSimulations.Boundary.convectionFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convectionFlow(T1, T∞, h)
</code></pre><p>Calculates a heat flux density (ϕ⃗, in wm⁻²) for a given convection coefficient, h, between a point at temperature T1 and a fluid with temperature T∞.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L24">source</a></section></article><h3 id="Radiation"><a class="docs-heading-anchor" href="#Radiation">Radiation</a><a id="Radiation-1"></a><a class="docs-heading-anchor-permalink" href="#Radiation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.radiationFlow" href="#HSSSimulations.Boundary.radiationFlow"><code>HSSSimulations.Boundary.radiationFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radiationFlow(T1, T∞, ε)
</code></pre><p>Calculates a heat flux density (ϕ⃗, in wm⁻²) for a given emmisivity, ε, between a point at temperature T1 and infinity at temperature T∞. The temperature arguments should both be in the units °C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L45">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.movingObjOverlap" href="#HSSSimulations.Boundary.movingObjOverlap"><code>HSSSimulations.Boundary.movingObjOverlap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">movingObjOverlap(
    geometry::Geometry,
    movingObj,
    objPos::Tuple{Int64, Int64}
) -&gt; Vector
</code></pre><p>Makes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos left and right edge are given by <code>objPos</code>. The overlap is filled with the value passed as <code>movingObj</code>.</p><p>The difference between the first and second value of the <code>objPos</code> Tuple multipled by the spacing in the y-axis (Δy) should match the width of the moving object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));

julia&gt; movingObjOverlap(geometry, true, (2, 4))
3-element Vector{Bool}:
 1
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary_adv.jl#L66">source</a></section><section><div><pre><code class="language-julia hljs">movingObjOverlap(
    geometry::Geometry,
    movingObj::AbstractVector,
    objPos::Int64
) -&gt; Any
</code></pre><p>Makes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by <code>objPos</code>. The overlap is filled with the matching values from the vector <code>movingObj</code>.</p><p>The length of the vector multipled by the spacing in the y-axis (Δy) should match the width of the moving object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));

julia&gt; movingObjOverlap(geometry, [1, 2, 3, 4, 5], 6)
3-element Vector{Int64}:
 2
 3
 4

julia&gt; movingObjOverlap(geometry, [1, 2, 3, 4, 5], 8)
3-element Vector{Int64}:
 0
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary_adv.jl#L103">source</a></section><section><div><pre><code class="language-julia hljs">movingObjOverlap(
    geometry::Geometry,
    movingObj::AbstractMatrix,
    objPos::Int64
) -&gt; Any
</code></pre><p>Makes a matrix with the same dimensions as the top surface of the simulation area. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by <code>objPos</code>. The overlap is filled with the matching values from the matrix <code>movingObj</code>.</p><p>Also for Matrix inputs, the length of the first axis multipled by the spacing in the x-axis (Δx) should match the depth of the moving object and the length of the second axis multipled by the spacing in the y-axis (Δy) should match the width of the moving object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));

julia&gt; movingObjOverlap(geometry, [1 2 3; 4 5 6; 7 8 9], 4)
3×3 Matrix{Int64}:
 2  3  0
 5  6  0
 8  9  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary_adv.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.recoating!" href="#HSSSimulations.Boundary.recoating!"><code>HSSSimulations.Boundary.recoating!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recoating!(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep,
    recoatDist,
    temp
)
</code></pre><p>Powder recoating logic. This updates the indices and fills the new real indices with the initial results provided in the simulation&#39;s <code>Problem</code>, except the temperature, which is set to <code>temp</code>. This allows for the new powder temp to be set to the temperature of the powder in the hopper, or feed bed, at that time in the build. This always runs in the positive y axis, so new powder is always deposited starting from <code>[:, 1, :]</code> and going to <code>[:, end, :]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary_adv.jl#L1">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.calcInds" href="#HSSSimulations.Boundary.calcInds"><code>HSSSimulations.Boundary.calcInds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calcInds(
    resultsArray::AbstractArray,
    ghostArray::AbstractArray,
    ΔH::Int64,
    isRecoatLoadSet::Bool
) -&gt; HSSSimulations.Types.Indices
</code></pre><p>Calculates the indices at the start of a load. For build load sets this includes &#39;imaginary&#39; nodes that don&#39;t yet represent a volume with powder in it (but will after recoat). <code>isRecoatLoadSet</code> should be set to true if the current load set includes powder recoating, and false if it does not. <code>ΔH</code> is the same as that found in the <a href="../types/#HSSSimulations.Types.Geometry"><code>Geometry</code></a> struct.</p><p>See <a href="../types/#HSSSimulations.Types.Indices"><code>Types.Indices</code></a> for more details on the struct returned by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/indices.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.padWithGhost!" href="#HSSSimulations.Boundary.padWithGhost!"><code>HSSSimulations.Boundary.padWithGhost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">padWithGhost!(
    pts::AbstractResult,
    cts::AbstractResult,
    ls,
    prob
)
</code></pre><p>Wraps the temperature array with ghost cells and updates the Tᵗ⁻¹ array in the <a href="../types/#HSSSimulations.Types.Problem"><code>Problem</code></a> with the new value. The ghost cells are calculated based on a the boundaries for each face provided in the current load. See <a href="#HSSSimulations.Types.Load"><code>Types.Load</code></a> for more details on these boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/ghosts.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.updateInds!" href="#HSSSimulations.Boundary.updateInds!"><code>HSSSimulations.Boundary.updateInds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateInds!(
    indStruct::HSSSimulations.Types.Indices,
    resultsArray::AbstractArray,
    ghostArray::AbstractArray,
    recoatDist::Int64
)
</code></pre><p>Updates an indices struct during a load step. Used to update the real and imaginary nodes during recoat of the powder layer based on the <code>recoatDist</code> (how far through the layer the powder has been deposited in number of nodes into the simulation area).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/indices.jl#L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.ghostCalc!" href="#HSSSimulations.Boundary.ghostCalc!"><code>HSSSimulations.Boundary.ghostCalc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghostCalc!(Tᵗ⁻¹, T, params, indices, gdist, κ)
</code></pre><p>Fills in the ghost nodes for the boundary on the face defined by <code>indices</code> using the <a href="#HSSSimulations.Types.boundaryHeatTransferRate"><code>boundaryHeatTransferRate</code></a> function for the type of the boundary parametre (<code>params</code>) given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/ghosts.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.boundaryTemp" href="#HSSSimulations.Boundary.boundaryTemp"><code>HSSSimulations.Boundary.boundaryTemp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundaryTemp(ϕ⃗, T, κ, gdist) -&gt; Any
</code></pre><p>Calculates a temperature for a ghost cell that will give the heat flux density (ϕ⃗, in wm⁻²) to a node with a temperature of T. <code>gdist</code> is the distance between the ghost and real node in meters, eg. for a z boundary it would be <code>Δz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/ghosts.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.σ" href="#HSSSimulations.Boundary.σ"><code>HSSSimulations.Boundary.σ</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Stefan-Boltzmann constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/boundary.jl#L40-L42">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../material/">« Material Model</a><a class="docs-footer-nextpage" href="../hssbound/">HSS Boundary »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 28 February 2024 23:46">Wednesday 28 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
