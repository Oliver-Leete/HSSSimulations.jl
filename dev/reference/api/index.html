<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Main API · High Speed Sintering Simulations</title><meta name="title" content="Main API · High Speed Sintering Simulations"/><meta property="og:title" content="Main API · High Speed Sintering Simulations"/><meta property="twitter:title" content="Main API · High Speed Sintering Simulations"/><meta name="description" content="Documentation for High Speed Sintering Simulations."/><meta property="og:description" content="Documentation for High Speed Sintering Simulations."/><meta property="twitter:description" content="Documentation for High Speed Sintering Simulations."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">High Speed Sintering Simulations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Modelling of HSS (and related technologies)</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/intro/">Tutorial Introduction</a></li><li><a class="tocitem" href="../../tutorials/1_full_tut/">Tutorial 1: Full Build</a></li><li><a class="tocitem" href="../../tutorials/2_basic_tut/">Tutorial 2: Warm-up and Cool-down only</a></li><li><a class="tocitem" href="../../tutorials/3_material_tut/">Tutorial 3: A Melt Rate Based Material Model</a></li><li><a class="tocitem" href="../../tutorials/4_res_tut/">Tutorial 4: Saving More Results</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Main API</a><ul class="internal"><li><a class="tocitem" href="#main_api_solver"><span>Solver</span></a></li><li><a class="tocitem" href="#Simulation-Geometry"><span>Simulation Geometry</span></a></li><li><a class="tocitem" href="#Ink-Struct"><span>Ink Struct</span></a></li><li><a class="tocitem" href="#Materials"><span>Materials</span></a></li><li><a class="tocitem" href="#Time-Step-Results"><span>Time Step Results</span></a></li><li><a class="tocitem" href="#Other-Results"><span>Other Results</span></a></li><li><a class="tocitem" href="#Boundary-Loads"><span>Boundary Loads</span></a></li><li><a class="tocitem" href="#Boundary-Parameters"><span>Boundary Parameters</span></a></li><li><a class="tocitem" href="#Settings"><span>Settings</span></a></li><li><a class="tocitem" href="#Results-File-Structure"><span>Results File Structure</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../adv_intro/">Advanced API Introduction</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../res/">Simulation Results</a></li><li><a class="tocitem" href="../material/">Material Model</a></li><li><a class="tocitem" href="../boundary/">Boundary Model</a></li><li><a class="tocitem" href="../hssbound/">HSS Boundary</a></li><li><a class="tocitem" href="../solver/">Solver</a></li><li><a class="tocitem" href="../postprocessing/">Post Processing</a></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_intro/">Recipes Introduction</a></li><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Pattern Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulating Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Material Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Model Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Result Type Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Load Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundary Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Type Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solver Recipes</a></li></ul></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li><li><a class="tocitem" href="../../doc_index/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Main API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Main API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/src/reference/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Main-API"><a class="docs-heading-anchor" href="#Main-API">Main API</a><a id="Main-API-1"></a><a class="docs-heading-anchor-permalink" href="#Main-API" title="Permalink"></a></h1><p>This page covers the basic API used for running simple simulations. Each section will also link to the relevant advanced API that can be used to further customise the behaviour of that part of the simulation. See <a href="../adv_intro/#Advanced-API-Introduction">Advanced API Introduction</a> for more information on how to use the advanced API.</p><h2 id="main_api_solver"><a class="docs-heading-anchor" href="#main_api_solver">Solver</a><a id="main_api_solver-1"></a><a class="docs-heading-anchor-permalink" href="#main_api_solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.problemSolver" href="#HSSSimulations.Solver.problemSolver"><code>HSSSimulations.Solver.problemSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">problemSolver(problem::Problem) -&gt; Tuple{Any, Any}
</code></pre><p>The main function that is called to solve a simulation and the struct that defines the problem to simulate.</p><p>Takes a fully defined problem and solves it, saving the solution to disk and returning the filename where it is saved. See <a href="#HSSSimulations.Types.Problem-Tuple{}"><code>Problem</code></a> for how to define the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/problemSolve.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.Problem-Tuple{}" href="#HSSSimulations.Types.Problem-Tuple{}"><code>HSSSimulations.Types.Problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Problem(
;
    geometry,
    matProp,
    params,
    loadSets,
    init,
    file,
    initLay,
    ink,
    description,
    otherResults,
    options
)
</code></pre><p>Assemble a problem out of its components.</p><p><strong>Arguments</strong></p><ul><li><code>geometry::</code><a href="../types/#HSSSimulations.Types.Geometry"><code>Geometry</code></a>: See <a href="#Simulation-Geometry">Simulation Geometry</a></li><li><code>matProp::</code><a href="../material/#HSSSimulations.Types.AbstractMatProp"><code>AbstractMatProp</code></a>: See <a href="#Materials">Materials</a></li><li><code>params::</code><a href="../boundary/#HSSSimulations.Types.AbstractProblemParams"><code>AbstractProblemParams</code></a>: See <a href="#Boundary-Parameters">Boundary Parameters</a></li><li><code>loadSets::Vector{</code><a href="../boundary/#HSSSimulations.Types.AbstractLoadSet"><code>AbstractLoadSet</code></a><code>}</code>: The list of load sets to simulate, in order   that the need simulating. See <a href="#Boundary-Loads">Boundary Loads</a></li><li><code>ink::</code><a href="#HSSSimulations.Types.Ink"><code>Ink</code></a>: The locations for ink deposition. This should be the same size as the   finial dimension of the simulation. See <a href="#Ink-Struct">Ink Struct</a></li><li><code>init::</code><a href="../res/#HSSSimulations.Types.AbstractResult"><code>AbstractResult</code></a>: The initial results struct. This should be the same size   as the finial dimension of the simulation. See <a href="#Time-Step-Results">Time Step Results</a></li><li><code>initLay::Int</code>: The thickness of powder deposited before the simulation starts, given in   number of layers thick. This must be greater than zero</li><li><code>file::String</code>: The file path and name for the output file of the simulation</li><li><code>description::String=&quot;&quot;</code>: A short description of what is being simulated</li><li><code>otherResults::</code><a href="../res/#HSSSimulations.Types.AbstractOtherResults"><code>AbstractOtherResults</code></a><code>=</code><a href="#HSSSimulations.Types.OtherResults"><code>OtherResults</code></a><code>()</code>: The struct to   save the final results to. See <a href="#Other-Results">Other Results</a></li><li><code>options::</code><a href="#HSSSimulations.Types.Options"><code>Options</code></a><code>=Options()</code>: The options to use for the simulation. See   <a href="#Settings">Settings</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/problem.jl#L59">source</a></section></article><h2 id="Simulation-Geometry"><a class="docs-heading-anchor" href="#Simulation-Geometry">Simulation Geometry</a><a id="Simulation-Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Geometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.Geometry-Tuple{Any, Any, Any}" href="#HSSSimulations.Types.Geometry-Tuple{Any, Any, Any}"><code>HSSSimulations.Types.Geometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Geometry(
    simSize, Δx, Δt;
    Δy=Δx, Δz=Δx, name=&quot;NA&quot;, Δh=0,
    offset=(0.0, 0.0), buildSize=nothing,
    force=false,
)</code></pre><p>Constructor for the <a href="../types/#HSSSimulations.Types.Geometry"><code>Geometry</code></a> type that is is used to store all of the geometry information (and time step length for some reason) for a rectangular build volume of the machine being simulated (given as the <code>buildSize</code>). It also saves the information for the subset of the build volume to actually be simulated (of size <code>simSize</code>, offset form the machine origin by <code>offset</code>), if the full build volume is not being simulated. If no <code>buildSize</code> is given then it is assumed to be just big enougth to fit the <code>simSize</code> with the given <code>offset</code>.</p><p><code>Δh</code> is the layer height in meters. If it is given as <code>0</code> (or not given) then it is assumed that the simulation isn&#39;t representing a full build, but instead something like the preheat or cooldown phase. In this case no layer recoat logic can be run (make sure not to include a recoating <a href="../boundary/#HSSSimulations.Types.Load"><code>Types.Load</code></a>).</p><p><code>Δt</code> is the time step (in seconds) and <code>Δx, Δy and Δz</code> are the node spacing (in meters). If not given then <code>Δy and Δz</code> default to the same as <code>Δx</code>. The timestep is included in the geometry as it is tied to the node spacing when it comes to making a stable simulation for the explicit finite difference method used in this model.</p><p>If the <code>force</code> argement is given then the divisible errors will be suppressed, this will result in the geometry not being properly represented.</p><div class="admonition is-danger"><header class="admonition-header">Use With Caution</header><div class="admonition-body"><p>Use the <code>force</code> argument with great caution. It was only added to allow for the creation of geometries that were blocked due to floating point math errors. If it is used when things aren&#39;t actually divisible then it will result in the geometry not being properly represented, and a disconnect between what you think you are simulating and what is actually being simulated.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/geometry.jl#L71-L105">source</a></section></article><h2 id="Ink-Struct"><a class="docs-heading-anchor" href="#Ink-Struct">Ink Struct</a><a id="Ink-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#Ink-Struct" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.Ink" href="#HSSSimulations.Types.Ink"><code>HSSSimulations.Types.Ink</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ink{T}</code></pre><p>Defines the volume of the ink placement within that (and therefore hopefully the part to be made). See <a href="../../howtos/howto_ink/#Ink-Pattern-Recipes">Ink Pattern Recipes</a> for some example patterns.</p><p><strong>Fields</strong></p><ul><li><p><code>nodes::Array{T, 3} where T</code>: The emmisivity of the models nodes, set to eₚ for nodes without ink.</p></li><li><p><code>name::String</code>: Just used for future reference of results</p></li></ul><p>This is the emmisivity relative to the lamp. So the emmisivity of the ink over the range of the wavelengths that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/types.jl#L75">source</a></section></article><h2 id="Materials"><a class="docs-heading-anchor" href="#Materials">Materials</a><a id="Materials-1"></a><a class="docs-heading-anchor-permalink" href="#Materials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Material.PA2200" href="#HSSSimulations.Material.PA2200"><code>HSSSimulations.Material.PA2200</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PA2200(
    geometry::Geometry
) -&gt; MatProp{Interpolations.Extrapolation{Float64, 2, Interpolations.ScaledInterpolation{Float64, 2, Interpolations.BSplineInterpolation{Float64, 2, Matrix{Float64}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{UnitRange{Int64}, UnitRange{Int64}}}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Flat{Nothing}}, _A, _B, _C, _D, _E, _F, typeof(PA_Ċ), Array{Float64, 3}} where {_A, _B, _C, _D, _E, _F}
</code></pre><p>An example material based on EOS&#39;s PA2200, using a rate of consolidation based on melt state. With eyeball correction to consolidation rate. Calling this with the <a href="../types/#HSSSimulations.Types.Geometry"><code>Geometry</code></a> struct to be used for the simulation as the only argument will return the relevant <a href="../material/#HSSSimulations.Material.MatProp"><code>MatProp</code></a> struct.</p><p>The sources of the data used are summarized in <a href="../material/#PA2200">PA2200</a>. For more details, check the material model chapter of my thesis.</p><p>This is one example material. To see how to define new materials or new material models, see <a href="../material/#Material-Model">Material Model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Material/PA2200.jl#L130">source</a></section></article><h2 id="Time-Step-Results"><a class="docs-heading-anchor" href="#Time-Step-Results">Time Step Results</a><a id="Time-Step-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Step-Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Results.Result" href="#HSSSimulations.Results.Result"><code>HSSSimulations.Results.Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Result{P&lt;:AbstractArray} &lt;: AbstractResult</code></pre><p>The results from a single timestep, use directly to create the initial conditions. Also created for each time step during the simulation.</p><p>This saves the data from the default material model and the heat transfer solver. For information on how to create a new result struct see <a href="../res/#Time/Load-Step-Results">Time/Load Step Results</a>.</p><p><strong>Fields</strong></p><ul><li><p><code>T::AbstractArray</code>: Temperature for each node</p></li><li><p><code>M::AbstractArray</code>: Melt state for each node</p></li><li><p><code>C::AbstractArray</code>: Consolidation state for each node</p></li><li><p><code>t::Float64</code>: Time of timestep, since the start of the build</p></li><li><p><code>tₚ::Float64</code>: The progress through the load step (0=start, 0.5=half way, 1=end)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/results.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Results.Result-NTuple{4, Any}" href="#HSSSimulations.Results.Result-NTuple{4, Any}"><code>HSSSimulations.Results.Result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Result(geomSize, Tᵢ, Mᵢ, Cᵢ) -&gt; Result
</code></pre><p>Create a result with uniform fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/results.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Results.Result-NTuple{5, Any}" href="#HSSSimulations.Results.Result-NTuple{5, Any}"><code>HSSSimulations.Results.Result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Result(geomSize, Tᵢ, Mᵢ, Cᵢ, t) -&gt; Result
</code></pre><p>Create a result with uniform fields and a given time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/results.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Results.Result-Tuple{Any, Any, Any}" href="#HSSSimulations.Results.Result-Tuple{Any, Any, Any}"><code>HSSSimulations.Results.Result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Result(geomSize, t, tₚ) -&gt; Result
</code></pre><p>Create an empty result. This is used during the simulation to create the results for each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/results.jl#L26">source</a></section></article><h2 id="Other-Results"><a class="docs-heading-anchor" href="#Other-Results">Other Results</a><a id="Other-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Results" title="Permalink"></a></h2><p>These are results that are saved once at the end of the simulation, for when</p><p>The default final results struct shown below saves the maximum melt state from the default material model and nothing else. For information on how to create a new result struct see <a href="../res/#End-of-Simulation-Results">End of Simulation Results</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.OtherResults" href="#HSSSimulations.Types.OtherResults"><code>HSSSimulations.Types.OtherResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OtherResults &lt;: AbstractOtherResults</code></pre><p>The default struct stores no additional data and only acts as a placeholder. When used, the simulation will store the maximum melt state to <code>Results</code> folder of the output file and no other final results (time step results are still saved each load step).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/types.jl#L66">source</a></section></article><h2 id="Boundary-Loads"><a class="docs-heading-anchor" href="#Boundary-Loads">Boundary Loads</a><a id="Boundary-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Loads" title="Permalink"></a></h2><p>Two functions are provided below to create loads and load sets. The <a href="#HSSSimulations.Boundary.basicLoad"><code>basicLoad</code></a> function creates a single basic load that can be used with <a href="#HSSSimulations.Solver.FixedLoadSet"><code>FixedLoadSet</code></a> and <a href="#HSSSimulations.Solver.LayerLoadSet"><code>LayerLoadSet</code></a> to make load sets for the <code>loadSets</code> argument of the <a href="#HSSSimulations.Types.Problem-Tuple{}"><code>Problem</code></a>. For information on how to make more loads, see <a href="../boundary/#Boundary-Model">Boundary Model</a>.</p><p>The <a href="#HSSSimulations.HSSBound.HSSLoads"><code>HSSLoads</code></a> constructor creates a full list of load sets needed to simulate a typical HSS build. For more information on these loads, see <a href="../hssbound/#HSS-Boundary">HSS Boundary</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.basicLoad" href="#HSSSimulations.Boundary.basicLoad"><code>HSSSimulations.Boundary.basicLoad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basicLoad(
    tₗ,
    skip
) -&gt; Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}
</code></pre><p>A basic <a href="../boundary/#HSSSimulations.Types.Load"><code>Types.Load</code></a> with a conduction boundary on the bottom surface and a convection boundary on the top. All other surfaces are symetrical boundaries.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loadStep = basicLoad(5, 2)
  x₁ : SymetryBoundary
  x₂ : SymetryBoundary
  y₁ : SymetryBoundary
  y₂ : SymetryBoundary
  z₁ : ConductionBoundary
  z₂ : ConvectionBoundary
  name : NA
  tₗ : 5.0
  skip : 2</code></pre><p>This returns a single <code>Load</code>, for a single load step. To make a load set you will need an array of <code>Load</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/loads.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.FixedLoadSet" href="#HSSSimulations.Solver.FixedLoadSet"><code>HSSSimulations.Solver.FixedLoadSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FixedLoadSet &lt;: AbstractLoadSet</code></pre><p>#Fields</p><ul><li><p><code>name::String</code>: Name of the load set</p></li><li><p><code>loads::Vector{Load}</code>: List of loads for load set</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/loadSetSolve.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Solver.LayerLoadSet" href="#HSSSimulations.Solver.LayerLoadSet"><code>HSSSimulations.Solver.LayerLoadSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LayerLoadSet &lt;: AbstractLoadSet</code></pre><p>#Fields</p><ul><li><p><code>name::String</code>: Name of the load set</p></li><li><p><code>finishLayer::Int64</code>: The last layer to deposit as part of this load set</p></li><li><p><code>loads::Vector{Load}</code>: List of loads for load set</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Solver/loadSetSolve.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.HSSBound.HSSLoads" href="#HSSSimulations.HSSBound.HSSLoads"><code>HSSSimulations.HSSBound.HSSLoads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HSSLoads(
    skip,
    geometry;
    nrPreheat,
    lenPreheat,
    nrCool,
    lenCool,
    sinterSpeed,
    lcAndBedWidth
) -&gt; Vector{AbstractLoadSet}
</code></pre><p>Returns a list of load sets, one for the preheat, build, and cooldown phases of a default build for the HSS example. The same <code>skip</code> is used for all load steps (See <a href="../../explanation/faqs/#Why-We-Skip-Some-Results">Why We Skip Some Results</a> for more information on <code>skip</code>).</p><p>The loads used in these load sets are explained further below, and all assume the use of the <a href="../hssbound/#HSSSimulations.HSSBound.HSSParams"><code>HSSParams</code></a> parameter set.</p><pre><code class="language-julia-repl hljs">julia&gt; HSSLoads(10, Geometry((1,1,1),1,1); nrPreheat=5, lenPreheat=60.0, nrCool=5, lenCool=60.0, sinterSpeed=0.160)
3-element Vector{AbstractLoadSet}:
   name : Preheat
  loads
----------------------

  Name: Overheads Only
  For 5 loads



   name : Layer
  finishLayer : 0
  loads
----------------------

  Name: Overheads Only
  Name: Sintering
  Name: Overheads Only
  Name: Recoating
  Name: Overheads Only
  Name: No Inking
  Name: Overheads Only
  Name: Inking



   name : Cooldown
  loads
----------------------

  Name: Overheads Off
  For 5 loads</code></pre><p><strong>Extended help</strong></p><p>Here we will cover the details on exactly what it is that the example boundary is replicating. We will cover this one boundary at a time. As the simulation is a cuboid, it has six external surfaces, each of which must have defined boundary conditions.</p><p>The simulation is to be compared to an array of identical, symmetrical parts being printed. Assuming that this array is infinite results in a symmetrical boundary condition. This means that the four conditions representing the side walls (x₁, x₂, y₁ and y₂ in the notation used in <a href="../boundary/#HSSSimulations.Types.Load"><code>Types.Load</code></a>), can all use the default boundary condition provided by <a href="../boundary/#HSSSimulations.Boundary.SymetryBoundary"><code>Boundary.SymetryBoundary</code></a>.</p><p>The bottom boundary (z₁) is where the build bed is in contact with the piston. As the piston is one of the few consistent things on our machine, this can be simulated as a constant temperature boundary with a contact conduction coefficient. This is done using <a href="../hssbound/#HSSSimulations.HSSBound.PistonBoundary"><code>HSSBound.PistonBoundary</code></a>.</p><p>The final boundary, the top surface of the powder (z₂) is by far the most complicated. It changes constantly throughout the build as new layers are added and sintered.</p><p><strong>Overhead Heaters</strong></p><p>In the default state with nothing happening the top boundary has heat loss due to convection to the forced air draft over the surface and loss from radiation to the surrounding surfaces. In addition, there is a stationary overhead heater. During preheating (during the <a href="#HSSSimulations.Solver.FixedLoadSet"><code>FixedLoadSet</code></a> named Preheat) the overhead heater is set to a fixed power (Simulated using <a href="../hssbound/#HSSSimulations.HSSBound.loadOverheads"><code>HSSBound.loadOverheads</code></a>).</p><p>Once the build starts (during the <a href="#HSSSimulations.Solver.LayerLoadSet"><code>LayerLoadSet</code></a> named Layer), the overhead power is adjusted, starting at a set amount (usually around 60% (of a 300W heater)) and changing by a set amount (usually 1 percent of maximum power) every set number of layers (usually every 3 layers) with the goal of reaching the target temperature of the top surface (Simulated using <a href="../hssbound/#HSSSimulations.HSSBound.loadOverheads"><code>HSSBound.loadOverheads</code></a>). Once the build is finished (during the <a href="#HSSSimulations.Solver.FixedLoadSet"><code>FixedLoadSet</code></a> named Cooldown) the overhead is turned off (set to 0W power) and left to cool down (Simulated using <a href="../hssbound/#HSSSimulations.HSSBound.loadCooldown"><code>HSSBound.loadCooldown</code></a>).</p><p>The overhead heater boundary is implemented as a radiation boundary condition, because of this the overhead temperature is needed (not the input power, which is all we defined above). For this, the <a href="../hssbound/#HSSSimulations.HSSBound.overheadTempFunc"><code>HSSBound.overheadTempFunc</code></a> is used to calculate the overhead temperature based on its previous temperature and the change in temperature caused by its current input power.</p><p><strong>Carriages</strong></p><p>Most of this change comes from the movement of two carriages, the lamp carriage and the print carriage. The first contains both the powder hopper (for recoating) and the sinter lamp. The second contains the print heads used to deposit the absorptive ink.</p><p>During each layer the following happens (described as if looking from the front of the machine, with the x-axis going front to back, and slightly confusingly the y-axis going right to left (don&#39;t ask, I regret this choice)):</p><ul><li>The lamp carriage moves from left to right with the lamp set at sinter power   (<a href="../hssbound/#HSSSimulations.HSSBound.loadSinterStroke"><code>loadSinterStroke</code></a>)</li><li>The lamp carriage moves from right to left with the lamp set to recoat power and the powder hopper   deposits a layer of powder (<a href="../hssbound/#HSSSimulations.HSSBound.loadRecoatStroke"><code>loadRecoatStroke</code></a>)</li><li>The print carriage moves from right to left whilst doing nothing special   (<a href="../hssbound/#HSSSimulations.HSSBound.loadBlankStroke"><code>loadBlankStroke</code></a>)</li><li>The print carriage moves from left to right as the print heads deposit the ink   (<a href="../hssbound/#HSSSimulations.HSSBound.loadInkStroke"><code>loadInkStroke</code></a>)</li></ul><p>In between each of the above steps are brief moments of simplicity, where the only boundary conditions are those covered in previous sections. These gaps use the aforementioned <a href="../hssbound/#HSSSimulations.HSSBound.loadOverheads"><code>HSSBound.loadOverheads</code></a>. The carriage boundaries are only actually used when the carriages are over the build bed, it is assumed that if they are moving but not over the bed then they have no impact on the boundary conditions so the <a href="../hssbound/#HSSSimulations.HSSBound.loadOverheads"><code>HSSBound.loadOverheads</code></a> can be used instead.</p><p>It is also worth noting, that when a carriage is in over the top of the build bed, the build bed is shadowed from the overheads, which is modeled in each of the four carriage loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/HSSBound/HSSLoads.jl#L1">source</a></section></article><h2 id="Boundary-Parameters"><a class="docs-heading-anchor" href="#Boundary-Parameters">Boundary Parameters</a><a id="Boundary-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Boundary.BasicProblemParams" href="#HSSSimulations.Boundary.BasicProblemParams"><code>HSSSimulations.Boundary.BasicProblemParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A basic implementation of a <a href="../boundary/#HSSSimulations.Types.AbstractProblemParams"><code>Types.AbstractProblemParams</code></a> struct to go along with <a href="#HSSSimulations.Boundary.basicLoad"><code>basicLoad</code></a>. For a more elaborate example see <code>HSSParams</code></p><p><strong>Fields</strong></p><ul><li><p><code>condCoef::Float64</code>: The contact conduction coefficent for the bottom face</p></li><li><p><code>condTemp::Any</code>: The temperature of the surface in contact with the bottom face</p></li><li><p><code>convCoef::Float64</code>: The convection coefficent for the top face to the air above</p></li><li><p><code>convTemp::Any</code>: The temperature of the air in contact with the top face</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Boundary/loads.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.HSSBound.HSSParams-Tuple{Geometry}" href="#HSSSimulations.HSSBound.HSSParams-Tuple{Geometry}"><code>HSSSimulations.HSSBound.HSSParams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HSSParams(Geometry; kwargs...) -&gt; HSSParams</code></pre><p>The <code>geometry</code> (of type <a href="../types/#HSSSimulations.Types.Geometry"><code>Geometry</code></a>) should be the same one used for the simulation. If the piston target temperature is chaneged then the piston path will need to be changed to curves that will match the target temperature. The same applies if the preheat bed is thicker than the normal ≈3 mm.</p><p>This is intended to proved the required parameters for the load sets produced by <a href="#HSSSimulations.HSSBound.HSSLoads"><code>HSSLoads</code></a>.</p><p>See <a href="../hssbound/#HSSSimulations.HSSBound.HSSParams"><code>HSSParams</code></a> for information on the fields of the created struct.</p><p><strong>Arguments</strong></p><ul><li><p><code>name = &quot;HSS example problem boundary&quot;</code>: A name for the parameter set, only used for user reference.</p></li><li><p><code>pistonPath = joinpath(artifact&quot;HSS&quot;, &quot;HSS_Piston.jld2&quot;)</code>: Where to find the piston heat up and cool down curves data file.</p></li><li><p><code>airPath = joinpath(artifact&quot;HSS&quot;, &quot;HSS_Surface.jld2&quot;)</code>: Where to find the machine&#39;s internal surface heat up and cool down curves data file.</p></li><li><p><code>surfacePath = joinpath(artifact&quot;HSS&quot;, &quot;HSS_Air.jld2&quot;)</code>: Where to find the machine&#39;s internal air heat up and cool down curves data file.</p></li><li><p><code>conductionCoef = 7500.0</code>: The conduction coefficient of the top surface of the bed, in W/m²k.</p></li><li><p><code>lampVector = [0.0, 1, 2, 2, 2, 2, 2, 1, 0]</code>: The y-axis distribution of the lamp power, see <a href="../hssbound/#HSSSimulations.HSSBound.lampMaker"><code>lampMaker</code></a> for more details.</p></li><li><p><code>lampWidth = 0.100</code>: The width of the lamps power distribution, in meters.</p></li><li><p><code>lampOffset = 0.175</code>: The distance between the left edge of the lamp carriage and th left edge of the lamp&#39;s distribution, in meters.</p></li><li><p><code>carriageWidth = 0.275</code>: The width of the lamp/recoater carriage, in meters.</p></li><li><p><code>recoatOffset = 0.045</code>: The offset between the left edge of the recoater carriage and the left edge of the recoater, in meters.</p></li><li><p><code>printCarriageWidth = 0.180</code>: The width of the print head carriage, in meters.</p></li><li><p><code>printOffset = 0.110</code>: The offset between the left edge of the print head carriage and the left edge of the print nozzles.</p></li><li><p><code>surfaceTarget = 160.0</code>: The target temperature of the top surface of the powder bed. Used to control the overhead heaters, in °C.</p></li><li><p><code>surfaceTol = 1.0</code>: The tolerance of the bed surface temperature when compared to the target temperature, in °C.</p></li><li><p><code>overheadLayerStep = 3</code>: How often, in number of layers, to update the overhead power based on the bed surface temperature.</p></li><li><p><code>overheadPercentStep = 1.0</code>: How big of a step in overhead power to make each time they are updated, in % of total power.</p></li><li><p><code>overheadTemp = 25.0</code>: The starting temperature of the overhead heaters themselves, in °C.</p></li><li><p><code>overheadPower = 0.6 * 300</code>: The starting input power of the overhead heaters, in watts.</p></li><li><p><code>overheadPowerOut = T -&gt; (0.596T - 12.2)</code>: A function that takes the current overhead heater temperature and returns the output power of the heater.</p></li><li><p><code>overheadHeatCapacity = 118.923</code>: The heat capacity of the overhead heaters, in J/K.</p></li><li><p><code>overheadMaxPower = 300.0</code>: The maximum input power of the overhead heaters.</p></li><li><p><code>convectionCoef = 4.0</code>: The convection coefficient of the top surface of the bed, in W/m²k.</p></li><li><p><code>sinterPower = 2000.0</code>: The output power of the sinter lamp during the sinter stroke.</p></li><li><p><code>recoatPower = 0.0</code>: The output power of the sinter lamp during the recoat stroke.</p></li><li><p><code>lastUpdatedOverhead = 0</code>: The last layer the overhead heaters were updated on.</p></li><li><p><code>percentOverhead = 0.2125</code>: The percentage of the surfaces that the top surface of the powder bed is exposed to that is the overhead heaters, as opposed to the other internal surfaces of the machine.</p></li><li><p><code>powderTempDelta = 25</code>: The difference between the surface temperature of the machine and the temperature of the powder being deposited.</p></li><li><p><code>overheadHeatupFunc</code>: A function that takes an input power and a previous overhead heater temperature and returns the temperature for the overhead heaters for the next time step. This uses <a href="../hssbound/#HSSSimulations.HSSBound.overheadTempFunc"><code>HSSBound.overheadTempFunc</code></a> by default, using the function shown below:</p></li></ul><pre><code class="language-julia hljs">overheadHeatupFunc = function (powerIn::Float64, prevOverheadTemp::Float64, _)
    return overheadTempFunc(
        powerIn,
        overheadPowerOut,
        overheadHeatCapacity,
        geometry.Δt,
        prevOverheadTemp,
    )
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/HSSBound/HSSParams.jl#L102-L175">source</a></section></article><h2 id="Settings"><a class="docs-heading-anchor" href="#Settings">Settings</a><a id="Settings-1"></a><a class="docs-heading-anchor-permalink" href="#Settings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.Options" href="#HSSSimulations.Types.Options"><code>HSSSimulations.Types.Options</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Options</code></pre><p><strong>Fields</strong></p><ul><li><p><code>compress::Union{Bool, TranscodingStreams.Codec}</code>: How to compress the results file, can be set to true (to compress), false (to leave uncompressed) or to a specific compression algorithm (see <a href="https://juliaio.github.io/JLD2.jl/dev/compression/">the JLD2 documentation</a> for more details)</p></li><li><p><code>debug::Union{Bool, Vector{String}}</code>: Whether or not to log debug information, can accept a list of strings to select only some debugging groups, see <a href="#HSSSimulations.Types.package_groups"><code>package_groups</code></a></p></li><li><p><code>showProgress::Union{Bool, Float64}</code>: Whether or not to show the progres meter, if a number is given that is used as the update interval</p></li><li><p><code>notify::Bool</code>: If true, simulations finishing will send a system notification using Alert.jl</p></li></ul><p>The <code>debug</code> option is passed to the logGroups option of <code>Solver.makeLogger</code>, check that out for more information and <a href="#HSSSimulations.Types.package_groups"><code>package_groups</code></a> for what log groups are available by default.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Depending on settings, the debug option might log a lot of things, the log file could end up somewhere in the region of 4x the size of the compressed results file, so make sure you clean them up after you&#39;re done.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/types.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HSSSimulations.Types.package_groups" href="#HSSSimulations.Types.package_groups"><code>HSSSimulations.Types.package_groups</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A list of all of the log groups used in this package. They log the following things:</p><ul><li><code>core</code>: the start of a problem, loadstep, load or timestep has started</li><li><code>solver</code>: the fdm solver</li><li><code>mat</code>: material model</li><li><code>bound</code>: boundary condition</li><li><code>b_adv</code>: recoating and moving object boundaries</li><li><code>hss</code>: HSS example functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/17b12005d300f8c4670a64cbdb693ce5c2d186aa/src/Types/types.jl#L122-L131">source</a></section></article><h2 id="Results-File-Structure"><a class="docs-heading-anchor" href="#Results-File-Structure">Results File Structure</a><a id="Results-File-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Results-File-Structure" title="Permalink"></a></h2><p>The last part of the API to cover is the format of the simulation results that are saved. These use the <code>JLD2</code> package to save to a Hierarchical Data Format version 5 (HDF5) based format. Most of the information stored should be readable by any HDF5 compatible software or libraries, except the input problem, which requires the software to understand Julia types (the easiest way is to just use Julia, it&#39;s mostly saved in case it needs to be rerun).</p><p>By default, this is stored compressed using the <code>ZlibCompressor</code> compressor.</p><p>The results have the following structure:</p><pre><code class="language-text hljs">Tree                           Description
Results
│
├─ Description                 - An overview of the problem that has been solved
├─ Input                       - The full problem struct that has been solved
├─ Start_Time                  - The computer&#39;s clock time at the end of the simulation
├── Results
│   ├─ MeltMax                 - The maximum melt state reached in the simulation
│   │
│   ├── Preheat-1              - List of loads run during the preheating load set
│   │   ├─ 1
│   │   ├─ 2
│   │   └─ ⋯ (3 more entries)
│   │
│   ├── Layer-2                - 1st Layer
│   │   ├─ 1                   - 1st Layer&#39;s 1st Load
│   │   ├─ 2                   - 1st Layer&#39;s 2nd Load
│   │   └─ ⋯ (6 more entries)  - And so on for the remaining loads
│   │
│   ├── Layer-3                - 2nd Layer
│   │   ├─ 1 (5 entries)
│   │   ├─ 2
│   │   └─ ⋯ (6 more entries)
│   │
│   ├─ ⋯ (25 more entries)     - And so on for the remaining layers
│   │
│   └── Cooldown-28            - List of loads run during the cooldown load set
│       ├─ 1
│       ├─ 2
│       └─ ⋯ (3 more entries)
│
├─ Results_Index               - A list of all load results indices within this file
├─ Finish_Time                 - The computer&#39;s clock time at the end of the simulation
└─ _types                      - Ignore (Used internally by JLD2)</code></pre><p>Where each of the loads has these fields:</p><pre><code class="language-text hljs">Tree           Description

Load
├─ name        - The load&#39;s name
├─ time        - 1D array of the times of the load&#39;s time steps
├─ T           - 4D array of temperatures (X, Y, Z, time step)
├─ M           - 4D array of melt states (X, Y, Z, time step)
└─ C           - 4D array of consolidation states (X, Y, Z, time step)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><a href="../res/#HSSSimulations.Results.loadStepSaver"><code>Results.loadStepSaver</code></a>, <a href="../res/#HSSSimulations.Results.otherResults"><code>Solver.otherResults</code></a>, are the two functions used for saving simulation results to the file. so looking at their implementation might help with if anything is not covered here. <a href="../solver/#HSSSimulations.Solver.startMetadata"><code>Solver.startMetadata</code></a> and <a href="../solver/#HSSSimulations.Solver.finishMetadata"><code>Solver.finishMetadata</code></a> are also used to save a few extra bits of metadata to the file. I&#39;d also recommend a tool like <a href="https://www.hdfgroup.org/downloads/hdfview/">HDFView</a> to get an idea for the structure of the results.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/4_res_tut/">« Tutorial 4: Saving More Results</a><a class="docs-footer-nextpage" href="../adv_intro/">Advanced API Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 28 February 2024 23:46">Wednesday 28 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
