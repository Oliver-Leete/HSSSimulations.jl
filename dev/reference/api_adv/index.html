<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced API · High Speed Sintering Simulations</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">High Speed Sintering Simulations</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/1_full_tut/">1 Full Build</a></li><li><a class="tocitem" href="../../tutorials/2_basic_tut/">2 Warm-up and Cool-down only</a></li><li><a class="tocitem" href="../../tutorials/3_material_tut/">3 A Melt Rate Based Material Model</a></li><li><a class="tocitem" href="../../tutorials/4_res_tut/">4 Saving More Results</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../api/">Main API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../adv_intro/">Introduction</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../res/">Res</a></li><li><a class="tocitem" href="../material/">Material</a></li><li><a class="tocitem" href="../boundary/">Boundary</a></li><li><a class="tocitem" href="../solver/">Solver</a></li><li><a class="tocitem" href="../postprocessing/">PostProcessing</a></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Patterns</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulate Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Materials</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Models</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Results</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Loads and Load Sets</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundaries</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Types</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solvers</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/HSSBoundary/">HSS Boundary</a></li><li><a class="tocitem" href="../MaterialExamples/">Material examples</a></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li></ul></li><li><a class="tocitem" href="../../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Advanced API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/src/reference/api_adv.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-API"><a class="docs-heading-anchor" href="#Advanced-API">Advanced API</a><a id="Advanced-API-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-API" title="Permalink"></a></h1><p>These APIs are exported by their module, but not exported by the package, so to use them you will need to either use their full address:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using HSSSimulations</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Solver.loadSetSolver!</code><code class="nohighlight hljs ansi" style="display:block;">loadSetSolver! (generic function with 2 methods)</code></pre><p>or by using the module it is in:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using HSSSimulations</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using .Solver</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; loadSetSolver!</code><code class="nohighlight hljs ansi" style="display:block;">loadSetSolver! (generic function with 2 methods)</code></pre><ul><li><ul><li><ul><li></li></ul></li></ul></li></ul><h2 id="Custom-Load-Sets"><a class="docs-heading-anchor" href="#Custom-Load-Sets">Custom Load Sets</a><a id="Custom-Load-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Load-Sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.loadSetSolver!" href="#HSSSimulations.Solver.loadSetSolver!"><code>HSSSimulations.Solver.loadSetSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadSetSolver!(
    loadSet&lt;:AbstractLoadSet
    initResult::AbstractResult,
    layerNum::Int,
    prob::Problem{T,Gh,Mp,R,OR,B},
) where {T&lt;:Any,Gh&lt;:Any,Mp&lt;:Any,R&lt;:Any,OR&lt;:Any,B&lt;:Any}</code></pre><p>This function is run once for each <code>LoadSet</code> passed in to the problem, and dispatched on the type of that load set. For basic load sets, like <a href="#HSSSimulations.Solver.FixedLoadSet"><code>FixedLoadSet</code></a>, it should basically just pass the arguments on to the <a href="#HSSSimulations.Solver.innerLoadSetSolver!"><code>innerLoadSetSolver!</code></a> function, the one exception being the list of loads being passed in instead of the <a href="#HSSSimulations.Types.AbstractLoadSet"><code>AbstractLoadSet</code></a> struct. For more complicated load sets, like <a href="#HSSSimulations.Solver.LayerLoadSet"><code>LayerLoadSet</code></a>, this should include the logic used for that load set. For <a href="#HSSSimulations.Solver.LayerLoadSet"><code>LayerLoadSet</code></a> this is a loop that loops over the list of loads once for each layer, incrementing the layer number as it goes.</p><p>For examples see the source code for the two default implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/loadSetSolve.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractLoadSet" href="#HSSSimulations.Types.AbstractLoadSet"><code>HSSSimulations.Types.AbstractLoadSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLoadSet &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>This struct holds the information for a load set, primarily the list of loads, but also some extra bits. Subtypes should implement a method for the <code>Solver.loadSetSolver!</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/boundaryTypes.jl#L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.FixedLoadSet" href="#HSSSimulations.Solver.FixedLoadSet"><code>HSSSimulations.Solver.FixedLoadSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FixedLoadSet &lt;: AbstractLoadSet</code></pre><p>#Fields</p><ul><li><code>name::String</code>: Name of the load set</li><li><code>loads::Vector{Load}</code>: List of loads for load set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/loadSetSolve.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{FixedLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{FixedLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.Solver.loadSetSolver!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadSetSolver!(
    loadSet::FixedLoadSet,
    initResult::AbstractResult,
    layerNum::Int64,
    prob::Problem{T, Gh, Mp, R, OR, B}
) -&gt; Tuple{AbstractResult, Int64}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/loadSetSolve.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.LayerLoadSet" href="#HSSSimulations.Solver.LayerLoadSet"><code>HSSSimulations.Solver.LayerLoadSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LayerLoadSet &lt;: AbstractLoadSet</code></pre><p>#Fields</p><ul><li><code>name::String</code>: Name of the load set</li><li><code>finishLayer::Int64</code>: The last layer to deposit as part of this load set</li><li><code>loads::Vector{Load}</code>: List of loads for load set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/loadSetSolve.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{LayerLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{LayerLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.Solver.loadSetSolver!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadSetSolver!(
    loadSet::LayerLoadSet,
    initResult::AbstractResult,
    initLayerNum::Int64,
    prob::Problem{T, Gh, Mp, R, OR, B}
) -&gt; Tuple{AbstractResult, Int64}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/loadSetSolve.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.innerLoadSetSolver!" href="#HSSSimulations.Solver.innerLoadSetSolver!"><code>HSSSimulations.Solver.innerLoadSetSolver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">innerLoadSetSolver!(
    loads::Vector{Load},
    initResult::AbstractResult,
    layerNum,
    prob::Problem;
    name,
    recoat,
    prevLayerNum
)
</code></pre><p>Solves a load set of a problem, iterating over and solving the loads in the given load set in order. The results for a load is saved to the file after solving it.</p><p>If the list of loads passed given include powder deposition, the <code>recoat</code> kwarg should be set to true, with the <code>layerNum</code> set to the thickness of the powder bed in layers that is desired at the end of the loads. If this is more than one layer thicker than the previous value, then the previous values should also be passed in to <code>prevLayerNum</code>.</p><p>It also helps to provide a unique name. This is the name that will be used to store the results from runnning the list of loads in the output file, and also will be used as the label in the progress meter. If no name is given then the current time is used instead. If the name given is not unique then you will get a run time error when it tries to save results to a place that is already taken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/loadSetSolve.jl#L87">source</a></section></article><h2 id="Custom-Materials"><a class="docs-heading-anchor" href="#Custom-Materials">Custom Materials</a><a id="Custom-Materials-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Materials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.MatProp" href="#HSSSimulations.Material.MatProp"><code>HSSSimulations.Material.MatProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MatProp{T1, T2, T3, T4, T5, T6, T7, T8, T9} &lt;: AbstractMatProp</code></pre><p>The default implementation of <a href="#HSSSimulations.Types.AbstractMatProp"><code>AbstractMatProp</code></a> used by the default <a href="#HSSSimulations.Material.calcMatProps!"><code>Material.calcMatProps!</code></a> method. See <a href="../MaterialExamples/#Material-Examples">Material Examples</a> for some premade materials. The arguments to its constructor are the same as the matching fields. The only addition is the geometry argument, which should just be the <a href="../types/#HSSSimulations.Types.Geometry"><code>Geometry</code></a> struct of for the simulation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The maximum melt state is never reset, so if a node goes from the melt region to the recrystalisation region more than once in a simulation, the behaviour might not be modeled properly.</p></div></div><p><strong>Fields</strong></p><ul><li><code>ρ::Any</code>:  Density.    Two dimensional interpolations, with inputs in axis 1 = consolidation state, axis 2 = melt state.</li><li><code>c::Any</code>:  Specific heat capacity.    One dimensional interpolations with the node&#39;s temperature as it&#39;s input.</li><li><code>κ::Any</code>:  Thermal conductivity.    Three dimensional interpolations, with inputs in axis 1 = consolidation state, axis 2 = temperature and axis 3    = melt state.</li><li><code>Mᵣ::Any</code>:  Melting range and temp relationship.    A 1d interpolation, with the only input axis being the temperature and the output is the melt state.</li><li><code>Mₛ::Float64</code>: The start temperature of the melt range</li><li><code>Mₑ::Float64</code>: The end temperature of the melt range</li><li><code>Rᵣ::Any</code>:  Crystallisation range and temp relationship.    A 2d interpolation, with the first input axis being the node temperature and the second input axis    being the maximum melt state reached. The output is the melt state.</li><li><code>Rₛ::Float64</code>: The start temperature of the recrystalisation range</li><li><code>Rₑ::Float64</code>: The end temperature of the recrystalisation range</li><li><code>Hf::Any</code>: Total specific heat of melting</li><li><code>Hr::Any</code>:  Total specific heat of fusion.    A 1d Interpolation where the input is the maximum melt state reached and the output is the total    heat of fusion.</li><li><code>Ċ::Any</code>:  Consolidation rate.    Either a single value representing a constant consolidation rate, or a 2d interpolation, with the    first axis being the node temperature and the second being the node melt state. The output is the    rate of change of sinter state.</li><li><code>eₚ::Float64</code>:  Emmisivity of the powder.    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.</li><li><code>eᵢ::Float64</code>:  Emmisivity of the powder with ink on it.    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.</li><li><code>ε::Float64</code>:  Black body emmisivity of the powder</li><li><code>name::String</code>: Just used for future reference</li><li><code>Mₘ::Any</code>: Used by the material model to track the maximum melt state reached per node</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.MatProp-NTuple{13, Any}" href="#HSSSimulations.Material.MatProp-NTuple{13, Any}"><code>HSSSimulations.Material.MatProp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MatProp(
    ρ,
    c,
    κ,
    Mᵣ,
    Rᵣ,
    Hf,
    Hr,
    Ċ,
    eₚ,
    eᵢ,
    ε,
    name,
    geometry
) -&gt; MatProp
</code></pre><p>Default constructor for <a href="#HSSSimulations.Material.MatProp"><code>MatProp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L79">source</a></section></article><h3 id="Custom-Material-Models"><a class="docs-heading-anchor" href="#Custom-Material-Models">Custom Material Models</a><a id="Custom-Material-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Material-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractMatProp" href="#HSSSimulations.Types.AbstractMatProp"><code>HSSSimulations.Types.AbstractMatProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMatProp &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>The abstract type that any material property struct needs to be a subtype of. These are for storing the values used to define the properties of a material, and those used to calculate the changes in material properties due to the build. The default struct used is <code>MatProp</code>, however new subtypes can be defined and used by defining a new <code>Material.calcMatProps!</code> function. This allows for the simplificiation (or complication) of the material model used in the simulation to fit your needs.</p><p>Any new subtype will need it&#39;s own method writen for <code>calcMatProps!</code> and if the example boundaries are being used some of them might need to be updated to use the new material properties. If melt state or consolidation state are beind removed from the material model then it might be worth implementing a new <a href="#HSSSimulations.Types.AbstractResult"><code>AbstractResult</code></a> to save on memory. If an additional property that needs to be tracked is added to the material model then it will be necissary to implement a new subtype of those to track this.</p><p>See <a href="../../howtos/howto_matprop/#Material-Model-Recipes">Material Model Recipes</a> and <a href="../../tutorials/3_material_tut/#Tutorial-3:-A-Melt-Rate-Based-Material-Model">Tutorial 3: A Melt Rate Based Material Model</a> for more information on implementing your own.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/types.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.calcMatProps!" href="#HSSSimulations.Material.calcMatProps!"><code>HSSSimulations.Material.calcMatProps!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calcMatProps!(::AbstractResult, ::AbstractResult, &lt;:Problem, ::Indices)</code></pre><p>Updates any of the material properties that change, along with the Fourier number for the current time step. New methods can be defined by dispatching on <code>Problem</code> with a different subtype of MatProp (for more information on this, see <a href="#HSSSimulations.Types.AbstractMatProp"><code>Types.AbstractMatProp</code></a>). The two main functions called by this one, <a href="#HSSSimulations.Material.meltUpdate"><code>meltUpdate</code></a> and <a href="#HSSSimulations.Material.consUpdate"><code>consUpdate</code></a>, are both also dispatched on the type of the material property struct, so they can be overwritten individually for a new material property struct if the new material model only needs to change some of the behaviour.</p><p><strong>Arguments</strong></p><ul><li><code>cts</code>: Current time step results</li><li><code>pts</code>: Previous time step results</li><li><code>ind</code>: The indicies to update</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L107-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.calcMatProps!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp&lt;:AbstractMatProp, R, OR, B}" href="#HSSSimulations.Material.calcMatProps!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp&lt;:AbstractMatProp, R, OR, B}"><code>HSSSimulations.Material.calcMatProps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcMatProps!(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp&lt;:AbstractMatProp, R, OR, B},
    ind
)
</code></pre><p>The default material model, designed to be used with <a href="#HSSSimulations.Material.MatProp"><code>MatProp</code></a>, but should work with any <a href="#HSSSimulations.Types.AbstractMatProp"><code>Types.AbstractMatProp</code></a> that shares <a href="#HSSSimulations.Material.MatProp"><code>MatProp</code></a>&#39;s <code>ρ</code>, <code>c</code>, <code>κ</code> and <code>Mₘ</code> fields. </p><p>Updates melt and consolidation state, and then uses those to update the density, heat capacity and conductivity. These are then used to calculate the Fourier number for each axis for this time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.meltUpdate" href="#HSSSimulations.Material.meltUpdate"><code>HSSSimulations.Material.meltUpdate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meltUpdate(Mᵗ⁻¹, T, Mₘ, Δt, mp::AbstractMatProp) -&gt; Mᵗ, Mₘ, Δh</code></pre><p>Calculates the new melt state of a single node. It is given the melt state and temperature of the node in the previous time step, the maximum melt state the node has reached so far, the duration of the current time step and the material property struct.</p><p>It should return the new melt state for the node, the new maximum melt state, and the specific enthalpy change due to fusion or recrystalisation that is associated with the change in melt state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.meltUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}" href="#HSSSimulations.Material.meltUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}"><code>HSSSimulations.Material.meltUpdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meltUpdate(
    Mᵗ⁻¹,
    T,
    Mₘ,
    _,
    mp::AbstractMatProp
) -&gt; Tuple{Any, Any, Any}
</code></pre><p>Updates the melt state of a node if the temperature of the node is in the melting or crystalisation termperature range if not the existing value is returned. This uses a basic time independent model that associates a single melt state to a given combination of temperature and maximum melt state reached so far.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.consUpdate" href="#HSSSimulations.Material.consUpdate"><code>HSSSimulations.Material.consUpdate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">consUpdate(C, M, T, Δt, mp::AbstractMatProp) -&gt; C</code></pre><p>Calculates the new consolidation state of a single node. It is given the current consolidation state, melt state and temperature of the node, the duration of the current time step and the material property struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.consUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}" href="#HSSSimulations.Material.consUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}"><code>HSSSimulations.Material.consUpdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">consUpdate(C, M, T, Δt, mp::AbstractMatProp) -&gt; Any
</code></pre><p>Updates the consolidation state of a node by adding the change in consolidation state (rate * time) to the previous consolidation state. Only applies if the material is melted and not already fully consolidated.</p><p>This finds the consolidation rate by calling <code>mp.Ċ</code> with <code>C</code>, <code>T</code> and <code>M</code> as arguments.</p><p>The returned values maximum is limited to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/materialProps.jl#L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Material.PA_Ċ_maker" href="#HSSSimulations.Material.PA_Ċ_maker"><code>HSSSimulations.Material.PA_Ċ_maker</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Based on model from Childs and Tontowi 2001. Modified to work off of consolidation and melt states. Takes three coefficients and returns a consolidation rate calculator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Material/PA2200.jl#L95-L98">source</a></section></article><h2 id="Custom-Results"><a class="docs-heading-anchor" href="#Custom-Results">Custom Results</a><a id="Custom-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractResult" href="#HSSSimulations.Types.AbstractResult"><code>HSSSimulations.Types.AbstractResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractResult &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>This as the abstract type for the results from a single simulation time step. See <a href="../../tutorials/4_res_tut/#Tutorial-4:-Saving-More-Results">Tutorial 4: Saving More Results</a> and <a href="../../howtos/howto_result/#Result-Type-Recipes">Result Type Recipes</a> for how to make your own subtype.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As this struct is what stores the data during the simulation, all subtypes <strong>MUST</strong> have the <code>T</code>, <code>t</code> and <code>tₚ</code> fields, and if used with the default material model it will also need the <code>M</code> and <code>C</code> fields.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/types.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Res.loadStepSaver" href="#HSSSimulations.Res.loadStepSaver"><code>HSSSimulations.Res.loadStepSaver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadSave(loadResultsFolder, loadResults::StructVector{T}) where {T&lt;:AbstractResult}</code></pre><p>Saves the results of a load step into the folder for the current load step in the output file of the problem, given by the <code>loadResultsFolder</code> argument.</p><p>Any new methods for this function should dispatch on the type parameter of the <code>loadResults</code>, and save any desired results to the file like so:</p><pre><code class="language-julia hljs">function loadStepSaver(loadResultsFolder, loadResults::StructVector{T}) where {T&lt;:AbstractResult}
    loadResultsFolder[&quot;time&quot;] = loadResults.t
    loadResultsFolder[&quot;T&quot;] = stack(loadResults.T)
    return
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stack</code> is used as a very efficient way of converting the vector of 3D arrays from the <code>StructVector</code> in to a 4D array.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/results.jl#L66-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Res.loadStepSaver-Union{Tuple{T}, Tuple{Any, StructVector{T}}} where T&lt;:Result" href="#HSSSimulations.Res.loadStepSaver-Union{Tuple{T}, Tuple{Any, StructVector{T}}} where T&lt;:Result"><code>HSSSimulations.Res.loadStepSaver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loadStepSaver(
    loadResultsFolder,
    loadResults::StructArray{T&lt;:Result, 1}
)
</code></pre><p>Saves the results for the temperature, melt state and consolidation state as 4D arrays of X,Y,Z and t. And the time is saved as a 1D Array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/results.jl#L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractOtherResults" href="#HSSSimulations.Types.AbstractOtherResults"><code>HSSSimulations.Types.AbstractOtherResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractOtherResults &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>This as the abstract type for the results that are saved only at the end of the simulation. This is useful to store things that do not change every time step, without requiring any changes to the material property or params structs. However those structs can also be used to store such things, such as is done for Mₘ in the <code>MatProp</code> struct.</p><p>As the default implementation does nothing, and nothing normally dispatches on it, it can be replaced by another empty type to use a new method for any function that dispatches on <a href="../types/#HSSSimulations.Types.Problem"><code>Problem</code></a> (I think that&#39;s all of the user facing API).</p><p><a href="../../tutorials/4_res_tut/#Tutorial-4:-Saving-More-Results">Tutorial 4: Saving More Results</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/types.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.OtherResults" href="#HSSSimulations.Types.OtherResults"><code>HSSSimulations.Types.OtherResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OtherResults &lt;: AbstractOtherResults</code></pre><p>The default struct stores no data and only acts as a placeholder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/types.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Res.otherResults" href="#HSSSimulations.Res.otherResults"><code>HSSSimulations.Res.otherResults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">otherResults(prob&lt;:Problem, file)</code></pre><p>Runs at the end of the simulation to save any additional results that only need to be saved once, as opposed to for every nth time step. The <a href="../types/#HSSSimulations.Types.Problem"><code>Types.Problem</code></a> type and any of its type parameters can be dispatched on.</p><p>See <a href="#HSSSimulations.Types.AbstractOtherResults"><code>AbstractOtherResults</code></a> for a place to store random data, and <a href="../../tutorials/4_res_tut/#Tutorial-4:-Saving-More-Results">Tutorial 4: Saving More Results</a> for a detailed guide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/results.jl#L104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Res.otherResults-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.Res.otherResults-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.Res.otherResults</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">otherResults(problem::Problem{T, Gh, Mp, R, OR, B}, file)
</code></pre><p>Default <a href="#HSSSimulations.Res.otherResults"><code>otherResults</code></a> method that just saves the maximum melt state reached for each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/results.jl#L116">source</a></section></article><h2 id="Custom-Boundaries"><a class="docs-heading-anchor" href="#Custom-Boundaries">Custom Boundaries</a><a id="Custom-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractProblemParams" href="#HSSSimulations.Types.AbstractProblemParams"><code>HSSSimulations.Types.AbstractProblemParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractProblemParams &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>The <code>Problem</code> struct contains a field called boundary that is of this type. The purpose of this field is to store any boundary condition inputs that changes over the course of a build, such as the air temperature in the machine. As this is an abstract type a new struct can be made, that is a subtype of AbstractProblemParams, to contain the required variables for a given simulation. An example of this is given in <code>HSSParams</code>.</p><p>Any new subtype will need it&#39;s own boundaries written (the examples given are only meant to work with the <code>HSSParams</code> example).</p><p>See the <a href="../../howtos/howto_param/#Problem-Parameters-Recipes">Problem Parameters Recipes</a> for some insperation for implementing your own.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/boundaryTypes.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate" href="#HSSSimulations.Types.boundaryHeatTransferRate"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, i, p&lt;:AbstractBoundary) -&gt; ϕ⃗::Float64</code></pre><p>Used to calculate the heat flux denstity (ϕ⃗, in wm⁻²) into the model at a node on the relavant face for a given boundary condition. They are run per node, for each node on the face. The function should return a single numeric value that represents the heat flux density into the model.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>     : The temperature of the node for which the ghost node is being calculated</li><li><code>i</code>     : The cartesian index of the node for which the ghost node is being calculated</li><li><code>p</code>     : The boundary struct for the current boundary (see <a href="#HSSSimulations.Types.AbstractBoundary"><code>AbstractBoundary</code></a>)</li></ul><p>See the implementations of this for examples, and <a href="../../howtos/howto_bound/#Boundary-Recipes">Boundary Recipes</a> for some additional examples along with the relevant boundary structs.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A positive heat flow equates to heat flowing into the model and negative out of the model.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As this is run for every node on the face every time step, try to avoid complex computations. Where possible, put them in the constructor of the <a href="#HSSSimulations.Types.AbstractBoundary"><code>AbstractBoundary</code></a> instead, as that is only run once per face per timestep.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/boundaryTypes.jl#L83-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SymetryBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SymetryBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(
    _,
    _,
    _::SymetryBoundary
) -&gt; Float64
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConductionBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConductionBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, _, p::ConductionBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConvectionBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConvectionBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, _, p::ConvectionBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractPistonBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractPistonBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(
    T,
    _,
    p::HSSSimulations.HSSBound.AbstractPistonBoundary
) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/piston.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractOverheadsBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractOverheadsBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(
    T,
    _,
    p::HSSSimulations.HSSBound.AbstractOverheadsBoundary
) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SinterBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SinterBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, i, p::SinterBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/sinterStroke.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, RecoatBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, RecoatBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, i, p::RecoatBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/recoatStroke.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, InkBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, InkBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, i, p::InkBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/inkStroke.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, BlankBoundary}" href="#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, BlankBoundary}"><code>HSSSimulations.Types.boundaryHeatTransferRate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundaryHeatTransferRate(T, i, p::BlankBoundary) -&gt; Any
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/blankStroke.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractBoundary" href="#HSSSimulations.Types.AbstractBoundary"><code>HSSSimulations.Types.AbstractBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subtypes of this define a boundary for a single face of the model. An instance of the subtype is created per boundary each time step.</p><p>The fields of the subtype should contain all of the information needed to calculate the heatflow on that boundary (except for the information already passed in to <code>Types.boundaryHeatTransferRate</code>).</p><p>Each subtype of this should have a constructor that satisfies the following signature:</p><pre><code class="nohighlight hljs">&lt;Boundary&gt;(pts::AbstractResult, cts::AbstractResult, prob::Problem, ls::LoadStep)</code></pre><p><strong>Arguments</strong></p><ul><li><code>pts</code>  : The results from the previous timestep. See <code>Result</code></li><li><code>cts</code>  : The results from the current timestep. See <code>Result</code></li><li><code>prob</code> : The &#39;global&#39; variables of the simulation. See <a href="../types/#HSSSimulations.Types.Problem"><code>Problem</code></a></li><li><code>ls</code>   : The per load step variables. See <a href="../types/#HSSSimulations.Types.LoadStep"><code>Types.LoadStep</code></a></li></ul><p>For examples see the default subtypes, and their constructors. <a href="../../howtos/howto_bound/#Boundary-Recipes">Boundary Recipes</a> has examples of some of the extra things that can be done with new <code>AbstractBoundary</code>s.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The constructor for z₂ is the only one that is run before the indices lists are set for that load. So any updating of the indices, such as that done by <code>recoating!</code>, should be done in that boundary constructor.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>cts.T</code> is unknown when this function is called, use the temperature from the previous time step insted (<code>pts.T</code>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/boundaryTypes.jl#L49-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.conductionFlow" href="#HSSSimulations.Boundary.conductionFlow"><code>HSSSimulations.Boundary.conductionFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conductionFlow(T1, T2, h)
</code></pre><p>Calculates a heat flux density (ϕ⃗, in wm⁻²) for a given contact conduction coefficient, h, between points at temperature T1 (the node on the boundary) and T2 (the wall in contact with the node).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.convectionFlow" href="#HSSSimulations.Boundary.convectionFlow"><code>HSSSimulations.Boundary.convectionFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convectionFlow(T1, T∞, h)
</code></pre><p>Calculates a heat flux density (ϕ⃗, in wm⁻²) for a given convection coefficient, h, between a point at temperature T1 and a fluid with temperature T∞.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.radiationFlow" href="#HSSSimulations.Boundary.radiationFlow"><code>HSSSimulations.Boundary.radiationFlow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radiationFlow(T1, T∞, ε)
</code></pre><p>Calculates a heat flux density (ϕ⃗, in wm⁻²) for a given emmisivity, ε, between a point at temperature T1 and infinity at temperature T∞. The temperature arguments should both be in the units °C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.AbstractPistonBoundary" href="#HSSSimulations.HSSBound.AbstractPistonBoundary"><code>HSSSimulations.HSSBound.AbstractPistonBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPistonBoundary &lt;: AbstractBoundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/piston.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.PistonBoundary" href="#HSSSimulations.HSSBound.PistonBoundary"><code>HSSSimulations.HSSBound.PistonBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PistonBoundary &lt;: HSSSimulations.HSSBound.AbstractPistonBoundary</code></pre><p>Boundary for the bottom surface of a HSS build for loads where the heater is turned on. Assumes that the piston maintains a constant temperature at after the initial heat up.</p><p><strong>Fields</strong></p><ul><li><code>piston::Float64</code>: Piston temperature</li><li><code>h::Float64</code>: Contact conduction coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/piston.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.PistonBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.PistonBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.PistonBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PistonBoundary(
    _::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    _::HSSSimulations.Types.LoadStep
) -&gt; PistonBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/piston.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.PistonCoolBoundary" href="#HSSSimulations.HSSBound.PistonCoolBoundary"><code>HSSSimulations.HSSBound.PistonCoolBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PistonCoolBoundary &lt;: HSSSimulations.HSSBound.AbstractPistonBoundary</code></pre><p>Boundary for the bottom surface of a HSS build for cooldown loads. Assumes that once cooling starts it doesn&#39;t stop.</p><p><strong>Fields</strong></p><ul><li><code>piston::Float64</code>: Piston temperature</li><li><code>h::Float64</code>: Contact conduction coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/piston.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.PistonCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.PistonCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.PistonCoolBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PistonCoolBoundary(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    _::HSSSimulations.Types.LoadStep
) -&gt; PistonCoolBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/piston.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.AbstractOverheadsBoundary" href="#HSSSimulations.HSSBound.AbstractOverheadsBoundary"><code>HSSSimulations.HSSBound.AbstractOverheadsBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractOverheadsBoundary &lt;: AbstractBoundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.OverheadsBoundary" href="#HSSSimulations.HSSBound.OverheadsBoundary"><code>HSSSimulations.HSSBound.OverheadsBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OverheadsBoundary &lt;: HSSSimulations.HSSBound.AbstractOverheadsBoundary</code></pre><p>Boundary for the top surface of a HSS build with no lamp or print carriage movement. Assumes the heater controller is the same as our HSS machine where It only updates the overhead power every overheadLayerStep number of layers, and only once on that layer.</p><p><strong>Fields</strong></p><ul><li><code>overheadTemp::Float64</code>: Temperatur of overhead heater</li><li><code>surfaceTemp::Float64</code>: Temperatur of machine internal surface</li><li><code>ε::Float64</code>: Black Body Emmissivity</li><li><code>airTemp::Float64</code>: Temperature of air above build bed</li><li><code>h::Float64</code>: Convection coefficient</li><li><code>Po::Float64</code>: Weighting of overhead heaters vs raditiation loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.OverheadsBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.OverheadsBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.OverheadsBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OverheadsBoundary(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep
) -&gt; OverheadsBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.OverheadsCoolBoundary" href="#HSSSimulations.HSSBound.OverheadsCoolBoundary"><code>HSSSimulations.HSSBound.OverheadsCoolBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OverheadsCoolBoundary &lt;: HSSSimulations.HSSBound.AbstractOverheadsBoundary</code></pre><p>Like the <a href="#HSSSimulations.HSSBound.OverheadsBoundary"><code>OverheadsBoundary</code></a> but it sets the overhead power to 0w (turning it off). Assumes that once cooling starts it doesn&#39;t stop.</p><p><strong>Fields</strong></p><ul><li><code>overheadTemp::Float64</code>: Temperatur of overhead heater</li><li><code>surfaceTemp::Float64</code>: Temperatur of machine internal surface</li><li><code>ε::Float64</code>: Black Body Emmissivity</li><li><code>airTemp::Float64</code>: Temperature of air above build bed</li><li><code>h::Float64</code>: Convection coefficient</li><li><code>Po::Float64</code>: Weighting of overhead heaters vs raditiation loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.OverheadsCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.OverheadsCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.OverheadsCoolBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OverheadsCoolBoundary(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    _::HSSSimulations.Types.LoadStep
) -&gt; OverheadsCoolBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.SinterBoundary" href="#HSSSimulations.HSSBound.SinterBoundary"><code>HSSSimulations.HSSBound.SinterBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SinterBoundary &lt;: AbstractBoundary</code></pre><p>Boundary for the top surface of a HSS build for when the recoat/lamp carriage is over the build bed and the lamp is set to sinter power.</p><p><strong>Fields</strong></p><ul><li><code>overheadTemp::Float64</code>: Temperatur of overhead heater</li><li><code>surfaceTemp::Float64</code>: Temperatur of machine internal surface</li><li><code>eₗ::Array{Float64, 3}</code>: Net absorbtivity relative to lamp</li><li><code>ε::Float64</code>: Black Body Emmissivity</li><li><code>airTemp::Float64</code>: Temperature of air above build bed</li><li><code>h::Float64</code>: Convection coefficient</li><li><code>lamp::Vector{Float64}</code>: Sinter lamp array</li><li><code>shadow::Vector{Bool}</code>: Carriage shadow array</li><li><code>Po::Float64</code>: Weighting of overhead heaters vs raditiation loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/sinterStroke.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.SinterBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.SinterBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.SinterBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SinterBoundary(
    _::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep
) -&gt; SinterBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/sinterStroke.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.RecoatBoundary" href="#HSSSimulations.HSSBound.RecoatBoundary"><code>HSSSimulations.HSSBound.RecoatBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RecoatBoundary &lt;: AbstractBoundary</code></pre><p>Boundary for the top surface of a HSS build with the recoat/lamp carriage over the build area, the lamp set to recoat power and new powder being deposited.</p><p><strong>Fields</strong></p><ul><li><code>overheadTemp::Float64</code>: Temperatur of overhead heater</li><li><code>surfaceTemp::Float64</code>: Temperatur of machine internal surface</li><li><code>eₗ::Array{Float64, 3}</code>: Net absorbtivity relative to lamp</li><li><code>ε::Float64</code>: Black Body Emmissivity</li><li><code>airTemp::Float64</code>: Temperature of air above build bed</li><li><code>h::Float64</code>: Convection coefficient</li><li><code>lamp::Vector{Float64}</code>: Sinter lamp array</li><li><code>shadow::Vector{Bool}</code>: Carriage shadow array</li><li><code>Po::Float64</code>: Weighting of overhead heaters vs raditiation loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/recoatStroke.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.RecoatBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.RecoatBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.RecoatBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RecoatBoundary(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep
) -&gt; RecoatBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/recoatStroke.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.InkBoundary" href="#HSSSimulations.HSSBound.InkBoundary"><code>HSSSimulations.HSSBound.InkBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Boundary for the top surface of a HSS build with the print head carriage over the build volume depositing ink.</p><p><strong>Fields</strong></p><ul><li><code>overheadTemp::Float64</code>: Temperatur of overhead heater</li><li><code>surfaceTemp::Float64</code>: Temperatur of machine internal surface</li><li><code>ε::Float64</code>: Black Body Emmissivity</li><li><code>airTemp::Float64</code>: Temperature of air above build bed</li><li><code>h::Float64</code>: Convection coefficient</li><li><code>shadow::Vector{Bool}</code>: Carriage shadow array</li><li><code>Po::Float64</code>: Weighting of overhead heaters vs raditiation loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/inkStroke.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.InkBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.InkBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.InkBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InkBoundary(
    _::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep
) -&gt; InkBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/inkStroke.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.BlankBoundary" href="#HSSSimulations.HSSBound.BlankBoundary"><code>HSSSimulations.HSSBound.BlankBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BlankBoundary &lt;: AbstractBoundary</code></pre><p>Boundary for the top surface of a HSS build with the print head carriage over the build area but not on the ink deposition stroke.</p><p><strong>Fields</strong></p><ul><li><code>overheadTemp::Float64</code>: Temperatur of overhead heater</li><li><code>surfaceTemp::Float64</code>: Temperatur of machine internal surface</li><li><code>ε::Float64</code>: Black Body Emmissivity</li><li><code>airTemp::Float64</code>: Temperature of air above build bed</li><li><code>h::Float64</code>: Convection coefficient</li><li><code>shadow::Vector{Bool}</code>: Carriage shadow array</li><li><code>Po::Float64</code>: Weighting of overhead heaters vs raditiation loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/blankStroke.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.BlankBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}" href="#HSSSimulations.HSSBound.BlankBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}"><code>HSSSimulations.HSSBound.BlankBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BlankBoundary(
    _::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep
) -&gt; BlankBoundary
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/blankStroke.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.HSSBound.loadOverheads" href="#HSSSimulations.HSSBound.loadOverheads"><code>HSSSimulations.HSSBound.loadOverheads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadNoTop(tₗ, skip)</code></pre><p>Returns the compleate <a href="#HSSSimulations.Types.Load"><code>HSSBound.Load</code></a> struct for a HSS build with no lamp or print carriage movement. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).</p><p>Uses <a href="#HSSSimulations.HSSBound.OverheadsBoundary"><code>HSSBound.OverheadsBoundary</code></a> for the top surface, <a href="#HSSSimulations.HSSBound.PistonBoundary"><code>HSSBound.PistonBoundary</code></a> for the bottom surface and the default <a href="#HSSSimulations.Boundary.SymetryBoundary"><code>Boundary.SymetryBoundary</code></a> functions for the sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/HSSBound/overheads.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.Load-Tuple{}" href="#HSSSimulations.Types.Load-Tuple{}"><code>HSSSimulations.Types.Load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Types.Load(;
    name=&quot;default&quot;, tₗ=1, skip=1,
    x₁=SymetryBoundary, x₂=SymetryBoundary,
    y₁=SymetryBoundary, y₂=SymetryBoundary,
    z₁=SymetryBoundary, z₂=SymetryBoundary,
)</code></pre><p>Default constructor for <a href="#HSSSimulations.Types.Load"><code>Types.Load</code></a>. All of the boundaries defaults to symetry boundaries (see <a href="#HSSSimulations.Boundary.SymetryBoundary"><code>Boundary.SymetryBoundary</code></a>). See <a href="#HSSSimulations.Boundary.ConductionBoundary"><code>Boundary.ConductionBoundary</code></a> and <a href="#HSSSimulations.Boundary.ConvectionBoundary"><code>Boundary.ConvectionBoundary</code></a>, for some more built in loads. And <a href="../BoundaryExamples/#High-Speed-Sintering-Boundary-Example">High Speed Sintering Boundary Example</a> for more complicated loads.</p><p>The <code>z₂</code> load is run before any others, so any calculations that need to be done first should be put there, such as recoating.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Load(; name=&quot;test&quot;, tₗ=1, skip=1, x₁=ConductionBoundary, y₂=ConvectionBoundary)
  x₁ : ConductionBoundary
  x₂ : SymetryBoundary
  y₁ : SymetryBoundary
  y₂ : ConvectionBoundary
  z₁ : SymetryBoundary
  z₂ : SymetryBoundary
  name : test
  tₗ : 1.0
  skip : 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/loads.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.Load" href="#HSSSimulations.Types.Load"><code>HSSSimulations.Types.Load</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Load{X₁&lt;:AbstractBoundary, X₂&lt;:AbstractBoundary, Y₁&lt;:AbstractBoundary, Y₂&lt;:AbstractBoundary, Z₁&lt;:AbstractBoundary, Z₂&lt;:AbstractBoundary} &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p><strong>Fields</strong></p><ul><li><code>x₁::Type{X₁} where X₁&lt;:AbstractBoundary</code>: The boundary condition for the start of the x axis (<code>[1,:,:]</code>)</li><li><code>x₂::Type{X₂} where X₂&lt;:AbstractBoundary</code>: The boundary condition for the end of the x axis (<code>[end,:,:]</code>)</li><li><code>y₁::Type{Y₁} where Y₁&lt;:AbstractBoundary</code>: The boundary condition for the start of the y axis (<code>[:,1,:]</code>)</li><li><code>y₂::Type{Y₂} where Y₂&lt;:AbstractBoundary</code>: The boundary condition for the end of the y axis (<code>[:,end,:]</code>)</li><li><code>z₁::Type{Z₁} where Z₁&lt;:AbstractBoundary</code>: The boundary condition for the start of the z axis (<code>[:,:,1]</code>)</li><li><code>z₂::Type{Z₂} where Z₂&lt;:AbstractBoundary</code>: The boundary condition for the end of the z axis (<code>[:,:,end]</code>)</li><li><code>name::String</code>: Used to annotate the results</li><li><code>tₗ::Float64</code>: The duration of the load in seconds</li><li><code>skip::Int64</code>: The distance between results to save (see <a href="../../explanation/faqs/#Why-We-Skip-Some-Results">Why We Skip Some Results</a>)</li></ul><p>Each of the boundaries given must satisfy <code>Boundary isa Type{T} where T &lt;: AbstractBoundary</code>. This is to say that they should be the type itself, not an instance of that type. Additionally it should be a subtype of <a href="#HSSSimulations.Types.AbstractBoundary"><code>AbstractBoundary</code></a> and meet all of the requirements outlined in the that documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the <code>Load</code> is in a <a href="#HSSSimulations.Types.AbstractLoadSet"><code>BuildLoadSet</code></a> then one of the boundaries in one of the loads in the set should call the recoating logic so that new powder is actuall being layed down. This should always be done in the z₂ boundary, as it is a special case that ensures the indicies are updated for all other boundaries.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Types/boundaryTypes.jl#L111">source</a></section></article><h3 id="Basic-Boundaries"><a class="docs-heading-anchor" href="#Basic-Boundaries">Basic Boundaries</a><a id="Basic-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Boundaries" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.SymetryBoundary" href="#HSSSimulations.Boundary.SymetryBoundary"><code>HSSSimulations.Boundary.SymetryBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SymetryBoundary &lt;: AbstractBoundary</code></pre><p>A boundary for a face that has no heatflow (such as a face on a symetrical boundary). Used as the default boundary in <a href="#HSSSimulations.Types.Load"><code>Types.Load</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.ConductionBoundary" href="#HSSSimulations.Boundary.ConductionBoundary"><code>HSSSimulations.Boundary.ConductionBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConductionBoundary &lt;: AbstractBoundary</code></pre><p>A boundary for a face that has a source of contact conductive heat flow.</p><p><strong>Fields</strong></p><ul><li><code>temp::Float64</code>: Temperature of object being contacted</li><li><code>coef::Float64</code>: Coefficient of contact conduction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.ConvectionBoundary" href="#HSSSimulations.Boundary.ConvectionBoundary"><code>HSSSimulations.Boundary.ConvectionBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvectionBoundary &lt;: AbstractBoundary</code></pre><p>A boundary for a face that has a source of convective heat flow.</p><p><strong>Fields</strong></p><ul><li><code>temp::Float64</code>: Air temperature</li><li><code>coef::Float64</code>: Convection coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary.jl#L91">source</a></section></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.movingObjOverlap" href="#HSSSimulations.Boundary.movingObjOverlap"><code>HSSSimulations.Boundary.movingObjOverlap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">movingObjOverlap(
    geometry::Geometry,
    movingObj,
    objPos::Tuple{Int64, Int64}
) -&gt; Vector
</code></pre><p>Makes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos left and right edge are given by <code>objPos</code>. The overlap is filled with the value passed as <code>movingObj</code>.</p><p>The difference between the first and second value of the <code>objPos</code> Tuple multipled by the spacing in the y-axis (Δy) should match the width of the moving object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));

julia&gt; movingObjOverlap(geometry, true, (2, 4))
3-element Vector{Bool}:
 1
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary_adv.jl#L65">source</a></section><section><div><pre><code class="language-julia hljs">movingObjOverlap(
    geometry::Geometry,
    movingObj::AbstractVector,
    objPos::Int64
) -&gt; Any
</code></pre><p>Makes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by <code>objPos</code>. The overlap is filled with the matching values from the vector <code>movingObj</code>.</p><p>The length of the vector multipled by the spacing in the y-axis (Δy) should match the width of the moving object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));

julia&gt; movingObjOverlap(geometry, [1, 2, 3, 4, 5], 6)
3-element Vector{Int64}:
 2
 3
 4

julia&gt; movingObjOverlap(geometry, [1, 2, 3, 4, 5], 8)
3-element Vector{Int64}:
 0
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary_adv.jl#L102">source</a></section><section><div><pre><code class="language-julia hljs">movingObjOverlap(
    geometry::Geometry,
    movingObj::AbstractMatrix,
    objPos::Int64
) -&gt; Any
</code></pre><p>Makes a matrix with the same dimensions as the top surface of the simulation area. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by <code>objPos</code>. The overlap is filled with the matching values from the matrix <code>movingObj</code>.</p><p>Also for Matrix inputs, the length of the first axis multipled by the spacing in the x-axis (Δx) should match the depth of the moving object and the length of the second axis multipled by the spacing in the y-axis (Δy) should match the width of the moving object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));

julia&gt; movingObjOverlap(geometry, [1 2 3; 4 5 6; 7 8 9], 4)
3×3 Matrix{Int64}:
 2  3  0
 5  6  0
 8  9  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary_adv.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.recoating!" href="#HSSSimulations.Boundary.recoating!"><code>HSSSimulations.Boundary.recoating!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recoating!(
    pts::AbstractResult,
    cts::AbstractResult,
    prob::Problem{T, Gh, Mp, R, OR, B},
    ls::HSSSimulations.Types.LoadStep,
    recoatDist,
    temp
)
</code></pre><p>Powder recoating logic. This updates the indices and fills the new real indices with the initial results provided in the simulation&#39;s <code>Problem</code>, except the temperature, which is set to <code>temp</code>. This allows for the new powder temp to be set to the temperature of the powder in the hopper, or feed bed, at that time in the build. This always runs in the positive y axis, so new powder is always deposited starting from <code>[:, 1, :]</code> and going to <code>[:, end, :]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Boundary/boundary_adv.jl#L1">source</a></section></article><h2 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Solver.makeLogger" href="#HSSSimulations.Solver.makeLogger"><code>HSSSimulations.Solver.makeLogger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeLogger(debugGroups, logFile) -&gt; LoggingExtras.TeeLogger
</code></pre><p><code>debugGroups</code> is a list of groups of debug messages to log to the <code>logFile</code>. If it is set to true then all log groups in the package are used (see <a href="../api/#HSSSimulations.Types.package_groups"><code>package_groups</code></a>), if it is set to false then no log groups are used.</p><p>User log groups can be added to the list, simple add your own string to the list and then set debug messages with the <code>_group</code> field set to your string.</p><p>There is a special group called <code>&quot;misc&quot;</code> that will catch any group not in the <a href="../api/#HSSSimulations.Types.package_groups"><code>package_groups</code></a> list or in any additional group given by the user to the debugGroups list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/2da687384b65476aa73d715c279710820addae8e/src/Solver/logging.jl#L3">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 July 2023 01:51">Thursday 27 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
