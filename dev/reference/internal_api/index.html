<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal APIs · Powder Model Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Powder Model Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/1_full_tut/">1 Full Build</a></li><li><a class="tocitem" href="../../tutorials/2_basic_tut/">2 Warm-up and Cool-down only</a></li><li><a class="tocitem" href="../../tutorials/3_material_tut/">3 A Melt Rate Based Material Model</a></li><li><a class="tocitem" href="../../tutorials/4_res_tut/">4 Saving More Results</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/">Main API</a></li><li><a class="tocitem" href="../api_adv/">Advanced API</a></li><li><a class="tocitem" href="../BoundaryExamples/">HSS Boundary</a></li><li><a class="tocitem" href="../PostProcessing/">Post proccessing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Internal APIs</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Boundary"><span>Boundary</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Private Internals</a></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Patterns</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulate Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Materials</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Models</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Results</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Loads and Load Sets</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundaries</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Types</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solvers</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/HSSBoundary/">HSS Boundary</a></li><li><a class="tocitem" href="../MaterialExamples/">Material examples</a></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li></ul></li><li><a class="tocitem" href="../../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Internal APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal APIs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/src/reference/internal_api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-APIs"><a class="docs-heading-anchor" href="#Internal-APIs">Internal APIs</a><a id="Internal-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-APIs" title="Permalink"></a></h1><p>These are things exported from modules, but not intended for external use.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.AbstractSimProperty" href="#HSSSimulations.Types.AbstractSimProperty"><code>HSSSimulations.Types.AbstractSimProperty</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSimProperty</code></pre><p>This is the parent type of all of the simulation property types. It exists mostly to define a show method for all of it&#39;s subtype. This just makes things nicer to look at the.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/types.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.GVars" href="#HSSSimulations.Types.GVars"><code>HSSSimulations.Types.GVars</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GVars{T&lt;:AbstractArray, Gh&lt;:AbstractArray, M&lt;:AbstractMatProp, R&lt;:AbstractResult, OR&lt;:AbstractOtherResults, P&lt;:AbstractProblemParams}</code></pre><p>An internal struct used for passing the many variables around the different function, it is built from a given problem struct, using a constructor in the problem module. There is probably a better way of doing this, but it works.</p><p><strong>Fields</strong></p><ul><li><code>geometry::Geometry</code>: Simulation geometry</li><li><code>matProp::AbstractMatProp</code>: Simulation material properties</li><li><code>params::AbstractProblemParams</code>: Parameters used for boundary conditions</li><li><code>Fx::AbstractArray</code>: Matrix of x axis Fourier numbers</li><li><code>Fy::AbstractArray</code>: Matrix of y axis Fourier numbers</li><li><code>Fz::AbstractArray</code>: Matrix of z axis Fourier numbers</li><li><code>κ::AbstractArray</code>: Matrix of thermal conductivities</li><li><code>Tᵗ⁻¹::AbstractArray</code>: Ghost node padded matrix of previous time step</li><li><code>eᵗ::AbstractArray</code>: Matrix of current emissivities</li><li><code>ink::Ink</code>: Matrix of final emissivities</li><li><code>file::String</code>: File name</li><li><code>init::AbstractResult</code>: Initial results</li><li><code>otherResults::AbstractOtherResults</code>: Results struct used to save data only once at the end</li><li><code>resultsIndex::Vector{String}</code>: index of results file</li><li><code>options::Options</code>: Simulation options</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/internalTypes.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.GVars-Tuple{Problem}" href="#HSSSimulations.Types.GVars-Tuple{Problem}"><code>HSSSimulations.Types.GVars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GVars(
    problem::Problem
) -&gt; GVars{Array{Float64, 3}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}
</code></pre><p>Make an instance of <a href="#HSSSimulations.Types.GVars"><code>Types.GVars</code></a> from a <a href="../api/#HSSSimulations.Solver.Problem"><code>Problem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Solver/problemSolve.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.LoadTime" href="#HSSSimulations.Types.LoadTime"><code>HSSSimulations.Types.LoadTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LoadTime</code></pre><p>Contains all of the time information for a LoadStep.</p><p><strong>Fields</strong></p><ul><li><code>Δt::Float64</code>: Time between time steps</li><li><code>times::Vector{Float64}</code>: Array of all of the times in the load step</li><li><code>unskipTimes::Vector{Float64}</code>: Array of all none skipped times in the load step</li><li><code>tₚ::Vector{Float64}</code>: Array of percentage through timestep, same index as times</li><li><code>utₚ::Vector{Float64}</code>: Array of percentage through timestep, same index as unskipTimes</li><li><code>tₛ::Float64</code>: The time at the start of the load step</li><li><code>tₑ::Float64</code>: Time step end time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/internalTypes.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.LoadTime-NTuple{4, Any}" href="#HSSSimulations.Types.LoadTime-NTuple{4, Any}"><code>HSSSimulations.Types.LoadTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LoadTime(tₛ, tₗ, Δt, skip) -&gt; LoadTime
</code></pre><p>Default Constructor for <a href="#HSSSimulations.Types.LoadTime"><code>LoadTime</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>tₛ::Float64</code>: The time at the start of the load step</li><li><code>tₗ</code>: The lenght of the load step</li><li><code>Δt::Float64</code>: Time between time steps</li><li><code>skip</code>: How often to save results. See <a href="../../explanation/faqs/#Why-We-Skip-Some-Results">Why We Skip Some Results</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/internalTypes.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.LoadStep" href="#HSSSimulations.Types.LoadStep"><code>HSSSimulations.Types.LoadStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LoadStep{R&lt;:AbstractResult}</code></pre><p>An internal struct for the propeties that are constant within a load step.</p><p><strong>Fields</strong></p><ul><li><code>time::LoadTime</code>: See <a href="#HSSSimulations.Types.LoadTime"><code>LoadTime</code></a></li><li><code>size::Tuple{Int64, Int64, Int64}</code>: The x, y and z size in number of nodes (mostly just used for the z,    which may have changed from the same value in the <code>GVars.geometry</code> variable)</li><li><code>ind::Indices</code>: See <a href="#HSSSimulations.Types.Indices"><code>Indices</code></a></li><li><code>load::Load</code>: See <a href="../api_adv/#HSSSimulations.Types.Load"><code>Load</code></a></li><li><code>init::AbstractResult</code>: The initial results for the load. See <a href="../api_adv/#HSSSimulations.Types.AbstractResult"><code>AbstractResult</code></a></li><li><code>name::String</code>: Used for the progress meter</li><li><code>layerNum::Int64</code>: Used for any <code>Load</code> functions that need the layer number. For preheat    and cooldown load sets this will be the initial thickness or the finial thickness in layers    respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/internalTypes.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.Indices" href="#HSSSimulations.Types.Indices"><code>HSSSimulations.Types.Indices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Indices</code></pre><p>Stores the indices of the nodes, taking into account if the node represents a volume that contains powder or not. And also stores the node pais for the boundaries.</p><p><code>iᵣ</code> are indices of real nodes, this is all nodes that represent space where there is currently powder. This will normally include every node, however before and during the recoat load it will not include all of the top layer, as powder has not been deposited there yet. <code>iᵢ</code> are the indices of &#39;imaginary&#39; nodes, these are nodes that represent locations that do not currently contain powder. These is the same as the indices of all of the nodes minus the indicies of the real nodes (<code>iᵣ</code>).</p><p>Fields with a subscript 1 (<code>₁</code>) denote the boundary at the start of that axis, and subscript 2 (<code>₂</code>) dentoes the end of that boundary. eg. <code>x₂</code> is the boundary [end,:,:] and <code>y₁</code> is y[:,1,:]. z₂ is a special case where it always represents the top surface of the build, even if a layer has not been compleatly deposited yet. y₂ is another special case, where it represents its normal face, but also represents the leading edge of deposited powder.</p><p>The first element of the tuple in the boundary indices is the index (of the array without the ghost cells) for the real node and the second element is the index (of the array with the ghost cells) of the matching ghost node.</p><p><strong>Fields</strong></p><ul><li><p><code>iᵣ::Vector{CartesianIndex{3}}</code>: List of currently real nodes</p></li><li><p><code>iᵢ::Vector{CartesianIndex{3}}</code>: List of currently imaginary nodes</p></li><li><p><code>x₁::Matrix{Tuple{CartesianIndex{3}, CartesianIndex{3}}}</code></p></li><li><p><code>x₂::Matrix{Tuple{CartesianIndex{3}, CartesianIndex{3}}}</code></p></li><li><p><code>y₁::Matrix{Tuple{CartesianIndex{3}, CartesianIndex{3}}}</code></p></li><li><p><code>y₂::Matrix{Tuple{CartesianIndex{3}, CartesianIndex{3}}}</code>: List of real/ghost node pairs for `[:,end,:]</p></li><li><p><code>z₁::Matrix{Tuple{CartesianIndex{3}, CartesianIndex{3}}}</code></p></li><li><p><code>z₂::Matrix{Tuple{CartesianIndex{3}, CartesianIndex{3}}}</code>: List of real/ghost node pairs for `[:,:,end]</p></li><li><p><code>iₘ::CartesianIndex{3}</code>: The middle point of z₂, and it is currently only used for debugging/logging.</p></li><li><p><code>ΔH::Int64</code>: The same as it is in <a href="#HSSSimulations.Types.Geometry"><code>Geometry</code></a>, it is just copied over for convenience.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/boundaryTypes.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Types.Geometry" href="#HSSSimulations.Types.Geometry"><code>HSSSimulations.Types.Geometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Geometry &lt;: HSSSimulations.Types.AbstractSimProperty</code></pre><p>Defines the geometry of the build volume (and the simulation volume within that (if only a subset of a build is being simulated).</p><p><strong>Fields</strong></p><ul><li><code>x::Float64</code>: The size of the x axis of the model in meters</li><li><code>y::Float64</code>: The size of the y axis of the model in meters</li><li><code>z::Float64</code>: The size of the z axis of the model in meters</li><li><code>X::Int64</code>: The size of the x axis of the model in nodes</li><li><code>Y::Int64</code>: The size of the y axis of the model in nodes</li><li><code>Z::Int64</code>: The size of the z axis of the model in nodes</li><li><code>xoffset::Float64</code>: The x axis offset of the model from the machines datum in meters</li><li><code>yoffset::Float64</code>: The y axis offset of the model from the machines datum in meters</li><li><code>X_OFFSET::Int64</code>: The x axis offset of the model from the machines datum in nodes</li><li><code>Y_OFFSET::Int64</code>: The y axis offset of the model from the machines datum in nodes</li><li><code>xbuild::Float64</code>: The total x axis size of the machine from which the subset is taken in meters</li><li><code>ybuild::Float64</code>: The total y axis size of the machine from which the subset is taken in meters</li><li><code>X_BUILD::Int64</code>: The total x axis size of the machine from which the subset is taken in nodes</li><li><code>Y_BUILD::Int64</code>: The total y axis size of the machine from which the subset is taken in nodes</li><li><code>Δx::Float64</code>: The spacing of the nodes in meters in the x axis</li><li><code>Δy::Float64</code>: The spacing of the nodes in meters in the y axis</li><li><code>Δz::Float64</code>: The spacing of the nodes in meters in the z axis</li><li><code>Δt::Float64</code>: The spacing of timesteps in seconds</li><li><code>Nₗ::Int64</code>: The number of layers in the model</li><li><code>Δh::Float64</code>: The layer height in nodes</li><li><code>ΔH::Int64</code>: The layer height in meters</li><li><code>name::String</code>: Just used for future reference of results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Types/geometry.jl#L8">source</a></section></article><h2 id="Boundary"><a class="docs-heading-anchor" href="#Boundary">Boundary</a><a id="Boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.calcInds" href="#HSSSimulations.Boundary.calcInds"><code>HSSSimulations.Boundary.calcInds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calcInds(res, ghost, ΔH, recoatLoadSet) -&gt; Indices
</code></pre><p>Calculates the indices at the start of a load. For build load sets this includes &#39;imaginary&#39; nodes that don&#39;t yet represent a volume with powder in it (but will after recoat). <code>recoatLoadSet</code> should be set to true if the current load set includes powder recoating, and false if it does not.</p><p>See <a href="#HSSSimulations.Types.Indices"><code>Types.Indices</code></a> for more details on the struct returned by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Boundary/indices.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HSSSimulations.Boundary.padWithGhost!" href="#HSSSimulations.Boundary.padWithGhost!"><code>HSSSimulations.Boundary.padWithGhost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">padWithGhost!(
    pts::AbstractResult,
    cts::AbstractResult,
    ls,
    G
)
</code></pre><p>Wraps the temperature array with ghost cells and updates the Tᵗ⁻¹ array in G with the new value. The ghost cells are calculated based on a the boundaries for each face provided in the current load. See <a href="../api_adv/#HSSSimulations.Types.Load"><code>Types.Load</code></a> for more details on these boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/857b7ddd46d6589950b76ddd87044158e255471b/src/Boundary/ghosts.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PostProcessing/">« Post proccessing</a><a class="docs-footer-nextpage" href="../internals/">Private Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 19 June 2023 15:28">Monday 19 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
