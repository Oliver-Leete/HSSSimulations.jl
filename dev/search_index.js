var documenterSearchIndex = {"docs":
[{"location":"howtos/howto_matprop/#Material-Model-Recipes","page":"Material Models","title":"Material Model Recipes","text":"","category":"section"},{"location":"howtos/howto_matprop/#A-Basic-Material-Model","page":"Material Models","title":"A Basic Material Model","text":"","category":"section"},{"location":"howtos/howto_matprop/","page":"Material Models","title":"Material Models","text":"This material model just acts like a normal temperature dependent solid. Useful for comparing against to see the impact of your model. As it does not save the melt or consolidation state it can be combined with Basic Results to save on storage space.","category":"page"},{"location":"howtos/howto_matprop/","page":"Material Models","title":"Material Models","text":"\"\"\"\nA basic material model that doesn't include any melting or consolidation.\n\n# Fields\n\n  - `ρ, c, κ`: Density, Specific heat capacity and Thermal conductivity\n  - `eₚ`: Emmisivity of the powder\n    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths\n    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n  - `eₚ`: Emmisivity of the powder with ink on it\n    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths\n    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n  - `Mₘ`: Used by the material model to track the maximum melt state reached per node.\n\"\"\"\nstruct BasicMatProp{T1,T2,T3} <: Material.AbstractMatProp\n    ρ::T1\n    c::T2\n    κ::T3\n    eₚ::Float64\n    eᵢ::Float64\n    name::String\n    Mₘ::Array{Float64,3}\nend","category":"page"},{"location":"howtos/howto_matprop/","page":"Material Models","title":"Material Models","text":"function Material.calcMatProps!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T,Gh,Mp,R,OR,B},\n    ind,\n) where {T<:Any,Gh<:Any,Mp<:BasicMatProp,OR<:Any,R<:Any,B<:Any}\n    mp = prob.matProp\n    (; Δx, Δy, Δz, Δt) = prob.geometry\n\n    Threads.@threads for i in ind\n        ρ = mp.ρ(0, 0)\n        prob.κ[i] = mp.κ(0, pts.T[i], 0)\n        c = mp.c(pts.T[i])\n\n        α = prob.κ[i] / (ρ * c)\n        prob.Fx[i] = α * (Δt / (Δx^2))\n        prob.Fy[i] = α * (Δt / (Δy^2))\n        prob.Fz[i] = α * (Δt / (Δz^2))\n    end\n    @debug \"material properties\" _group = \"mat\" prob.Fx[ind[end]] prob.Fy[ind[end]] prob.Fz[ind[end]] prob.κ[ind[end]]\n    return\nend","category":"page"},{"location":"howtos/howto_problem/#Problem-Solver-Recipes","page":"Problem Solvers","title":"Problem Solver Recipes","text":"","category":"section"},{"location":"howtos/howto_problem/#A-Problem-Solver-That-Waits-For-a-Bed-Temperature-Before-Starting-the-Build","page":"Problem Solvers","title":"A Problem Solver That Waits For a Bed Temperature Before Starting the Build","text":"","category":"section"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"For when the default problem solver isn't enough it is always possible to make your own.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"For this example we will make a problem solver that stops the machine's preheat when a certain top surface temperature has been reached, instead of waiting a set amount of time. As loads are defined as being a fixed time length this can't be done with the standard logic.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"The new problem solver function:","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"\nwhile targetLower < mean(prevResult.T[:, :, end]) < targetUpper\n    prevResult = loadSetSolver!(LayerPreheatLoadSet(problem.preheatLoads, start), prevResult, prob)\nend","category":"page"},{"location":"howtos/howto_problem/#A-Problem-Solver-That-Waits-For-a-Bed-Temperature-Before-Starting-Each-Layer","page":"Problem Solvers","title":"A Problem Solver That Waits For a Bed Temperature Before Starting Each Layer","text":"","category":"section"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"To emulate the behaviour of a machine waiting after each layer until the bed temperature has stabilised.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"This function moves the wait for temperature logic into the layer loop, to allow for simulations of machines that follow do this. To do this a new Types.AbstractLoadSet needs to be defined (see Load Set Types on how WaitLoadSet was made). As there is no default field in the problem struct to store wait loads, here we are instead passing them straight into our problem solver function as the waitLoads parameter.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solvers","title":"Problem Solvers","text":"function layerTempWaitProblemSolver(problem::Problem, targetLower, targetUpper, waitLoads)\n    for i in start:finish\n        while targetLower < mean(prevResult.T[:, :, end]) < targetUpper\n            prevResult = loadSetSolver!(WaitLoadSet(waitLoads, i), prevResult, G)\n        end\n        prevResult = loadSetSolver!(BuildLoadSet(problem.buildLoads, i), prevResult, G)\n    end\nend","category":"page"},{"location":"howtos/howto_result/#Result-Type-Recipes","page":"Results","title":"Result Type Recipes","text":"","category":"section"},{"location":"howtos/howto_result/#Basic-Results","page":"Results","title":"Basic Results","text":"","category":"section"},{"location":"howtos/howto_result/","page":"Results","title":"Results","text":"A basic result type that only stores the temperature, can be used with A Basic Material Model.","category":"page"},{"location":"howtos/howto_result/","page":"Results","title":"Results","text":"warning: Warning\nAs this struct is what stores the data during the simulation, if this is used with the normal material model you will get an error, as it needs the M and C fields that we have removed.","category":"page"},{"location":"howtos/howto_result/","page":"Results","title":"Results","text":"As well as defining the type, it helps to have a few convenient constructors, some of these will be needed for the type to function in the simulation. It also needs an implementation of Res.loadStepSaver.","category":"page"},{"location":"howtos/howto_result/","page":"Results","title":"Results","text":"struct BasicResult{P<:AbstractArray} <: AbstractResult\n    \"Temperature\"\n    T::P\n    \"Time of timestep\"\n    t::Float64\n    \"The progress through the load step (0=start, 1=end)\"\n    tₚ::Float64\nend\n\n\"\"\"\nCreate an empty result\n\"\"\"\nfunction BasicResult(geomSize, t, tₚ)\n    T = Array{Float64}(undef, geomSize...)\n    return BasicResult{typeof(T)}(T, t, tₚ)\nend\n\n\"\"\"\nCreate a result with uniform fields\n\"\"\"\nfunction BasicResult(geomSize, Tᵢ, t, tₚ)\n    T = fill(Tᵢ, geomSize)\n    return BasicResult{typeof(T)}(T, t, tₚ)\nend\n\n\"\"\"\nFunction to save the results for each load step\n\"\"\"\nfunction Res.loadStepSaver(loadResultsFolder, loadResults::StructVector{T}) where {T<:BasicResult}\n    loadResultsFolder[\"time\"] = loadResults.t\n    loadResultsFolder[\"T\"] = stack(loadResults.T)\n    return\nend","category":"page"},{"location":"howtos/howto_mat/#Material-Recipes","page":"Materials","title":"Material Recipes","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"EditURL = \"https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/lit/res_tut.jl\"","category":"page"},{"location":"tutorials/4_res_tut/#Tutorial-4:-Saving-More-Results","page":"4 Saving More Results","title":"Tutorial 4: Saving More Results","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"using HSSSimulations\nusing .Types\nusing .Res\nusing .HSSBound","category":"page"},{"location":"tutorials/4_res_tut/#Overview","page":"4 Saving More Results","title":"Overview","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"This tutorial will go over both of the ways to save data from the simulation. One method saves results for every time step (well, the ones that the results aren't skipped for) of the simulation. The other, simpler, method saves some results at the end of the simulation.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"For this tutorial we will save some of the information about the overhead heaters. The temperature of the heaters will be saved at every time step. And a list of layers where the power was updated will be saved (along) with every layer that they're saved for.","category":"page"},{"location":"tutorials/4_res_tut/#Setting-Up-the-Time-Step-Results","page":"4 Saving More Results","title":"Setting Up the Time Step Results","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"To store results for each time step we will need to make a new AbstractResult type. This is very similar to the built in Result type, with the addition of the O field, where we'll store the overhead heater temperature. This has to be an array of some kind instead of just a float64 to allow for the value to be mutable (so we can update it once it has been calculated).","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"struct OverheadResult{P<:AbstractArray,V<:AbstractArray} <: AbstractResult\n    \"Temperature\"\n    T::P\n    \"Melt state\"\n    M::P\n    \"Consolidation state\"\n    C::P\n    \"Overhead Heater Temperature\"\n    O::V\n    \"Time of timestep\"\n    t::Float64\n    \"The progress through the load step (0=start, 1=end)\"\n    tₚ::Float64\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"warning: Warning\nAs this struct is what stores the data during the simulation, all subtypes MUST have the T, t and tₚ fields, and if you want to use it with the default material model it will also need the M and C fields.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"In addition, we'll also need some constructors for our new type, one empty one that is used in the simulation code:","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"function OverheadResult(geomSize, t, tₚ)\n    T = Array{Float64}(undef, geomSize...)\n    M = Array{Float64}(undef, geomSize...)\n    C = Array{Float64}(undef, geomSize...)\n    O = Vector{Float64}(undef, 1)\n    return OverheadResult{typeof(T),typeof(O)}(T, M, C, O, t, tₚ)\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"And one to create one filled with given values, that we'll use to create our initial conditions result:","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"function OverheadResult(geomSize, Tᵢ, Mᵢ, Cᵢ, t, tₚ)\n    T = fill(Tᵢ, geomSize)\n    M = fill(Mᵢ, geomSize)\n    C = fill(Cᵢ, geomSize)\n    O = Vector{Float64}(undef, 1)\n    return OverheadResult{typeof(T),typeof(O)}(T, M, C, O, t, tₚ)\nend","category":"page"},{"location":"tutorials/4_res_tut/#Recording-the-Time-Step-Results","page":"4 Saving More Results","title":"Recording the Time Step Results","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"We have the new types ready to store the data, so now we can update some functions to actually fill them with data. The function we care about is the one that finds the new temperature for the overhead heaters, which conveniently is just one of the arguments to HSSParams. So we can just make a function that we'll pass in when calling HSSParams. This is basically just the default function, but with the added step cts.O[1] = oveheadTemp to save our result.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"function overheadHeatupFunc(powerIn::Float64, prevOverheadTemp::Float64, cts)\n    overheadTemp = HSSBound.overheadTempFunc(\n        powerIn,\n        x -> (0.596x - 12.2),\n        118.923,\n        geometry.Δt,\n        prevOverheadTemp,\n    )\n    cts.O[1] = overheadTemp\n    return overheadTemp\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"As well as recording the results, we also need to save them. This is done with the Res.loadStepSaver function. We can create a method for this function that uses our OverheadResult type. Although it can't be dispatched on directly, instead we dispatch on a type from the StructArrays package, with our type as its type parameter. This is handily rexported by the Res module, so we can use it from there.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"The Res.loadStepSaver function is given a folder of the output file that we can then save the contents of loadResults to. loadResults is acts as a struct who's fields are vectors of the fields of our OverheadResult struct. But we can use stack to turn the vectors of arrays into higher dimension arrays before saving them. This will make them the right format to work with the built in post processing functions.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"function Res.loadStepSaver(\n    loadResultsFolder,\n    loadResults::Res.StructVector{T},\n) where {T<:OverheadResult}\n    loadResultsFolder[\"time\"] = loadResults.t\n    loadResultsFolder[\"T\"] = stack(loadResults.T)\n    loadResultsFolder[\"M\"] = stack(loadResults.M)\n    loadResultsFolder[\"C\"] = stack(loadResults.C)\n    loadResultsFolder[\"O\"] = stack(loadResults.O)\n    return\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"Before this function is called, the name of the load has already been saved to the name field, so we don't have to worry about that here (just don't try and save something else to the name field here, it will error).","category":"page"},{"location":"tutorials/4_res_tut/#Saving-Results-at-the-End","page":"4 Saving More Results","title":"Saving Results at the End","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"Compared to saving results for every time step, saving results at the end is much easier. The downside is that we can only save things that we have access to at the end. And the only things we have access to at the end are the contents of Problem. Luckely, there is a placeholder field in Problem called otherResults. To use this we can make an AbstractOtherResults that stores whatever data we want. For this we'll make one that stores some information about the overhead heater controller.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"We'll store a list of layers that caused the overhead heater to update, along with the time of the update and the new power.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"struct OverheadContRes <: AbstractOtherResults\n    layerChanged::Vector{Int}\n    timeChanged::Vector{Float64}\n    newPower::Vector{Float64}\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"To save this data we will use the HSSBound module and make a new version of the constructor for HSSBound.OverheadsBoundary that dispatches on our new type. This is just the same as the default method, but with three push! statements added.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"function HSSBound.OverheadsBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T,Gh,Mp,R,OR,B},\n    ls::Types.LoadStep,\n) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:OverheadContRes,B<:Any}\n    param = prob.params","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"Overhead update logic","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"    if ls.layerNum - param.overheadLayerStep >= param.lastUpdatedOverhead\n        param.lastUpdatedOverhead = ls.layerNum\n        surfaceCurrent = pts.T[ls.ind.z₂[1][1]]\n        if surfaceCurrent > (param.surfaceTarget + param.surfaceTol)\n            overheadPower = param.overheadPower - param.overheadPowerStep\n        elseif surfaceCurrent < (param.surfaceTarget - param.surfaceTol)\n            overheadPower = param.overheadPower + param.overheadPowerStep\n        else\n            overheadPower = param.overheadPower\n        end\n        param.overheadPower = min(max(overheadPower, 0), param.overheadMaxPower)\n\n        push!(prob.otherResults.layerChanged, ls.layerNum)\n        push!(prob.otherResults.timeChanged, cts.t)\n        push!(prob.otherResults.newPower, param.overheadPower)\n\n        @debug \"Overhead Power updated\" _group = \"hss\" surfaceCurrent overheadPower\n    end\n    overheadTemp = param.overheadHeatupFunc(param.overheadPower, param.overheadTemp, cts)\n    param.overheadTemp = overheadTemp\n\n    airTemp = param.airHeat(cts.t)\n    surfaceTemp = param.surfaceHeat(cts.t)\n    ε = prob.matProp.ε\n    h = param.convectionCoef\n    Po = param.percentOverhead\n\n    @debug \"OverheadsBoundary\" _group = \"hss\" cts.tₚ overheadTemp surfaceTemp airTemp\n    return OverheadsBoundary(overheadTemp, surfaceTemp, ε, airTemp, h, Po)\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"Also, the other contents of a few of Problem's fields can be customised by us, the matProp field contains the AbstractMatProp struct for the simulation, and the params field contains the simulation's AbstractProblemParams struct. So if we were making a new material model then we could use it's struct to store something and then save it all at the end, or the same for boundary conditions with the parameters struct.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"In addition to our otherResults struct, we will also save a couple of things that are already available from the default structs. The maximum melt state is from the MatProp struct (and is normally saved by this function anyway), and coolStart is from the HSSParams struct (and is not normally saved).","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"We'll make a method for otherResults that dispatches on our OverheadContRes struct. This method saves MeltMax and CoolStart to the top level results folder of the output file, and all of our overhead controller stuff to its own subfolder of the results.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"function Res.otherResults(\n    prob::Types.Problem{T,Gh,Mp,R,OR,B},\n    file,\n) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:OverheadContRes,B<:Any}\n    file[\"MeltMax\"] = prob.matProp.Mₘ\n    file[\"CoolStart\"] = prob.params.coolStart\n    file[\"Overheads/layerChanged\"] = prob.otherResults.layerChanged\n    file[\"Overheads/timeChanged\"] = prob.otherResults.timeChanged\n    file[\"Overheads/newPower\"] = prob.otherResults.newPower\n    return\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"If we didn't want to store any data outside of what is incleded anyway from the material property or parameters struct, then we could have just made our new AbstractOtherResults struct empty and still used it to dispatch a method for Res.otherResults.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"In fact, as the default OtherResults struct is empty and isn't used, you can replace it with an empty struct of your own to use to dispatch methods of other functions. So if you wanted to change the behavour of one of the boundaries, or of the material model, but don't want to have to replace those structs, then just use the otherResults. I'll leave it as an exercise for the reader to rewrite the previous tutorial using this method to make things shorter.","category":"page"},{"location":"tutorials/4_res_tut/#The-Rest-of-the-Setup","page":"4 Saving More Results","title":"The Rest of the Setup","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"From here on it's similar to our other simulations. The one exceptions being the fact that we need to pass our overheadHeatupFunc into HSSParams and the fact that we need to pass an empty OverheadContRes into the problem. Creating a Geometry first to feed into the HSSParams. We'll also change some of the settings of the geometry so that it goes a bit faster but be less accurate, if you want to try this out on a full simulation feel free to use the geometry from the full build tutorial.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"geometry = Geometry(\n    (0.016, 0.016, 0.0122),\n    0.001,\n    1e-2;\n    Δz=0.003 / 30,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers\",\n)","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"Then the new stuff","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"params = HSSParams(geometry; overheadHeatupFunc=overheadHeatupFunc)\notherResults = OverheadContRes(Vector{Int}(), Vector{Float64}(), Vector{Float64}())","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"We also need to make sure to use our new results struct for our initial conditions, this will tell the simulation to use it for the rest of the time steps.","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"init = OverheadResult((geometry.X, geometry.Y, geometry.Z), 25.0, 0.0, 0.0, 0.0, 0)","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"And the rest of it","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"loadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)\nmaterial = PA2200(geometry)\n\ninitialLayer = 30\n\ninkArray = fill(material.eₚ, (geometry.X, geometry.Y, geometry.Z))\ninkArray[5:end-4, 5:end-4, 60:end-10] .= material.eᵢ\nink = Ink(inkArray, \"Sample square\")\n\nfile = \"results_tutorial.jld2\"\ndescription = \"A simulation to test out saving overhead heater results\"\n\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    loadSets=loadSets,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    otherResults=otherResults,\n    description=description,\n)\n\nresultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"","category":"page"},{"location":"tutorials/4_res_tut/","page":"4 Saving More Results","title":"4 Saving More Results","text":"This page was generated using Literate.jl.","category":"page"},{"location":"doc_index/#Function-Index","page":"Index","title":"Function Index","text":"","category":"section"},{"location":"doc_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"howtos/howto_param/#Problem-Parameters-Recipes","page":"Problem Parameters","title":"Problem Parameters Recipes","text":"","category":"section"},{"location":"howtos/howto_param/#A-Variable-Heat-Flux-Parameter-Set","page":"Problem Parameters","title":"A Variable Heat Flux Parameter Set","text":"","category":"section"},{"location":"howtos/howto_param/","page":"Problem Parameters","title":"Problem Parameters","text":"This parameter set is about as basic as it gets. It's made to be used alongside the boundary defined in A Variable Heat Flux Boundary it just needs the heat flux field to be set to a something that is callable.","category":"page"},{"location":"howtos/howto_param/","page":"Problem Parameters","title":"Problem Parameters","text":"struct VariableHeatFluxParams{T1} <: AbstractProblemParams\n    heatflux::T1\nend","category":"page"},{"location":"howtos/howto_param/","page":"Problem Parameters","title":"Problem Parameters","text":"As an example, here we make the parameter set with a function that defines the heat flux to be 3 watts times the current time (so 10 seconds in, the heat flux would be 30 watts).","category":"page"},{"location":"howtos/howto_param/","page":"Problem Parameters","title":"Problem Parameters","text":"VariableHeatFluxParams(t -> t * 3)","category":"page"},{"location":"reference/api_adv/#Advanced-API","page":"Advanced API","title":"Advanced API","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"DocTestSetup = quote\n    using HSSSimulations\nend","category":"page"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"These APIs are exported by their module, but not exported by the package, so to use them you will need to either use their full address:","category":"page"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"using HSSSimulations\nSolver.loadSetSolver!","category":"page"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"or by using the module it is in:","category":"page"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"using HSSSimulations\nusing .Solver\nloadSetSolver!","category":"page"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"","category":"page"},{"location":"reference/api_adv/#Custom-Load-Sets","page":"Advanced API","title":"Custom Load Sets","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Solver.loadSetSolver!\nTypes.AbstractLoadSet\nSolver.FixedLoadSet\nSolver.loadSetSolver!(::FixedLoadSet,::AbstractResult,::Int,::Problem{T,Gh,Mp,R,OR,B}) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nSolver.LayerLoadSet\nSolver.loadSetSolver!(::LayerLoadSet,::AbstractResult,::Int,::Problem{T,Gh,Mp,R,OR,B}) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Solver.loadSetSolver!","page":"Advanced API","title":"HSSSimulations.Solver.loadSetSolver!","text":"loadSetSolver!(\n    loadSet<:AbstractLoadSet\n    initResult::AbstractResult,\n    layerNum::Int,\n    prob::Problem{T,Gh,Mp,R,OR,B},\n) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\n\nThis function is run once for each LoadSet passed in to the problem, and dispatched on the type of that load set. For basic load sets, like FixedLoadSet, it should basically just pass the arguments on to the innerLoadSetSolver! function, the one exception being the list of loads being passed in instead of the AbstractLoadSet struct. For more complicated load sets, like LayerLoadSet, this should include the logic used for that load set. For LayerLoadSet this is a loop that loops over the list of loads once for each layer, incrementing the layer number as it goes.\n\nFor examples see the source code for the two default implementations.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Types.AbstractLoadSet","page":"Advanced API","title":"HSSSimulations.Types.AbstractLoadSet","text":"abstract type AbstractLoadSet <: HSSSimulations.Types.AbstractSimProperty\n\nThis struct holds the information for a load set, primarily the list of loads, but also some extra bits. Subtypes should implement a method for the Solver.loadSetSolver! function.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Solver.FixedLoadSet","page":"Advanced API","title":"HSSSimulations.Solver.FixedLoadSet","text":"struct FixedLoadSet <: AbstractLoadSet\n\n#Fields\n\nname::String: Name of the load set\nloads::Vector{Load}: List of loads for load set\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{FixedLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.Solver.loadSetSolver!","text":"loadSetSolver!(\n    loadSet::FixedLoadSet,\n    initResult::AbstractResult,\n    layerNum::Int64,\n    prob::Problem{T, Gh, Mp, R, OR, B}\n) -> Tuple{AbstractResult, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Solver.LayerLoadSet","page":"Advanced API","title":"HSSSimulations.Solver.LayerLoadSet","text":"struct LayerLoadSet <: AbstractLoadSet\n\n#Fields\n\nname::String: Name of the load set\nfinishLayer::Int64: The last layer to deposit as part of this load set\nloads::Vector{Load}: List of loads for load set\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{LayerLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.Solver.loadSetSolver!","text":"loadSetSolver!(\n    loadSet::LayerLoadSet,\n    initResult::AbstractResult,\n    initLayerNum::Int64,\n    prob::Problem{T, Gh, Mp, R, OR, B}\n) -> Tuple{AbstractResult, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"innerLoadSetSolver!","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Solver.innerLoadSetSolver!","page":"Advanced API","title":"HSSSimulations.Solver.innerLoadSetSolver!","text":"innerLoadSetSolver!(\n    loads::Vector{Load},\n    initResult::AbstractResult,\n    layerNum,\n    prob::Problem;\n    name,\n    recoat,\n    prevLayerNum\n)\n\n\nSolves a load set of a problem, iterating over and solving the loads in the given load set in order. The results for a load is saved to the file after solving it.\n\nIf the list of loads passed given include powder deposition, the recoat kwarg should be set to true, with the layerNum set to the thickness of the powder bed in layers that is desired at the end of the loads. If this is more than one layer thicker than the previous value, then the previous values should also be passed in to prevLayerNum.\n\nIt also helps to provide a unique name. This is the name that will be used to store the results from runnning the list of loads in the output file, and also will be used as the label in the progress meter. If no name is given then the current time is used instead. If the name given is not unique then you will get a run time error when it tries to save results to a place that is already taken.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"","category":"page"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"","category":"page"},{"location":"reference/api_adv/#Custom-Materials","page":"Advanced API","title":"Custom Materials","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"MatProp\nMatProp(::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any)","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Material.MatProp","page":"Advanced API","title":"HSSSimulations.Material.MatProp","text":"struct MatProp{T1, T2, T3, T4, T5, T6, T7, T8, T9} <: AbstractMatProp\n\nThe default implementation of AbstractMatProp used by the default Material.calcMatProps! method. See Material Examples for some premade materials. The arguments to its constructor are the same as the matching fields. The only addition is the geometry argument, which should just be the Geometry struct of for the simulation.\n\nwarning: Warning\nThe maximum melt state is never reset, so if a node goes from the melt region to the recrystalisation region more than once in a simulation, the behaviour might not be modeled properly.\n\nFields\n\nρ::Any:  Density.    Two dimensional interpolations, with inputs in axis 1 = consolidation state, axis 2 = melt state.\nc::Any:  Specific heat capacity.    One dimensional interpolations with the node's temperature as it's input.\nκ::Any:  Thermal conductivity.    Three dimensional interpolations, with inputs in axis 1 = consolidation state, axis 2 = temperature and axis 3    = melt state.\nMᵣ::Any:  Melting range and temp relationship.    A 1d interpolation, with the only input axis being the temperature and the output is the melt state.\nMₛ::Float64: The start temperature of the melt range\nMₑ::Float64: The end temperature of the melt range\nRᵣ::Any:  Crystallisation range and temp relationship.    A 2d interpolation, with the first input axis being the node temperature and the second input axis    being the maximum melt state reached. The output is the melt state.\nRₛ::Float64: The start temperature of the recrystalisation range\nRₑ::Float64: The end temperature of the recrystalisation range\nHf::Any: Total specific heat of melting\nHr::Any:  Total specific heat of fusion.    A 1d Interpolation where the input is the maximum melt state reached and the output is the total    heat of fusion.\nĊ::Any:  Consolidation rate.    Either a single value representing a constant consolidation rate, or a 2d interpolation, with the    first axis being the node temperature and the second being the node melt state. The output is the    rate of change of sinter state.\neₚ::Float64:  Emmisivity of the powder.    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\neᵢ::Float64:  Emmisivity of the powder with ink on it.    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\nε::Float64:  Black body emmisivity of the powder\nname::String: Just used for future reference\nMₘ::Any: Used by the material model to track the maximum melt state reached per node\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Material.MatProp-NTuple{13, Any}","page":"Advanced API","title":"HSSSimulations.Material.MatProp","text":"MatProp(\n    ρ,\n    c,\n    κ,\n    Mᵣ,\n    Rᵣ,\n    Hf,\n    Hr,\n    Ċ,\n    eₚ,\n    eᵢ,\n    ε,\n    name,\n    geometry\n) -> MatProp\n\n\nDefault constructor for MatProp.\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#Custom-Material-Models","page":"Advanced API","title":"Custom Material Models","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Types.AbstractMatProp\nMaterial.calcMatProps!\nMaterial.calcMatProps!(::AbstractResult, ::AbstractResult, ::Problem{T,Gh,Mp,R,OR,B}, ::Any) where {\n    T<:Any,Gh<:Any,Mp<:AbstractMatProp,R<:Any,OR<:Any,B<:Any,\n}\nMaterial.meltUpdate\nMaterial.meltUpdate(::Any,::Any,::Any,::Any,::AbstractMatProp)\nMaterial.consUpdate\nMaterial.consUpdate(::Any,::Any,::Any,::Any,::AbstractMatProp)\nMaterial.PA_Ċ_maker","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Types.AbstractMatProp","page":"Advanced API","title":"HSSSimulations.Types.AbstractMatProp","text":"abstract type AbstractMatProp <: HSSSimulations.Types.AbstractSimProperty\n\nThe abstract type that any material property struct needs to be a subtype of. These are for storing the values used to define the properties of a material, and those used to calculate the changes in material properties due to the build. The default struct used is MatProp, however new subtypes can be defined and used by defining a new Material.calcMatProps! function. This allows for the simplificiation (or complication) of the material model used in the simulation to fit your needs.\n\nAny new subtype will need it's own method writen for calcMatProps! and if the example boundaries are being used some of them might need to be updated to use the new material properties. If melt state or consolidation state are beind removed from the material model then it might be worth implementing a new AbstractResult to save on memory. If an additional property that needs to be tracked is added to the material model then it will be necissary to implement a new subtype of those to track this.\n\nSee Material Model Recipes and Tutorial 3: A Melt Rate Based Material Model for more information on implementing your own.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Material.calcMatProps!","page":"Advanced API","title":"HSSSimulations.Material.calcMatProps!","text":"calcMatProps!(::AbstractResult, ::AbstractResult, <:Problem, ::Indices)\n\nUpdates any of the material properties that change, along with the Fourier number for the current time step. New methods can be defined by dispatching on Problem with a different subtype of MatProp (for more information on this, see Types.AbstractMatProp). The two main functions called by this one, meltUpdate and consUpdate, are both also dispatched on the type of the material property struct, so they can be overwritten individually for a new material property struct if the new material model only needs to change some of the behaviour.\n\nArguments\n\ncts: Current time step results\npts: Previous time step results\nind: The indicies to update\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Material.calcMatProps!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp<:AbstractMatProp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.Material.calcMatProps!","text":"calcMatProps!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp<:AbstractMatProp, R, OR, B},\n    ind\n)\n\n\nThe default material model, designed to be used with MatProp, but should work with any Types.AbstractMatProp that shares MatProp's ρ, c, κ and Mₘ fields. \n\nUpdates melt and consolidation state, and then uses those to update the density, heat capacity and conductivity. These are then used to calculate the Fourier number for each axis for this time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Material.meltUpdate","page":"Advanced API","title":"HSSSimulations.Material.meltUpdate","text":"meltUpdate(Mᵗ⁻¹, T, Mₘ, Δt, mp::AbstractMatProp) -> Mᵗ, Mₘ, Δh\n\nCalculates the new melt state of a single node. It is given the melt state and temperature of the node in the previous time step, the maximum melt state the node has reached so far, the duration of the current time step and the material property struct.\n\nIt should return the new melt state for the node, the new maximum melt state, and the specific enthalpy change due to fusion or recrystalisation that is associated with the change in melt state.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Material.meltUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}","page":"Advanced API","title":"HSSSimulations.Material.meltUpdate","text":"meltUpdate(\n    Mᵗ⁻¹,\n    T,\n    Mₘ,\n    _,\n    mp::AbstractMatProp\n) -> Tuple{Any, Any, Any}\n\n\nUpdates the melt state of a node if the temperature of the node is in the melting or crystalisation termperature range if not the existing value is returned. This uses a basic time independent model that associates a single melt state to a given combination of temperature and maximum melt state reached so far.\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Material.consUpdate","page":"Advanced API","title":"HSSSimulations.Material.consUpdate","text":"consUpdate(C, M, T, Δt, mp::AbstractMatProp) -> C\n\nCalculates the new consolidation state of a single node. It is given the current consolidation state, melt state and temperature of the node, the duration of the current time step and the material property struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Material.consUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}","page":"Advanced API","title":"HSSSimulations.Material.consUpdate","text":"consUpdate(C, M, T, Δt, mp::AbstractMatProp) -> Any\n\n\nUpdates the consolidation state of a node by adding the change in consolidation state (rate * time) to the previous consolidation state. Only applies if the material is melted and not already fully consolidated.\n\nThis finds the consolidation rate by calling mp.Ċ with C, T and M as arguments.\n\nThe returned values maximum is limited to 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Material.PA_Ċ_maker","page":"Advanced API","title":"HSSSimulations.Material.PA_Ċ_maker","text":"Based on model from Childs and Tontowi 2001. Modified to work off of consolidation and melt states. Takes three coefficients and returns a consolidation rate calculator.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#Custom-Results","page":"Advanced API","title":"Custom Results","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Types.AbstractResult\nRes.loadStepSaver\nRes.loadStepSaver(::Any, ::StructVector{T}) where {T<:Result}\nTypes.AbstractOtherResults\nTypes.OtherResults\nRes.otherResults\nRes.otherResults(::Problem{T,Gh,Mp,R,OR,B}, ::Any) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Types.AbstractResult","page":"Advanced API","title":"HSSSimulations.Types.AbstractResult","text":"abstract type AbstractResult <: HSSSimulations.Types.AbstractSimProperty\n\nThis as the abstract type for the results from a single simulation time step. See Tutorial 4: Saving More Results and Result Type Recipes for how to make your own subtype.\n\nwarning: Warning\nAs this struct is what stores the data during the simulation, all subtypes MUST have the T, t and tₚ fields, and if used with the default material model it will also need the M and C fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Res.loadStepSaver","page":"Advanced API","title":"HSSSimulations.Res.loadStepSaver","text":"loadSave(loadResultsFolder, loadResults::StructVector{T}) where {T<:AbstractResult}\n\nSaves the results of a load step into the folder for the current load step in the output file of the problem, given by the loadResultsFolder argument.\n\nAny new methods for this function should dispatch on the type parameter of the loadResults, and save any desired results to the file like so:\n\nfunction loadStepSaver(loadResultsFolder, loadResults::StructVector{T}) where {T<:AbstractResult}\n    loadResultsFolder[\"time\"] = loadResults.t\n    loadResultsFolder[\"T\"] = stack(loadResults.T)\n    return\nend\n\nnote: Note\nstack is used as a very efficient way of converting the vector of 3D arrays from the StructVector in to a 4D array.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Res.loadStepSaver-Union{Tuple{T}, Tuple{Any, StructVector{T}}} where T<:Result","page":"Advanced API","title":"HSSSimulations.Res.loadStepSaver","text":"loadStepSaver(\n    loadResultsFolder,\n    loadResults::StructArray{T<:Result, 1}\n)\n\n\nSaves the results for the temperature, melt state and consolidation state as 4D arrays of X,Y,Z and t. And the time is saved as a 1D Array.\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.AbstractOtherResults","page":"Advanced API","title":"HSSSimulations.Types.AbstractOtherResults","text":"abstract type AbstractOtherResults <: HSSSimulations.Types.AbstractSimProperty\n\nThis as the abstract type for the results that are saved only at the end of the simulation. This is useful to store things that do not change every time step, without requiring any changes to the material property or params structs. However those structs can also be used to store such things, such as is done for Mₘ in the MatProp struct.\n\nAs the default implementation does nothing, and nothing normally dispatches on it, it can be replaced by another empty type to use a new method for any function that dispatches on Problem (I think that's all of the user facing API).\n\nTutorial 4: Saving More Results for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Types.OtherResults","page":"Advanced API","title":"HSSSimulations.Types.OtherResults","text":"struct OtherResults <: AbstractOtherResults\n\nThe default struct stores no data and only acts as a placeholder.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Res.otherResults","page":"Advanced API","title":"HSSSimulations.Res.otherResults","text":"otherResults(prob<:Problem, file)\n\nRuns at the end of the simulation to save any additional results that only need to be saved once, as opposed to for every nth time step. The Types.Problem type and any of its type parameters can be dispatched on.\n\nFor example, this will run if both the HSSParams parameter type, the MatProp material property and MyOtherResults are used for the simulation. It will save the maximum melt state of each node to a field called MeltMax, ect. See AbstractOtherResults for a place to store random data, and Tutorial 4: Saving More Results for a detailed guide.\n\nfunction Res.otherResults(\n    prob::Problem{T,Gh,M,R,OR,P},\n    file,\n) where {T<:Any,Gh<:Any,M<:MatProp,R<:Any,OR<:MyOtherResults,P<:HSSParams}\n    file[\"MeltMax\"] = prob.matProp.Mₘ\n    file[\"CooldownStartTime\"] = prob.params.coolStart\n    file[\"myResult\"] = prob.otherResults.something_else_interesting\n    return\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Res.otherResults-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.Res.otherResults","text":"otherResults(problem::Problem{T, Gh, Mp, R, OR, B}, file)\n\n\nDefault otherResults method that just saves the maximum melt state reached for each node.\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#Custom-Boundaries","page":"Advanced API","title":"Custom Boundaries","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Types.AbstractProblemParams\nTypes.boundaryHeatTransferRate\nBoundary.boundaryHeatTransferRate(::Any,::Any,::SymetryBoundary)\nBoundary.boundaryHeatTransferRate(::Any,::Any,::ConductionBoundary)\nBoundary.boundaryHeatTransferRate(::Any,::Any,::ConvectionBoundary)\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.AbstractPistonBoundary)\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.AbstractOverheadsBoundary)\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.SinterBoundary)\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.RecoatBoundary)\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.InkBoundary)\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.BlankBoundary)\nTypes.AbstractBoundary\nBoundary.conductionFlow\nBoundary.convectionFlow\nBoundary.radiationFlow\nHSSBound.AbstractPistonBoundary\nHSSBound.PistonBoundary\nHSSBound.PistonBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.PistonCoolBoundary\nHSSBound.PistonCoolBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.AbstractOverheadsBoundary\nHSSBound.OverheadsBoundary\nHSSBound.OverheadsBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.OverheadsCoolBoundary\nHSSBound.OverheadsCoolBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.SinterBoundary\nHSSBound.SinterBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.RecoatBoundary\nHSSBound.RecoatBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.InkBoundary\nHSSBound.InkBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.BlankBoundary\nHSSBound.BlankBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.loadOverheads","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Types.AbstractProblemParams","page":"Advanced API","title":"HSSSimulations.Types.AbstractProblemParams","text":"abstract type AbstractProblemParams <: HSSSimulations.Types.AbstractSimProperty\n\nThe Problem struct contains a field called boundary that is of this type. The purpose of this field is to store any boundary condition inputs that changes over the course of a build, such as the air temperature in the machine. As this is an abstract type a new struct can be made, that is a subtype of AbstractProblemParams, to contain the required variables for a given simulation. An example of this is given in HSSParams.\n\nAny new subtype will need it's own boundaries written (the examples given are only meant to work with the HSSParams example).\n\nSee the Problem Parameters Recipes for some insperation for implementing your own.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p<:AbstractBoundary) -> ϕ⃗::Float64\n\nUsed to calculate the heat flux denstity (ϕ⃗, in wm⁻²) into the model at a node on the relavant face for a given boundary condition. They are run per node, for each node on the face. The function should return a single numeric value that represents the heat flux density into the model.\n\nArguments\n\nT     : The temperature of the node for which the ghost node is being calculated\ni     : The cartesian index of the node for which the ghost node is being calculated\np     : The boundary struct for the current boundary (see AbstractBoundary)\n\nSee the implementations of this for examples, and Boundary Recipes for some additional examples along with the relevant boundary structs.\n\nnote: Note\nA positive heat flow equates to heat flowing into the model and negative out of the model.\n\nwarning: Warning\nAs this is run for every node on the face every time step, try to avoid complex computations. Where possible, put them in the constructor of the AbstractBoundary instead, as that is only run once per face per timestep.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SymetryBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(\n    _,\n    _,\n    _::SymetryBoundary\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConductionBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, _, p::ConductionBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConvectionBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, _, p::ConvectionBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractPistonBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(\n    T,\n    _,\n    p::HSSSimulations.HSSBound.AbstractPistonBoundary\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractOverheadsBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(\n    T,\n    _,\n    p::HSSSimulations.HSSBound.AbstractOverheadsBoundary\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SinterBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::SinterBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, RecoatBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::RecoatBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, InkBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::InkBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, BlankBoundary}","page":"Advanced API","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::BlankBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.AbstractBoundary","page":"Advanced API","title":"HSSSimulations.Types.AbstractBoundary","text":"Subtypes of this define a boundary for a single face of the model. An instance of the subtype is created per boundary each time step.\n\nThe fields of the subtype should contain all of the information needed to calculate the heatflow on that boundary (except for the information already passed in to Types.boundaryHeatTransferRate).\n\nEach subtype of this should have a constructor that satisfies the following signature:\n\n<Boundary>(pts::AbstractResult, cts::AbstractResult, prob::Problem, ls::LoadStep)\n\nArguments\n\npts  : The results from the previous timestep. See Result\ncts  : The results from the current timestep. See Result\nprob : The 'global' variables of the simulation. See Problem\nls   : The per load step variables. See Types.LoadStep\n\nFor examples see the default subtypes, and their constructors. Boundary Recipes has examples of some of the extra things that can be done with new AbstractBoundarys.\n\nwarning: Warning\nThe constructor for z₂ is the only one that is run before the indices lists are set for that load. So any updating of the indices, such as that done by recoating!, should be done in that boundary constructor.\n\nwarning: Warning\ncts.T is unknown when this function is called, use the temperature from the previous time step insted (pts.T).\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Boundary.conductionFlow","page":"Advanced API","title":"HSSSimulations.Boundary.conductionFlow","text":"conductionFlow(T1, T2, h)\n\n\nCalculates a heat flux density (ϕ⃗, in wm⁻²) for a given contact conduction coefficient, h, between points at temperature T1 (the node on the boundary) and T2 (the wall in contact with the node).\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Boundary.convectionFlow","page":"Advanced API","title":"HSSSimulations.Boundary.convectionFlow","text":"convectionFlow(T1, T∞, h)\n\n\nCalculates a heat flux density (ϕ⃗, in wm⁻²) for a given convection coefficient, h, between a point at temperature T1 and a fluid with temperature T∞.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Boundary.radiationFlow","page":"Advanced API","title":"HSSSimulations.Boundary.radiationFlow","text":"radiationFlow(T1, T∞, ε)\n\n\nCalculates a heat flux density (ϕ⃗, in wm⁻²) for a given emmisivity, ε, between a point at temperature T1 and infinity at temperature T∞. The temperature arguments should both be in the units °C.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.AbstractPistonBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.AbstractPistonBoundary","text":"abstract type AbstractPistonBoundary <: AbstractBoundary\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.PistonBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.PistonBoundary","text":"struct PistonBoundary <: HSSSimulations.HSSBound.AbstractPistonBoundary\n\nBoundary for the bottom surface of a HSS build for loads where the heater is turned on. Assumes that the piston maintains a constant temperature at after the initial heat up.\n\nFields\n\npiston::Float64: Piston temperature\nh::Float64: Contact conduction coefficient\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.PistonBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.PistonBoundary","text":"PistonBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    _::HSSSimulations.Types.LoadStep\n) -> PistonBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.PistonCoolBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.PistonCoolBoundary","text":"struct PistonCoolBoundary <: HSSSimulations.HSSBound.AbstractPistonBoundary\n\nBoundary for the bottom surface of a HSS build for cooldown loads. Assumes that once cooling starts it doesn't stop.\n\nFields\n\npiston::Float64: Piston temperature\nh::Float64: Contact conduction coefficient\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.PistonCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.PistonCoolBoundary","text":"PistonCoolBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    _::HSSSimulations.Types.LoadStep\n) -> PistonCoolBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.AbstractOverheadsBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.AbstractOverheadsBoundary","text":"abstract type AbstractOverheadsBoundary <: AbstractBoundary\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.OverheadsBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.OverheadsBoundary","text":"struct OverheadsBoundary <: HSSSimulations.HSSBound.AbstractOverheadsBoundary\n\nBoundary for the top surface of a HSS build with no lamp or print carriage movement. Assumes the heater controller is the same as our HSS machine where It only updates the overhead power every overheadLayerStep number of layers, and only once on that layer.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.OverheadsBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.OverheadsBoundary","text":"OverheadsBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> OverheadsBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.OverheadsCoolBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.OverheadsCoolBoundary","text":"struct OverheadsCoolBoundary <: HSSSimulations.HSSBound.AbstractOverheadsBoundary\n\nLike the OverheadsBoundary but it sets the overhead power to 0w (turning it off). Assumes that once cooling starts it doesn't stop.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.OverheadsCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.OverheadsCoolBoundary","text":"OverheadsCoolBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    _::HSSSimulations.Types.LoadStep\n) -> OverheadsCoolBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.SinterBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.SinterBoundary","text":"struct SinterBoundary <: AbstractBoundary\n\nBoundary for the top surface of a HSS build for when the recoat/lamp carriage is over the build bed and the lamp is set to sinter power.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\neₗ::Array{Float64, 3}: Net absorbtivity relative to lamp\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nlamp::Vector{Float64}: Sinter lamp array\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.SinterBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.SinterBoundary","text":"SinterBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> SinterBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.RecoatBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.RecoatBoundary","text":"struct RecoatBoundary <: AbstractBoundary\n\nBoundary for the top surface of a HSS build with the recoat/lamp carriage over the build area, the lamp set to recoat power and new powder being deposited.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\neₗ::Array{Float64, 3}: Net absorbtivity relative to lamp\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nlamp::Vector{Float64}: Sinter lamp array\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.RecoatBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.RecoatBoundary","text":"RecoatBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> RecoatBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.InkBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.InkBoundary","text":"Boundary for the top surface of a HSS build with the print head carriage over the build volume depositing ink.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.InkBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.InkBoundary","text":"InkBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> InkBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.BlankBoundary","page":"Advanced API","title":"HSSSimulations.HSSBound.BlankBoundary","text":"struct BlankBoundary <: AbstractBoundary\n\nBoundary for the top surface of a HSS build with the print head carriage over the build area but not on the ink deposition stroke.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.BlankBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"Advanced API","title":"HSSSimulations.HSSBound.BlankBoundary","text":"BlankBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> BlankBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.HSSBound.loadOverheads","page":"Advanced API","title":"HSSSimulations.HSSBound.loadOverheads","text":"loadNoTop(tₗ, skip)\n\nReturns the compleate HSSBound.Load struct for a HSS build with no lamp or print carriage movement. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.OverheadsBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Boundary.Load()\nTypes.Load","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Types.Load-Tuple{}","page":"Advanced API","title":"HSSSimulations.Types.Load","text":"Types.Load(;\n    name=\"default\", tₗ=1, skip=1,\n    x₁=SymetryBoundary, x₂=SymetryBoundary,\n    y₁=SymetryBoundary, y₂=SymetryBoundary,\n    z₁=SymetryBoundary, z₂=SymetryBoundary,\n)\n\nDefault constructor for Types.Load. All of the boundaries defaults to symetry boundaries (see Boundary.SymetryBoundary). See Boundary.ConductionBoundary and Boundary.ConvectionBoundary, for some more built in loads. And High Speed Sintering Boundary Example for more complicated loads.\n\nThe z₂ load is run before any others, so any calculations that need to be done first should be put there, such as recoating.\n\nExamples\n\njulia> Load(; name=\"test\", tₗ=1, skip=1, x₁=ConductionBoundary, y₂=ConvectionBoundary)\n  x₁ : ConductionBoundary\n  x₂ : SymetryBoundary\n  y₁ : SymetryBoundary\n  y₂ : ConvectionBoundary\n  z₁ : SymetryBoundary\n  z₂ : SymetryBoundary\n  name : test\n  tₗ : 1.0\n  skip : 1\n\n\n\n\n\n","category":"method"},{"location":"reference/api_adv/#HSSSimulations.Types.Load","page":"Advanced API","title":"HSSSimulations.Types.Load","text":"struct Load{X₁<:AbstractBoundary, X₂<:AbstractBoundary, Y₁<:AbstractBoundary, Y₂<:AbstractBoundary, Z₁<:AbstractBoundary, Z₂<:AbstractBoundary} <: HSSSimulations.Types.AbstractSimProperty\n\nFields\n\nx₁::Type{X₁} where X₁<:AbstractBoundary: The boundary condition for the start of the x axis ([1,:,:])\nx₂::Type{X₂} where X₂<:AbstractBoundary: The boundary condition for the end of the x axis ([end,:,:])\ny₁::Type{Y₁} where Y₁<:AbstractBoundary: The boundary condition for the start of the y axis ([:,1,:])\ny₂::Type{Y₂} where Y₂<:AbstractBoundary: The boundary condition for the end of the y axis ([:,end,:])\nz₁::Type{Z₁} where Z₁<:AbstractBoundary: The boundary condition for the start of the z axis ([:,:,1])\nz₂::Type{Z₂} where Z₂<:AbstractBoundary: The boundary condition for the end of the z axis ([:,:,end])\nname::String: Used to annotate the results\ntₗ::Float64: The duration of the load in seconds\nskip::Int64: The distance between results to save (see Why We Skip Some Results)\n\nEach of the boundaries given must satisfy Boundary isa Type{T} where T <: AbstractBoundary. This is to say that they should be the type itself, not an instance of that type. Additionally it should be a subtype of AbstractBoundary and meet all of the requirements outlined in the that documentation.\n\nnote: Note\nIf the Load is in a BuildLoadSet then one of the boundaries in one of the loads in the set should call the recoating logic so that new powder is actuall being layed down. This should always be done in the z₂ boundary, as it is a special case that ensures the indicies are updated for all other boundaries.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#Basic-Boundaries","page":"Advanced API","title":"Basic Boundaries","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Boundary.SymetryBoundary\nBoundary.ConductionBoundary\nBoundary.ConvectionBoundary","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Boundary.SymetryBoundary","page":"Advanced API","title":"HSSSimulations.Boundary.SymetryBoundary","text":"struct SymetryBoundary <: AbstractBoundary\n\nA boundary for a face that has no heatflow (such as a face on a symetrical boundary). Used as the default boundary in Types.Load.\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Boundary.ConductionBoundary","page":"Advanced API","title":"HSSSimulations.Boundary.ConductionBoundary","text":"struct ConductionBoundary <: AbstractBoundary\n\nA boundary for a face that has a source of contact conductive heat flow.\n\nFields\n\ntemp::Float64: Temperature of object being contacted\ncoef::Float64: Coefficient of contact conduction\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#HSSSimulations.Boundary.ConvectionBoundary","page":"Advanced API","title":"HSSSimulations.Boundary.ConvectionBoundary","text":"struct ConvectionBoundary <: AbstractBoundary\n\nA boundary for a face that has a source of convective heat flow.\n\nFields\n\ntemp::Float64: Air temperature\ncoef::Float64: Convection coefficient\n\n\n\n\n\n","category":"type"},{"location":"reference/api_adv/#Utilities","page":"Advanced API","title":"Utilities","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Boundary.movingObjOverlap\nBoundary.recoating!","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Boundary.movingObjOverlap","page":"Advanced API","title":"HSSSimulations.Boundary.movingObjOverlap","text":"movingObjOverlap(\n    geometry::Geometry,\n    movingObj,\n    objPos::Tuple{Int64, Int64}\n) -> Vector\n\n\nMakes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos left and right edge are given by objPos. The overlap is filled with the value passed as movingObj.\n\nThe difference between the first and second value of the objPos Tuple multipled by the spacing in the y-axis (Δy) should match the width of the moving object.\n\nExamples\n\njulia> geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));\n\njulia> movingObjOverlap(geometry, true, (2, 4))\n3-element Vector{Bool}:\n 1\n 1\n 0\n\n\n\n\n\nmovingObjOverlap(\n    geometry::Geometry,\n    movingObj::AbstractVector,\n    objPos::Int64\n) -> Any\n\n\nMakes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by objPos. The overlap is filled with the matching values from the vector movingObj.\n\nThe length of the vector multipled by the spacing in the y-axis (Δy) should match the width of the moving object.\n\nExamples\n\njulia> geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));\n\njulia> movingObjOverlap(geometry, [1, 2, 3, 4, 5], 6)\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> movingObjOverlap(geometry, [1, 2, 3, 4, 5], 8)\n3-element Vector{Int64}:\n 0\n 1\n 2\n\n\n\n\n\nmovingObjOverlap(\n    geometry::Geometry,\n    movingObj::AbstractMatrix,\n    objPos::Int64\n) -> Any\n\n\nMakes a matrix with the same dimensions as the top surface of the simulation area. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by objPos. The overlap is filled with the matching values from the matrix movingObj.\n\nAlso for Matrix inputs, the length of the first axis multipled by the spacing in the x-axis (Δx) should match the depth of the moving object and the length of the second axis multipled by the spacing in the y-axis (Δy) should match the width of the moving object.\n\nExamples\n\njulia> geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));\n\njulia> movingObjOverlap(geometry, [1 2 3; 4 5 6; 7 8 9], 4)\n3×3 Matrix{Int64}:\n 2  3  0\n 5  6  0\n 8  9  0\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#HSSSimulations.Boundary.recoating!","page":"Advanced API","title":"HSSSimulations.Boundary.recoating!","text":"recoating!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep,\n    recoatDist,\n    temp\n)\n\n\nPowder recoating logic. This updates the indices and fills the new real indices with the initial results provided in the simulation's Problem, except the temperature, which is set to temp. This allows for the new powder temp to be set to the temperature of the powder in the hopper, or feed bed, at that time in the build. This always runs in the positive y axis, so new powder is always deposited starting from [:, 1, :] and going to [:, end, :].\n\n\n\n\n\n","category":"function"},{"location":"reference/api_adv/#Logging","page":"Advanced API","title":"Logging","text":"","category":"section"},{"location":"reference/api_adv/","page":"Advanced API","title":"Advanced API","text":"Solver.makeLogger","category":"page"},{"location":"reference/api_adv/#HSSSimulations.Solver.makeLogger","page":"Advanced API","title":"HSSSimulations.Solver.makeLogger","text":"makeLogger(debugGroups, logFile) -> LoggingExtras.TeeLogger\n\n\ndebugGroups is a list of groups of debug messages to log to the logFile. If it is set to true then all log groups in the package are used (see package_groups), if it is set to false then no log groups are used.\n\nUser log groups can be added to the list, simple add your own string to the list and then set debug messages with the _group field set to your string.\n\nThere is a special group called \"misc\" that will catch any group not in the package_groups list or in any additional group given by the user to the debugGroups list.\n\n\n\n\n\n","category":"function"},{"location":"howtos/howto_subsets/#Simulating-Subsets-of-a-Build","page":"Simulate Subsets of a Build","title":"Simulating Subsets of a Build","text":"","category":"section"},{"location":"howtos/howto_subsets/#A-Single-Layer","page":"Simulate Subsets of a Build","title":"A Single Layer","text":"","category":"section"},{"location":"howtos/howto_subsets/","page":"Simulate Subsets of a Build","title":"Simulate Subsets of a Build","text":"This simulates a single layer deposited on top of a uniformly preheated powder bed.","category":"page"},{"location":"howtos/howto_subsets/","page":"Simulate Subsets of a Build","title":"Simulate Subsets of a Build","text":"geometry = Geometry(\n    (0.016, 0.016, 0.031),\n    0.001,\n    1.5e-3;\n    Δz=0.003 / 90,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 1 layer of build\",\n)\nmaterial = PA2200(geometry)\nparams = HSSParams(geometry)\nloadSets = HSSLoads(1, geometry; nrPreheat=0, lenPreheat=0.0, nrCool=0, lenCool=0.0)\n\ngeomsize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(geomsize, 160.0, 0.0, 0.0, 1000.0, 0)\ninitialLayer = 30\n\ninkArray = fill(material.eₚ, size)\nink = Ink(inkArray, \"Empty\")\n\nfile = tempname()\ndescription = \"A single layer simulation with no ink\"\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    preheatLoads=preheatLoads,\n    buildLoads=buildLoads,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    description=description,\n)\n\nresultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"reference/PostProcessing/#Post-Processing","page":"Post proccessing","title":"Post Processing","text":"","category":"section"},{"location":"reference/PostProcessing/","page":"Post proccessing","title":"Post proccessing","text":"PostProcessing.makeIndex","category":"page"},{"location":"reference/PostProcessing/#HSSSimulations.PostProcessing.makeIndex","page":"Post proccessing","title":"HSSSimulations.PostProcessing.makeIndex","text":"makeIndex(group)\n\nwarning: Warning\nThis function is hard coded to only make an index for two levels deep, this is meant to work with the loadsets and loads as the two levels.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"EditURL = \"https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/lit/basic_tut.jl\"","category":"page"},{"location":"tutorials/2_basic_tut/#Tutorial-2:-Warm-up-and-Cool-down-only","page":"2 Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"using HSSSimulations","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"This tutorial will cover how to create a basic simulation problem, solve it, and inspect the results. This basic simulation will only simulate a solid block without, no layers or anything else fancy.","category":"page"},{"location":"tutorials/2_basic_tut/#Defining-the-Problem","page":"2 Warm-up and Cool-down only","title":"Defining the Problem","text":"","category":"section"},{"location":"tutorials/2_basic_tut/#Geometry","page":"2 Warm-up and Cool-down only","title":"Geometry","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"First we'll start by defining the finite difference geometry for the problem. This is done by creating an instance of Geometry as shown below. The first argument is the size of the simulation in meters (here it is 10 mm x 10 mm x 30 mm), the second is the spacing between the finite difference nodes, and the third is the time step. Finally, a name has been given to make it easier to figure out what we're looking at if we come back to this in the future.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"geometry = Geometry(\n    (0.010, 0.010, 0.030),\n    0.0005,\n    0.001;\n    name=\"Basic Simulation Tutorial\",\n)","category":"page"},{"location":"tutorials/2_basic_tut/#Material","page":"2 Warm-up and Cool-down only","title":"Material","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"For the material we will use the default material model along with the example material, PA2200 (for information on defining a new material or material model see Material Recipes.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"material = PA2200(geometry)","category":"page"},{"location":"tutorials/2_basic_tut/#Boundary-and-Loads","page":"2 Warm-up and Cool-down only","title":"Boundary and Loads","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"For the boundary conditions we will borrow some things from the boundary example module High Speed Sintering Boundary Example.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"params = HSSParams(\n    geometry;\n    overheadPower=300.0,\n    name=\"Overhead heat and cool\",\n)","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"First we make the Types.AbstractProblemParams we will be using, a HSSParams struct (This includes way more than we need here, but it will still work. If you want to define a simpler struct have a look at Problem Solver Recipes).","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"skipper = 20\ncooldownLoads = vcat(\n    [HSSBound.loadOverheads(3.0, skipper) for _ in 1:2],\n    [HSSBound.loadCooldown(3.0, skipper) for _ in 1:2],\n)","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"Next we make an array of the load conditions we want to simulate. For this example we will be putting all of our loads in the cooldown loads, as we aren't dealing with layers we don't need the build loads, and the preheat loads are run before any layers are deposited, so they can't really be used here.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"Put simply, this will simulate 1.5 minutes (3x30 seconds) of heating from the overhead heaters (HSSBound.loadOverheads) followed by 15 minutes of cooling (HSSBound.loadCooldown). The skipper is how often the results will be saved, here we are saying to only save one result for every 20 time steps (See Why We Skip Some Results for more information on why).","category":"page"},{"location":"tutorials/2_basic_tut/#Initial-Conditions","page":"2 Warm-up and Cool-down only","title":"Initial Conditions","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"Next up is the initial results. Before we define them, we'll make life a little easier for ourselves by making a tuple to represent the simulation size (unlike the one we used earlier, this one is the simulation size in number of nodes, instead of in meters).","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"geomSize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(geomSize, 25.0, 0.0, 0.0, 0.0, 0)\ninitLay = geometry.Z","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"The initial condition (made as a Result) here will set all the simulation to 25 °C and set the melt state and consolidation state to zero.","category":"page"},{"location":"tutorials/2_basic_tut/#Ink","page":"2 Warm-up and Cool-down only","title":"Ink","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"inkArray = fill(material.eₚ, geomSize)\nink = Ink(inkArray, \"No ink\")","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"We'll use the size tuple again to make an array to hold our Ink values. This array stores the emissivity for all the points in the simulation, as we are not printing any ink for this simulation we will just set it all to the powder's emissivity.","category":"page"},{"location":"tutorials/2_basic_tut/#Construct-The-Problem","page":"2 Warm-up and Cool-down only","title":"Construct The Problem","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"With everything set up the last step is to give it a little description, decide where to save the results to and then create the Problem (ignore the geometry.Z, we'll cover that in the Tutorial 1: Full Build).","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"note: Note\nThe file path given here will save the results to the temporary directory on a Unix based system. If you are using windows, or want to save the file elsewhere then you should change the path.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"file = tempname()\ndescription = \"A basic simulation to teach us how to use this package\"\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=geometry.Z,\n    ink=ink,\n    file=file,\n    description=description,\n)","category":"page"},{"location":"tutorials/2_basic_tut/#Solving-the-Problem","page":"2 Warm-up and Cool-down only","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"Now the complicated bit. We need to run the following:","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"resultFile, finalResult = problemSolver(problem)","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"No really, that's it. That one line will solve your problems for you (well, your simulation problems). It might take a while, but once it starts solving the loads you should get some nice progress bars to reassure you that it hasn't just crashed.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"The resultFile returned is just the file path to read the results from, as the simulation results can get quite big in their uncompressed form they aren't all kept in memory (also why we set the skip to 20 earlier, otherwise the results would be 20x as big). However, the final time step is returned, captured here in the finalResult variable. Just in case you quickly need the end results.","category":"page"},{"location":"tutorials/2_basic_tut/#Inspecting-the-Results","page":"2 Warm-up and Cool-down only","title":"Inspecting the Results","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"Now we have solved the problem, we should probably have a look at what the results were. Firstly we can get a good overview of the results using the","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"","category":"page"},{"location":"tutorials/2_basic_tut/","page":"2 Warm-up and Cool-down only","title":"2 Warm-up and Cool-down only","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/howto_loadset/#loadsettype","page":"Load Set Types","title":"Load Set Type Recipes","text":"","category":"section"},{"location":"howtos/howto_loadset/","page":"Load Set Types","title":"Load Set Types","text":"Before reading this, it might be a good idea to have a look at AbstractLoadSet.","category":"page"},{"location":"howtos/howto_loadset/","page":"Load Set Types","title":"Load Set Types","text":"The previous tutorials have been removed as they were obsoleted by new features, stay tuned for their replacements.","category":"page"},{"location":"howtos/howto_load/#Load-Recipes","page":"Loads and Load Sets","title":"Load Recipes","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"You might want to check out Load","category":"page"},{"location":"howtos/howto_load/#A-Cooling-Recoat-Load-and-Load-Set","page":"Loads and Load Sets","title":"A Cooling Recoat Load and Load Set","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"This load will and load set use the boundary that we created in A Cooling Recoat Boundary","category":"page"},{"location":"howtos/howto_load/#Loads","page":"Loads and Load Sets","title":"Loads","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"When making a load, we only need to define the boundaries that are different from the default, any undefined boundaries are left as SymetryBoundarys.","category":"page"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"Well make a function to create a new Load that takes a time length and a skip ([Why We Skip Some Results]@ref).","category":"page"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"function loadRecoatCoolStroke(tₗ, skip)\n    return Load(;\n        # Lets give it a name we'll be able to recognise later\n        name = \"Cooldown Recoat\",\n        tₗ   = tₗ,\n        skip = skip,\n        # Set the bottom boundary\n        z₁=PistonCoolBoundary,\n        # Set the top boundary\n        z₂=RecoatCoolBoundary,\n    )\nend","category":"page"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"Well also make a matching load to go with the matching boundary from A Cooling Recoat Return Boundary.","category":"page"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"function loadRecoatCoolReturnStroke(tₗ, skip)\n    return Load(;\n        name = \"Cooldown Return\",\n        tₗ   = tₗ,\n        skip = skip,\n        z₁   = PistonCoolBoundary,\n        z₂   = RecoatCoolReturnBoundary,\n    )\nend","category":"page"},{"location":"howtos/howto_load/#Load-Set","page":"Loads and Load Sets","title":"Load Set","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"The load sets that are given to the solver are actually just a list of loads. So here we'll just make a function that returns a list of the loads we want. This one works for a recoater that spends 7 seconds over the bed with one second between each time it's over the bed.","category":"page"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"function cooldownLoadSet(skip)\n    return [\n        # A load without any carriage movement to represent when the carriage\n        # isn't above the bed\n        loadCooldown(1.0, skip),\n        loadRecoatStroke(7.0, skip),\n        loadCooldown(1.0, skip),\n        loadRecoatReturnStroke(7.0, skip),\n        loadCooldown(1.0, skip),\n    ]\nend","category":"page"},{"location":"howtos/howto_load/","page":"Loads and Load Sets","title":"Loads and Load Sets","text":"If we wanted this to have custom behaviour in the problem we might want to define a new LoadSet type or if you want even more complicated behaviour, have a look at Problem Solver Recipes.","category":"page"},{"location":"reference/MaterialExamples/#Material-Examples","page":"Material examples","title":"Material Examples","text":"","category":"section"},{"location":"reference/MaterialExamples/#PA2200","page":"Material examples","title":"PA2200","text":"","category":"section"},{"location":"reference/MaterialExamples/","page":"Material examples","title":"Material examples","text":"Provided is an example material property structs based on EOS's PA2200 powder. Calling it with no arguments will return the relevant MatProp struct.","category":"page"},{"location":"reference/MaterialExamples/","page":"Material examples","title":"Material examples","text":"The sources of the data used are summarized below. For more details, check the material model chapter of my thesis.","category":"page"},{"location":"reference/MaterialExamples/","page":"Material examples","title":"Material examples","text":"Material.PA_κ\nMaterial.PA_ρ\nMaterial.PA_c\nMaterial.PA_Mᵣ\nMaterial.PA_Rᵣ\nMaterial.PA_Hf\nMaterial.PA_Hr\nMaterial.PA_Ċ\nMaterial.PA_eₚ\nMaterial.PA_eᵢ\nMaterial.PA_ε","category":"page"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_κ","page":"Material examples","title":"HSSSimulations.Material.PA_κ","text":"Values from Yaun 2014 used for consolidation state of 0 and 1 (at a melt state of 0). And values from Riedlbaur 2015 (I think originally from Rietzel 2011, but my German isn't good enough to confirm) used for a melt state of 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_ρ","page":"Material examples","title":"HSSSimulations.Material.PA_ρ","text":"Assumes density is constant across temperatures and at data sheet values for maximum consolidation state. For consolidation and melt state zero, the measured value of the powder in the machine is used. The melted density is based on observations while taking dilatometry measurments.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_c","page":"Material examples","title":"HSSSimulations.Material.PA_c","text":"Data taken from stepscan of PA2200, processed by perkin-elmer dsc software. Melt region is interpolated over to avoide issuse with .\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_Mᵣ","page":"Material examples","title":"HSSSimulations.Material.PA_Mᵣ","text":"A normalized cumulative integral of the energy in to a system during melting from a DSC curves.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_Rᵣ","page":"Material examples","title":"HSSSimulations.Material.PA_Rᵣ","text":"A normalized cumulative integral of the energy out of a system during recrystallization from DSC curves. With each curve taken from increasing melt states.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_Hf","page":"Material examples","title":"HSSSimulations.Material.PA_Hf","text":"The difference between the energy in to the system during melting (from a DSC curve), and an interpolated line drawn between the sections of heating outside of the melt region.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_Hr","page":"Material examples","title":"HSSSimulations.Material.PA_Hr","text":"The difference between the energy out of the system during crystallization (from a DSC curve), and an interpolated line drawn between the sections of cooling outside of the recrystallization region.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_Ċ","page":"Material examples","title":"HSSSimulations.Material.PA_Ċ","text":"Based on model from Childs and Tontowi 2001. Modified to work off of consolidation and melt states. Calibrated from dilatometry data. See Material.PA_Ċ_maker for how to make your own.\n\n\n\n\n\n","category":"function"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_eₚ","page":"Material examples","title":"HSSSimulations.Material.PA_eₚ","text":"Taken from near ir experiments.\n\n\n\n\n\n","category":"constant"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_eᵢ","page":"Material examples","title":"HSSSimulations.Material.PA_eᵢ","text":"Taken from near ir experiments.\n\n\n\n\n\n","category":"constant"},{"location":"reference/MaterialExamples/#HSSSimulations.Material.PA_ε","page":"Material examples","title":"HSSSimulations.Material.PA_ε","text":"Taken from pyrometer calibrations.\n\n\n\n\n\n","category":"constant"},{"location":"howtos/howto_bound/#Boundary-Recipes","page":"Boundaries","title":"Boundary Recipes","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"AbstractBoundary and boundaryHeatTransferRate are your places to go for more information.","category":"page"},{"location":"howtos/howto_bound/#A-Fixed-Heat-Flux-Boundary","page":"Boundaries","title":"A Fixed Heat Flux Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"struct FixedHeatFluxBoundary <: AbstractBoundary\n    # Here goes the parameters that we will have access to in this boundaries\n    # method for the boundaryHeatTransferRate. We wont actually have any for\n    # this boundary\n    # heat flux we want to use as the fixed value.\n\n    # Our new boundary has to have a constructor that meets the signature\n    # requirements detailed in the AbstractBoundary documentation. For this\n    # boundary we don't need any of the inputs so we'll just discard them.\n    FixedHeatFluxBoundary(_, _, _, _) = new()\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"This boundary needs to implement a method for the boundaryHeatTransferRate function. This is what will be called on each node of the simulation that is on the boundary. As with the constructor, our simple boundary can ignore all the fields.","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"function Types.boundaryHeatTransferRate(_, _, _::FixedHeatFluxBoundary)\n    # Return a floating point representing the heat flux density\n    return 10.0\nend","category":"page"},{"location":"howtos/howto_bound/#A-Variable-Heat-Flux-Boundary","page":"Boundaries","title":"A Variable Heat Flux Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"Let's raise the stakes a little (but not much), we'll make a new boundary that has a heat flux density that changes depending only on the current time of the simulation. We'll have to make a new AbstractProblemParams (the one used here is from A Variable Heat Flux Parameter Set)","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"struct FixedHeatFluxBoundary <: AbstractBoundary\n    # All we need for this one is the heat flux we want to.\n    heatFluxDensity::Float64\n\n    # Our new boundary has to have a constructor that meets the signature\n    # requirements detailed in the AbstractBoundary documentation. For this\n    # boundary we only actually need two of the inputs, so we'll just discard\n    # the rest of them.\n    function RecoatCoolBoundary(_, cts, prob::Problem, _)\n        # Normally a boundary's constructor would use the params field that we\n        # gave to the problem quite a bit, so it's handy to make it easier to\n        # access. In this case it will only be used once, but I'll keep this\n        # here out of good habit anyway.\n        param = prob.params\n\n        # The current time step (cts) is given in, so lets grab its time to use\n        # in our heat flux function.\n        time = cts.t\n        heatflux = param.heatflux(time)\n\n        # Another useful field in prob is the problems geometry. Here we'll use\n        # this to find out the area of a node, to convert our heat flux into a\n        # heat flux density.\n        geom = prob.geometry\n        # Finding the area of the face of a node parallel to the y-axis\n        area = geom.X * geom.Z\n        heatfluxdensity = heatflux / area\n\n        return new(heatfluxdensity)\n    end\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"function Types.boundaryHeatTransferRate(_, _, p::FixedHeatFluxBoundary)\n    # Return a floating point representing the heat flux density\n    return p.heatfluxdensity\nend","category":"page"},{"location":"howtos/howto_bound/#A-Cooling-Recoat-Boundary","page":"Boundaries","title":"A Cooling Recoat Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"This boundary behaves very similarly to the built-in boundary RecoatBoundary, but it uses the temperatures for the air and internal surfaces. It also conditionally calls coolingStart to make sure that the start time of the cool down stage is set. And the lamp is turned off (even if there is a recoat lamp power set).","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"struct RecoatCoolBoundary <: AbstractBoundary\n    # All of the parameters we need to pass into the boundaryHeatTransferRate function\n    overheadTemp::Float64\n    surfaceTemp::Float64\n    eₗ::Array{Float64,3}\n    ε::Float64\n    airTemp::Float64\n    h::Float64\n    shadow::Vector{Bool}\n    Po::Float64\n\n    function RecoatCoolBoundary(pts, cts, prob::Problem, ls::Types.LoadStep)\n        param = prob.params\n\n        # Use an overhead power of 0 w\n        param.overheadTemp = overheadTemp = param.overheadHeatupFunc(0.0, param.overheadTemp, cts)\n\n        # If the coolStart hasn't been set, set it\n        if isnan(prob.params.coolStart)\n            coolingStart(pts.t, cts.t, prob.params)\n        end\n\n        # Find how far through the cooling parameters the current time step is\n        tAir = (cts.t - param.coolStart) + param.airCoolStart\n        tSurface = (cts.t - param.surfaceCoolStart\n\n        # Use the *Cool parameters to find the air and surface temperatures\n        airTemp = param.airCool(tAir)\n        surfaceTemp = param.surfaceCool(tSurface)\n\n        # Get the other parameters to pass through\n        eₗ = prob.eᵗ\n        ε = prob.matProp.ε\n        h = param.convectionCoef\n        Po = param.percentOverhead\n\n        # Calculate the position of the carriage and therefor its shadow\n        pos = ceil(Int, (param.carriageWidth + prob.geometry.Y_BUILD) * cts.tₚ)\n        shadowPos = (pos - param.carriageWidth, pos)\n        shadow = movingObjOverlap(prob.geometry, true, shadowPos)\n\n        # Calculate the distance across the bed the recoater has traveled, and\n        # use it to set the new nodes\n        recoatDist = pos - param.recoatOffset\n        if prob.geometry.Y_OFFSET < recoatDist <= prob.geometry.Y_OFFSET + prob.geometry.Y\n            recoatDist = recoatDist - prob.geometry.Y_OFFSET\n            recoating!(pts, cts, prob, ls, recoatDist, surfaceTemp)\n        end\n\n        # Any new powder put down is set to have the machines ambient air\n        # temperature as it's initial temperature\n        z₂ᵣ = map(first, ls.ind.z₂)\n        for i in z₂ᵣ\n            if pts.T[i] == prob.init.T[i]\n                pts.T[i] = airTemp\n            end\n        end\n\n        return new(overheadTemp, surfaceTemp, eₗ, ε, airTemp, h, shadow, Po)\n    end\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"The new method for the boundaryHeatTransferRate is the same as the method use for the RecoatBoundary but without the lamp logic.","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"function Types.boundaryHeatTransferRate(T, i, p::RecoatCoolBoundary)\n    shadow = p.shadow[i[2]]\n    eₗ = p.eₗ[i]\n    return (\n        convectionFlow(T, p.airTemp, p.h) +\n        radiationFlow(T, p.surfaceTemp, p.ε) * (shadow || (1 - p.Po)) +\n        radiationFlow(T, p.overheadTemp, p.ε) * !shadow * p.Po\n    )\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"Have a look at A Cooling Recoat Load and Load Set to see how to use this in a load.","category":"page"},{"location":"howtos/howto_bound/#A-Cooling-Recoat-Return-Boundary","page":"Boundaries","title":"A Cooling Recoat Return Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"To make use of the above boundary, it would be handy to have a load that represents the recoat carriage returning to its initial position (going in the other direction to the above load).","category":"page"},{"location":"howtos/howto_bound/","page":"Boundaries","title":"Boundaries","text":"struct RecoatCoolReturnBoundary <: AbstractBoundary\n    overheadTemp::Float64\n    surfaceTemp::Float64\n    eₗ::Array{Float64,3}\n    ε::Float64\n    airTemp::Float64\n    h::Float64\n    shadow::Vector{Bool}\n    Po::Float64\n\n    function RecoatCoolReturnBoundary(pts, cts, prob::Problem, ls::Types.LoadStep)\n        param = prob.params\n        param.overheadTemp = overheadTemp = param.overheadHeatupFunc(0.0, param.overheadTemp, cts)\n\n        # We'll still call this, in case we want to use this boundary before the previous one\n        if isnan(param.coolStart)\n            coolingStart(pts.t, cts.t, param)\n        end\n\n        tAir = (cts.t - param.coolStart) + param.airCoolStart\n        tSurface = (cts.t - param.coolStart) + param.surfaceCoolStart\n        airTemp = param.airCool(tAir)\n        surfaceTemp = param.surfaceCool(tSurface)\n        eₗ = prob.eᵗ\n        ε = prob.matProp.ε\n        h = param.convectionCoef\n        Po = param.percentOverhead\n\n        # Calculate the position of the carriage on its return stroke\n        pos = ceil(Int, (param.carriageWidth + prob.geometry.Y_BUILD) * (1 - cts.tₚ))\n        shadowPos = (pos - param.carriageWidth, pos)\n        shadow = movingObjOverlap(prob.geometry, true, shadowPos)\n\n        # No need to run any of the recoat logic for this one\n        return new(overheadTemp, surfaceTemp, eₗ, ε, airTemp, h, shadow, Po)\n    end\nend\n\nfunction Types.boundaryHeatTransferRate(T, i, p::RecoatCoolReturnBoundary)\n    shadow = p.shadow[i[2]]\n    eₗ = p.eₗ[i]\n    return (\n        convectionFlow(T, p.airTemp, p.h) +\n        radiationFlow(T, p.surfaceTemp, p.ε) * (shadow || (1 - p.Po)) +\n        radiationFlow(T, p.overheadTemp, p.ε) * !shadow * p.Po\n    )\nend","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"EditURL = \"https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/lit/full_tut.jl\"","category":"page"},{"location":"tutorials/1_full_tut/#Tutorial-1:-Full-Build","page":"1 Full Build","title":"Tutorial 1: Full Build","text":"","category":"section"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"using HSSSimulations","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"This tutorial will cover how to create a simulation problem, solve it, and inspect the results. It differs from the Tutorial 2: Warm-up and Cool-down only (which I will assume you have gone through) by actually trying to simulate part of a printer build, instead of a contrived situation. This means we'll have preheat loads, layers being added and complex boundary conditions. Whilst the simulation is more complicated, some setup is actually easier, as this is what the package was built for.","category":"page"},{"location":"tutorials/1_full_tut/#Defining-the-Problem","page":"1 Full Build","title":"Defining the Problem","text":"","category":"section"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"Like before, we'll start by defining the geometry:","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"geometry = Geometry(\n    (0.016, 0.016, 0.0122),\n    0.001,\n    1.5e-3;\n    Δz=0.003 / 90,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers\",\n)","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"There are some additional arguments given here, let's go over them quickly. In the basic simulation we specified the node spacing as the second argument, and this specified the spacing in all three axis. Here we add a Δz argument, when this is given it overrides the node spacing for this one axis. This is useful as we want the spacing in the z-axis to be the same as the layer height, but using the same spacing in all axes would limit the size of the simulation. This leads nicely on to Δh, which is the layer thickness in meters (100 microns in this case).","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"note: Note\nA Δy argument can also be given to override the node spacing in the y-axis. There is no equivalent for the x-axis, instead just give the desired spacing as the default and use the Δz and Δy overrides to get the desired spacing.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"The last two are the buildSize and offset. It is often useful to simulate a subset of the build volume (mostly for memory and computational cost reasons), to do this we can specify the true size of the machine (buildSize) and where the simulation sits within it (offset). Both of these are given in meters.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"We'll use the other built-in material this time, a version of the PA2200 material used before that has the rate of change of consolidation state dependent on more than just temperature.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"material = PA2200(geometry)","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"This time around we can just use the load sets provided by HSSLoads, without having to muck about with it ourselves. Here we define the skip (in this case lets go for 10), and a few extra key word arguments that decide how many preheat and cooldown loads to have, along with how long they should be (so preheat time in this case is 90x10, for 900 seconds total).","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"note: Note\nMultiple short loads are used in cases where the load case stays the same for a while. The solver only saves results from memory to disk in between loads, so splitting it up reduces the memory requirement (at the cost of a slight increase in computational cost).","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"params = HSSParams(geometry)\nloadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"When we specify the initial results, we'll also specify the initialLayer, this will be used to tell the simulation how many layers worth of powder should be already deposited at the start of the simulation. Theses are the layers that will be simulated during the preheat load set.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"geomsize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(geomsize, 25.0, 0.0, 0.0, 0.0, 0)\ninitialLayer = 30","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"The Ink struct for this problem is going to have some actual ink in it. To do this we will fill a subset of the inkArray with a value of 1.0 this is making the assumption that our ink is a perfect absorber of our lamp's energy. And we'll also change the name of the Ink to represent this.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"inkArray = fill(material.eₚ, size)\ninkArray[5:end-4, 5:end-4, 90:end-30] .= material.eᵢ\nink = Ink(inkArray, \"Sample square\")","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"And like before we will give the problem a name and description and then create it.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"file = \"full_build_simulation_tutorial.jld2\"\ndescription = \"A full simulation of a sample square\"\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    preheatLoads=preheatLoads,\n    buildLoads=buildLoads,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    description=description,\n)","category":"page"},{"location":"tutorials/1_full_tut/#Solving-the-Problem","page":"1 Full Build","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"Like before, this part is simple for you. But now it is even more complicated for the computer.","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"resultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"tip: Performance Tips\nThe simulation will only run on one proccessor, but will run on as many threads as you can give it. So if you haven't already, try starting juila with the --threads=auto flag to give the simulation more threads to work with. If you are using a notebook you will need to look into how to make a kernel that uses multiple threads.If it is still running too slow you can try playing around with the geometry sizes, the x and y-axis node spacing or the time step (just be aware that changing node spacing and time step can lead to unstable simulations, normally resultsing in an out of bounds error). And if you run into memory issues you can try increasing the value of skip (Why We Skip Some Results).","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"","category":"page"},{"location":"tutorials/1_full_tut/","page":"1 Full Build","title":"1 Full Build","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/howto_ink/#Ink-Pattern-Recipes","page":"Ink Patterns","title":"Ink Pattern Recipes","text":"","category":"section"},{"location":"reference/BoundaryExamples/#High-Speed-Sintering-Boundary-Example","page":"HSS Boundary","title":"High Speed Sintering Boundary Example","text":"","category":"section"},{"location":"reference/BoundaryExamples/","page":"HSS Boundary","title":"HSS Boundary","text":"For an explanation of what exactly this boundary is doing see High Speed Sintering Boundary Explanation","category":"page"},{"location":"reference/BoundaryExamples/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSParams\nHSSParams(::Geometry)\nHSSLoads","category":"page"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSParams","page":"HSS Boundary","title":"HSSSimulations.HSSBound.HSSParams","text":"An example structure to hold the boundary condition constants used in the example boundary condition functions. T1 must be a function that has the same signature as overheadTempFunc\n\nFields\n\nname::String\npistonHeat::Any\npistonCool::Any\nconductionCoef::Float64\nairHeat::Any\nairCool::Any\nconvectionCoef::Float64\nsurfaceHeat::Any\nsurfaceCool::Any\npowderTemp::Any\nsinterLamp::Vector{Float64}\nrecoatLamp::Vector{Float64}\nlampWidth::Int64\nlampOffset::Int64\ncarriageWidth::Int64\nprintCarriageWidth::Int64\nprintOffset::Int64\nrecoatOffset::Int64\nsurfaceTarget::Float64\nsurfaceTol::Float64\noverheadHeatupFunc::Any\noverheadLayerStep::Int64\noverheadPowerStep::Float64\noverheadMaxPower::Float64\npercentOverhead::Float64\noverheadPower::Float64: Current power input of overhead heaters\noverheadTemp::Float64: Current temperature of overhead heaters\nlastUpdatedOverhead::Int64: The last layer the overheads were updated on\ncoolStart::Float64: The time at the start of cooling loads\npistonCoolStart::Float64: The offset time if the piston wasn't at max temp at start of cooling\nairCoolStart::Float64: The offset time if the air wasn't at max temp at start of cooling\nsurfaceCoolStart::Float64: The offset time if the machine's internal suraface wasn't at max temp at start of cooling\n\n\n\n\n\n","category":"type"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSParams-Tuple{Geometry}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.HSSParams","text":"HSSParams(\n    geometry::Geometry;\n    name,\n    pistonPath,\n    airPath,\n    surfacePath,\n    conductionCoef,\n    lampVector,\n    lampWidth,\n    lampOffset,\n    carriageWidth,\n    recoatOffset,\n    printCarriageWidth,\n    printOffset,\n    surfaceTarget,\n    surfaceTol,\n    overheadLayerStep,\n    overheadPercentStep,\n    overheadTemp,\n    overheadPower,\n    overheadPowerOut,\n    overheadHeatCapacity,\n    overheadMaxPower,\n    convectionCoef,\n    sinterPower,\n    recoatPower,\n    lastUpdatedOverhead,\n    percentOverhead,\n    powderTempDelta,\n    overheadHeatupFunc\n) -> HSSParams{_A, _B, _C, _D, _E, _F, HSSSimulations.HSSBound.var\"#16#21\"{Geometry, HSSSimulations.HSSBound.var\"#15#20\", Float64}} where {_A, _B, _C, _D, _E, _F}\n\n\nThe geometry (of type Geometry) should be the same one used for the simulation. If the piston target temperature is chaneged then the piston path will need to be changed to curves that will match the target temperature. Same if the preheat bed is thicker than the normal ≈3 mm.\n\n\n\n\n\n","category":"method"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSLoads","page":"HSS Boundary","title":"HSSSimulations.HSSBound.HSSLoads","text":"HSSLoads(\n    skip,\n    geometry;\n    nrPreheat,\n    lenPreheat,\n    nrCool,\n    lenCool,\n    sinterSpeed,\n    lcAndBedWidth\n) -> Vector{AbstractLoadSet}\n\n\nReturns a list of loads for the preheat, build and cooldown loadsets for a default build for the HSS example. The same skip is used for all load steps (See Why We Skip Some Results for more information on skip).\n\njulia> HSSLoads(10, Geometry((1,1,1),1,1); nrPreheat=5, lenPreheat=60.0, nrCool=5, lenCool=60.0, sinterSpeed=0.160)\n3-element Vector{AbstractLoadSet}:\n   name : Preheat\n  loads\n----------------------\n\n  Name: Overheads Only\n  For 5 loads\n\n\n\n   name : Layer\n  finishLayer : 0\n  loads\n----------------------\n\n  Name: Overheads Only\n  Name: Sintering\n  Name: Overheads Only\n  Name: Recoating\n  Name: Overheads Only\n  Name: No Inking\n  Name: Overheads Only\n  Name: Inking\n\n\n\n   name : Cooldown\n  loads\n----------------------\n\n  Name: Overheads Off\n  For 5 loads\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#Loads","page":"HSS Boundary","title":"Loads","text":"","category":"section"},{"location":"reference/BoundaryExamples/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.loadCooldown\nHSSBound.loadSinterStroke\nHSSBound.loadRecoatStroke\nHSSBound.loadInkStroke\nHSSBound.loadBlankStroke","category":"page"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.loadCooldown","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadCooldown","text":"loadCooldown(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nUses HSSBound.OverheadsCoolBoundary and HSSBound.PistonCoolBoundary so that the overhead and piston heaters are turned off. Assumes that once cooling starts it doesn't stop.\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.loadSinterStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadSinterStroke","text":"loadSinterStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with recoat/lamp carriage over the build and the recoat lamp set to sinter power. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.SinterBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.loadRecoatStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadRecoatStroke","text":"loadRecoatStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with the recoat/lamp carriage over the build area, the lamp set to recoat power and new powder being deposited movement. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.RecoatBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.loadInkStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadInkStroke","text":"loadInkStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with the print head carriage over the build volume depositing ink. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.InkBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.loadBlankStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadBlankStroke","text":"loadBlankStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with the print head carriage over the build area but not on the ink deposition stroke. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.BlankBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#Utilities","page":"HSS Boundary","title":"Utilities","text":"","category":"section"},{"location":"reference/BoundaryExamples/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.lampMaker\nHSSBound.overheadTempFunc\nHSSBound.coolingStart","category":"page"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.lampMaker","page":"HSS Boundary","title":"HSSSimulations.HSSBound.lampMaker","text":"lampMaker(\n    lampVector::Vector,\n    lampWidth,\n    geometry::Geometry\n) -> Any\n\n\nReturns a vector of heat flux density coefficients representing the lamp, with the same node spacing as the simulation. The returned vector can be multiplied by the lamp power, in watts, to get a vector of heat flux densities of the lamp.\n\nArguments\n\nlampVector::Vector : A vector represeting the heat distribution of the lamp in the y axis\nlampWidth : The total width represented by the lamp vector (in the y axis, in nodes).\ngeometry::Geometry : The simulation geometry\n\nnote: Note\nIf the lamp width divided by the length of the lamp vector is not equal to the Δy then linear interpolation is used to fill in the values.\n\nwarn: Warn\nThis uses the Δx and Δy node spacings to calculate the area used to convert to heat flux density, because of this it is only applicable to the z₁ and z₂ boundaries.\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.overheadTempFunc","page":"HSS Boundary","title":"HSSSimulations.HSSBound.overheadTempFunc","text":"overheadTempFunc(\n    powerIn,\n    powerOut,\n    overheadHeatCapacity,\n    Δt,\n    prevOverheadTemp\n) -> Any\n\n\nCalculates the new temperature of a an overhead heater that has a given power output and is set to a given power (powerIn) values.\n\nArguments\n\npowerOut : A function that takes the temperatu of the heater and returns the power output\noverheadHeatCapacity : The heat capacity of the overhead heater\nprevOverheadTemp : The previous temperature of the overhead heaters\n\n\n\n\n\n","category":"function"},{"location":"reference/BoundaryExamples/#HSSSimulations.HSSBound.coolingStart","page":"HSS Boundary","title":"HSSSimulations.HSSBound.coolingStart","text":"coolingStart(tₚ, t, params::AbstractProblemParams)\n\n\nSets the time that the cooling starts, to be used to calculate how far into the cooling the simulation is during future time steps.\n\nIt also finds how far into the cooling curves of the different components to start based on the current temperature of that component. If the current temperature is less than any temperature in the cooling curve it will default to starting at the end of the curve.\n\nThis requires the type of pistonCool, airCool and surfaceHeat have methods for findfirst\n\n\n\n\n\n","category":"function"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"EditURL = \"https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/lit/material_tut.jl\"","category":"page"},{"location":"tutorials/3_material_tut/#Tutorial-3:-A-Melt-Rate-Based-Material-Model","page":"3 A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"using HSSSimulations","category":"page"},{"location":"tutorials/3_material_tut/#Overview","page":"3 A Melt Rate Based Material Model","title":"Overview","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"This tutorial will cover how to implement the time dependent melt state model introduced in my thesis. To do this, this tutorial builds on top of the full build tutorial by adding a new material property type.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"This is a proposed solution for the poor results of the melt state results found in my thesis is to model the melt state similarly to how the default material model treats the Consolidation state, making it time dependent. This has not been implemented as the default model as I don't currently have the required data, but if you have the data then you can use this implementation (my thesis should include an idea for how to get the data).","category":"page"},{"location":"tutorials/3_material_tut/#Making-the-Material-Property-Struct","page":"3 A Melt Rate Based Material Model","title":"Making the Material Property Struct","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"First up is the addition of a new material property struct and constructor. This is the same as the default one with the only change being the name (for dispatch reasons), and changing the Mᵣ and Rᵣ fields to Ṁ and Ṙ.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"note: Note\nThere is not actually any functional difference (for this use case, some of the fields have been removed so this struct wouldn't work with the normal meltUpdate function) between this and the built in MatProp type, other than the change of documentation. But by having a new type we can dispatch on it later on, to allow for our custom logic.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"struct MatPropTD{T1,T2,T3,T4,T5,T6,T7,T8,T9} <: Types.AbstractMatProp\n    ρ::T1\n    c::T2\n    κ::T3\n    \"\"\" Melting rate to temp and melt state relationship.\n    A 2d interpolation, with the first input axis being the temperature adn the\n    second the current melt state. The output is the melt rate.\n    \"\"\"\n    Ḟ::T4\n    \"\"\" Crystallisation rate to temp, melt state and maximum melt state relationship.\n    A 3d interpolation, with the first input axis being the node temperature,\n    the second the current melt state and the third the maximum melt state\n    reached. The output is the recrystalisation rate.\n    \"\"\"\n    Ṙ::T5\n    Hf::T6\n    Hr::T7\n    Ċ::T8\n    eₚ::Float64\n    eᵢ::Float64\n    ε::Float64\n    name::String\n    Mₘ::T9\nend","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"As well as copying the old type, we'll also copy its constructor, to give us a more convineient way of constructing it from our experimental data. Again, this is the same as before, just with a change of name.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"function MatPropTD(ρ, c, κ, Ṁ, Ṙ, Hf, Hr, Ċ, eₚ, eᵢ, ε, name, geometry)\n    geomSize = (geometry.X, geometry.Y, geometry.Z)\n    Mₘ = zeros(geomSize)\n\n    return MatPropTD{\n        typeof(ρ),typeof(c),typeof(κ),\n        typeof(Ṁ),typeof(Ṙ),typeof(Hf),typeof(Hr),\n        typeof(Ċ),typeof(Mₘ),\n    }(\n        ρ, c, κ,\n        Ṁ, Ṙ, Hf, Hr,\n        Ċ,\n        eₚ, eᵢ, ε,\n        name, Mₘ,\n    )\nend","category":"page"},{"location":"tutorials/3_material_tut/#Adding-The-New-Logic","page":"3 A Melt Rate Based Material Model","title":"Adding The New Logic","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"Now we have the new type, we can use it with julia's multiple dispatch to change what method is called when the simulation goes to update the melt state. This is done by making a new method for Material.meltUpdate that specifies our new type in place of the default MatProp type. Refer to my thesis if you would like an explanation as to what has changed here from the default method.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"function Material.meltUpdate(Mᵗ⁻¹, T, Mₘ, Δt, mp::MatPropTD)\n    ṀF = mp.Ḟ(T, Mᵗ⁻¹)\n    ṀR = mp.Ṙ(T, Mᵗ⁻¹, Mₘ)\n\n    if ṀF > -ṀR\n        ΔM = ṀF * Δt\n        ΔH = ΔM * mp.Hf\n    else\n        ΔM = ṀR * Δt\n        ΔH = ΔM * mp.Hr(Mₘ)\n    end\n    Mᵗ = min(max(Mᵗ⁻¹ + ΔM, 0), 1)\n    Mₘ = max(Mᵗ, Mₘ)\n\n    return Mᵗ, Mₘ, Δh\nend","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"If we needed more arguments to be passed in to this function, or wanted to change other properties of the material model, we could define a new method for Material.calcMatProps!. For an example of this, you can check out A Basic Material Model. Material.consUpdate is also dispatched on the material property struct, so that can also be modified sepreatly without having to rewrite the entire material model.","category":"page"},{"location":"tutorials/3_material_tut/#Making-a-New-Material","page":"3 A Melt Rate Based Material Model","title":"Making a New Material","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"We'll use PA2200 as our material, using most of the values from the default type. The only changes will be our two melt rate relationship fields. To fill in the values for these fields we'll use interpolated arrays, so first lets add the interpolations package:","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"using Interpolations","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"Then we can use this to create a 2D interpolation for Ṁ that does what we said we want it to do.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"note: Note\nThe data presented here is totally fictional and should be replaced with actual data.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"To do this you will need the values corrisponding to the inputs of the data, so for example if we recorded the melt rate at temperatures of 170°C, 180°C and 190°C then we could define","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"melt_temps = [170, 180, 190]","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"And if we made those measurements at melt states of 0 and 1","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"melt_state = [0, 1]","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"We can then define the outputs, what the value of the melt rates measured for each of those states, where the x-axis of the array is the temperature and the y-axis is the melt state. So for this example, we have a melt rate of 0.03 at M=0 at a temperature of 190°C.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"melt_rate = [\n    0 0.02 0.03\n    0 0.01 0.02\n]","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"Then we can use these to make the linear interpolation that will be used in the simulation. Where the first argument is a tuple of our inputs and the second is our outputs. The key word argument defines how the values should be extrapolated if an input is given outside of the range of the inputs we've provided. Check out the Interpolations.jl docs for more info on these.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"PA_Ṁ = linear_interpolation(\n    (melt_temps, melt_state),\n    melt_rate;\n    extrapolation_bc=Flat(),\n)","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"You can test out what this does by trying to index into it with values other than those given, it should return values linearly interpolated between the ones you gave.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"PA_Ṁ[175, 0.5]","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"Then we can do a similar thing for the recrystalisation rate. Although here we need an extra input, the maximum melt state that was reached before recrystalisation began.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"recryst_temps = [150, 180]\nmelt_state = [0, 1]\nmelt_max = [0, 1]","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"And because we have an extra input, the output needs to have an extra dimension. The triple semicolon is used to concatinate in the 3rd dimension. So the 2×2 array befor the triple semicolon is the melt rate for a melt max of 0 and the one after is for a melt max of 1.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"recryst_rate = [\n    0.1 0;\n    0.5 0\n    ;;;\n    0.2 0;\n    0.8 0\n]\n\nPA_Ṙ = linear_interpolation(\n    (recryst_temps, melt_state, melt_max),\n    recryst_rate;\n    extrapolation_bc=Flat(),\n)","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"And like before, we can gives this a go.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"PA_Ṙ[160, 0.2, 0.733]","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"And finally this can all go together to make our material, but like before we need to make a geometry to pass in to the material propetry constructor.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"geometry = Geometry(\n    (0.016, 0.016, 0.0122),\n    0.001,\n    1.5e-3;\n    Δz=0.003 / 90,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers\",\n)\n\nmaterial = MatPropTD(\n    Material.PA_ρ(),\n    Material.PA_c(),\n    Material.PA_κ(),\n    PA_TD_M,\n    PA_TD_R,\n    Material.PA_Hf(),\n    Material.PA_Hr(),\n    Material.PA_Ċ,\n    Material.PA_eₚ,\n    Material.PA_eᵢ,\n    Material.PA_ε,\n    \"Time dependent PA2200\",\n    geometry,\n)","category":"page"},{"location":"tutorials/3_material_tut/#The-Rest-of-the-Setup","page":"3 A Melt Rate Based Material Model","title":"The Rest of the Setup","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"From here on it's just the same as our other simulations.","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"params = HSSParams(geometry)\nloadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)\n\nsize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(size, 25.0, 0.0, 0.0, 0.0, 0)\ninitialLayer = 10\n\ninkArray = fill(material.eₚ, size)\ninkArray[5:end-4, 5:end-4, 60:end-10] .= material.eᵢ\nink = Ink(inkArray, \"Sample square\")\n\nfile = \"material_model_tutorial.jld2\"\ndescription = \"A simulation to test a time dependent melt model\"\n\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    preheatLoads=preheatLoads,\n    buildLoads=buildLoads,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    description=description,\n)\n\nresultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"","category":"page"},{"location":"tutorials/3_material_tut/","page":"3 A Melt Rate Based Material Model","title":"3 A Melt Rate Based Material Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/internals/#Internals","page":"Private Internals","title":"Internals","text":"","category":"section"},{"location":"reference/internals/","page":"Private Internals","title":"Private Internals","text":"Documentation for any things not exported from modules.","category":"page"},{"location":"reference/internals/#Boundary","page":"Private Internals","title":"Boundary","text":"","category":"section"},{"location":"reference/internals/","page":"Private Internals","title":"Private Internals","text":"Boundary.updateInds!\nBoundary.innerLoop!\nBoundary.boundaryTemp\nBoundary.σ","category":"page"},{"location":"reference/internals/#HSSSimulations.Boundary.updateInds!","page":"Private Internals","title":"HSSSimulations.Boundary.updateInds!","text":"updateInds!(\n    indStruct::HSSSimulations.Types.Indices,\n    recoatDist,\n    resSize,\n    ghost\n)\n\n\nUpdates an indices struct during a load step. Used to update the real and imaginary nodes during recoat of the powder layer based on the recoatDist (how far through the layer the powder has been deposited in number of nodes into the simulation area).\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Boundary.innerLoop!","page":"Private Internals","title":"HSSSimulations.Boundary.innerLoop!","text":"innerLoop!(Tᵗ⁻¹, T, params, ind, gdist, κ)\n\n\nThe inner loop of padWithGhost!. This exists for no reason other than as a function barrier to allow for the compiler to know the type of params for better dispatch.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Boundary.boundaryTemp","page":"Private Internals","title":"HSSSimulations.Boundary.boundaryTemp","text":"boundaryTemp(ϕ⃗, T, κ, gdist) -> Any\n\n\nCalculates a temperature for a ghost cell that will give the heat flux density (ϕ⃗, in wm⁻²) to a node with a temperature of T. gdist is the distance between the ghost and real node in meters, eg. for a z boundary it would be Δz.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Boundary.σ","page":"Private Internals","title":"HSSSimulations.Boundary.σ","text":"Stefan-Boltzmann constant\n\n\n\n\n\n","category":"constant"},{"location":"reference/internals/#Solver","page":"Private Internals","title":"Solver","text":"","category":"section"},{"location":"reference/internals/","page":"Private Internals","title":"Private Internals","text":"Solver.fdmSolver!\nSolver.timeSolver!\nSolver.nanfiller!\nSolver.loadSolver!\nTypes.makeDescription\nSolver.startMetadata\nSolver.finishMetadata","category":"page"},{"location":"reference/internals/#HSSSimulations.Solver.fdmSolver!","page":"Private Internals","title":"HSSSimulations.Solver.fdmSolver!","text":"fdmSolver!(cts, indᵣ, p)\n\n\nUses the explicit time step finite difference heat form of the heat equation to calculate the new results using ghost cell boundary conditions.\n\nIn simple terms this takes the avarage for all nodes for the one around the one being calculated (from the previous time step), and uses the difference between that and the temperature of the current node (for the previous time step) multiplied by the fourier number Fo to calculate the temperature of that node for the current timestep. This is done for all nodes. As ghost nodes are used, this function is the same for all nodes and doesn't need special logic for boundary nodes.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Solver.timeSolver!","page":"Private Internals","title":"HSSSimulations.Solver.timeSolver!","text":"timeSolver!(\n    cts::AbstractResult,\n    pts::AbstractResult,\n    ls::HSSSimulations.Types.LoadStep,\n    prob::Problem\n)\n\n\nSolves a timestep by calculating new material propeties, setting ghost node boundary conditions, using an explicit finited difference method and then conditionally recoating the poweder (if the load specifies). The results are stored in the Results struct cr that is passed into the function.\n\nArguments\n\ncts : The struct that will be used to store the results from this solver.\npts : The results struct with the results from the previous step.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Solver.nanfiller!","page":"Private Internals","title":"HSSSimulations.Solver.nanfiller!","text":"nanfiller!(cts, indᵢ)\n\n\nFills non real cells with NaNs instead of the undef value there currently. Using NaN instead of zero both allows for a check to see if the cell has been initialised and makes them not show up in plots.\n\nThis needs to be called on all loads (not just recoat loads) as on the loads before recoat there are still imaginary nodes that need filling (for pretty plotting).\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Solver.loadSolver!","page":"Private Internals","title":"HSSSimulations.Solver.loadSolver!","text":"loadSolver!(\n    ls::HSSSimulations.Types.LoadStep,\n    results,\n    prob::Problem\n) -> AbstractResult\n\n\nSolves a single load and returns an array of the results.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Types.makeDescription","page":"Private Internals","title":"HSSSimulations.Types.makeDescription","text":"makeDescription(problem::Problem) -> Any\n\n\nPrimaraly used for the show method for the Problem struct, but seperated into it's own function so the same formatting can be used for making a string to save to the results file. This is useful for having a summary of the simulation setup attached to the results for quick reference (The full problem struct is also saved, but that requires loading the results in a julia instance to read properly).\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Solver.startMetadata","page":"Private Internals","title":"HSSSimulations.Solver.startMetadata","text":"startMetadata(problem, file)\n\n\nAdds metadata to the results file. The data added here is stuff that is available at the start of the simulation, such as the problem description, the problem input and the start time.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#HSSSimulations.Solver.finishMetadata","page":"Private Internals","title":"HSSSimulations.Solver.finishMetadata","text":"finishMetadata(problem::Problem, file)\n\n\nAdds metadata to the results file. The data added here is stuff that is not available until the end of the simulation, such as the melt max array, the results index array and the simulation end time.\n\n\n\n\n\n","category":"function"},{"location":"explanation/faqs/#FAQs","page":"FAQs","title":"FAQs","text":"","category":"section"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"Well, no-one has actually asked me questions, but I imagine this is what people might ask.","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"tip: Tip\nFor more in-depth explanations on anything, or for anything not covered here, you might be able to find more detailed answers in my thesis. Worst case, try emailing me.","category":"page"},{"location":"explanation/faqs/#Why-We-Skip-Some-Results","page":"FAQs","title":"Why We Skip Some Results","text":"","category":"section"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"The underlying solver used is an explicit time finite difference solver. This is used as it is very cheap per time step solved (and things like the complex boundaries and the material model work best with lots of time steps), however it does have the issue of requiring lots of time steps to be stable.","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"While the quantity and computational cost sort of balance out to make it take a reasonable time to solve, there is an issue that is caused by the solver choice. As there are lots of time steps, this means there are lots of results, and trying to find space for all of these is challenging.","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"To prevent the results files from filling up all your hard drive or from crashing the simulation due to a lack of available memory, a skip parameter was introduced. This parameter defines how often we want to save the results, with a value of 1 not skipping any results, 2 only saving every second result, 3 saving every third result and so on, the rest are thrown away as soon as they are done with (after the following load).","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"It might seem a little strange to throw away results from a simulation, but as long as you don't make the skip too big you will see that very little useful information is lost.","category":"page"},{"location":"explanation/faqs/#Why-Use-Explicit-Time-Finite-Difference-Method","page":"FAQs","title":"Why Use Explicit Time Finite Difference Method","text":"","category":"section"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"Yeah I know, it's not the flashiest technique ever, and originally I only used it to make a quick proof of concept as it is so easy to implement (of this entire codebase, only about 6 lines of it are the actual FDM solver).","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"However, the more I tried to move away from it the more I realised it might actually be the best method to use.","category":"page"},{"location":"explanation/HSSBoundary/#High-Speed-Sintering-Boundary-Explanation","page":"HSS Boundary","title":"High Speed Sintering Boundary Explanation","text":"","category":"section"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"Here we will cover the details on exactly what it is that the example boundary is replicating. We will cover this one boundary at a time. As the simulation is a cuboid, it has six external surfaces, each of which must have defined boundary conditions.","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"The simulation is to be compared to an array of identical, symmetrical parts being printed. Assuming that this array is infinite results in a symmetrical boundary condition. This means that the four conditions representing the side walls (x₁, x₂, y₁ and y₂ in the notation used in Types.Load), can all use the default boundary condition provided by Boundary.SymetryBoundary.","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"The bottom boundary (z₁) is where the build bed is in contact with the piston. As the piston is one of the few consistent things on our machine, this can be simulated as a constant temperature boundary with a contact conduction coefficient. This is done using HSSBound.PistonBoundary.","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"The final boundary, the top surface of the powder (z₂) is by far the most complicated. It changes constantly throughout the build as new layers are added and sintered.","category":"page"},{"location":"explanation/HSSBoundary/#Overhead-Heaters","page":"HSS Boundary","title":"Overhead Heaters","text":"","category":"section"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"In the default state with nothing happening the top boundary has heat loss due to convection to the forced air draft over the surface and loss from radiation to the surrounding surfaces. In addition, there is a stationary overhead heater. During preheating (when the LoadSet = PreheatLoadSet) the overhead heater is set to a fixed power (Simulated using HSSBound.loadOverheads).","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"Once the build starts, the overhead power is adjusted, starting at a set amount (usually around 60% (of a 300W heater)) and changing by a set amount (usually 1 percentile point) every set number of layers (usually every 3 layers) with the goal of reaching the target temperature of the top surface (Simulated using HSSBound.loadOverheads). Once the build is finished (when the LoadSet = CooldownLoadSet) the overhead is turned off (set to 0W power) and left to cool down (Simulated using HSSBound.loadCooldown).","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"The overhead heater boundary is implemented as a radiation boundary condition, because of this the overhead temperature is needed (not the power, which is all we defined above). For this, the HSSBound.overheadTempFunc is used to calculate the change in temperature.","category":"page"},{"location":"explanation/HSSBoundary/#Carriages","page":"HSS Boundary","title":"Carriages","text":"","category":"section"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"Most of this change comes from the movement of two carriages, the lamp carriage and the print carriage. The first contains both the powder hopper (for recoating) and the sinter lamp. The second contains the print heads used to deposit the absorptive ink.","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"During each layer the following happens (described as if looking from the front of the machine, with the x-axis going front to back, and slightly confusingly the y-axis going right to left (don't ask, I regret this choice)):","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"The lamp carriage moves from left to right with the lamp set at sinter power\nThe lamp carriage moves from right to left with the lamp set to recoat power and the powder hopper deposits a layer of powder\nThe print carriage moves from right to left whilst doing nothing special\nThe print carriage moves from left to right as the print heads deposit the ink","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"In between each of the above steps are brief moments of simplicity, where the only boundary conditions are those covered in previous sections. These gaps use the aforementioned HSSBound.loadOverheads. The carriage boundaries are only actually used when the carriages are over the build bed, it is assumed that if they are moving but not over the bed then they have no impact on the boundary conditions so the HSSBound.loadOverheads can be used instead.","category":"page"},{"location":"explanation/HSSBoundary/","page":"HSS Boundary","title":"HSS Boundary","text":"It is also worth noting, that when a carriage is in over the top of the build bed, the build bed is shadowed from the overheads.","category":"page"},{"location":"reference/api/#API","page":"Main API","title":"API","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"DocTestSetup = quote\n    using HSSSimulations\nend","category":"page"},{"location":"reference/api/#Solver","page":"Main API","title":"Solver","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"problemSolver\nProblem(; kwargs...)","category":"page"},{"location":"reference/api/#HSSSimulations.Solver.problemSolver","page":"Main API","title":"HSSSimulations.Solver.problemSolver","text":"problemSolver(problem::Problem) -> Tuple{Any, Any}\n\n\nThe main function that is called to solve a simulation and the struct that defines the problem to simulate.\n\nTakes a fully defined problem and solves it, saving the solution to disk and returning the filename where it is saved. See Problem for how to define the problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#HSSSimulations.Types.Problem-Tuple{}","page":"Main API","title":"HSSSimulations.Types.Problem","text":"Problem(\n;\n    geometry,\n    matProp,\n    params,\n    loadSets,\n    init,\n    file,\n    initLay,\n    ink,\n    description,\n    otherResults,\n    options\n)\n\n\nAssemble a problem out of its components.\n\nArguments\n\n`geometry::Geometry`: [`Geometry`](@ref)\n`matProp::AbstractMatProp`: [`AbstractMatProp`](@ref)\n`params::AbstractProblemParams`: [`AbstractProblemParams`](@ref)\n`loadSets::Vector{AbstractLoadSet}`: [`AbstractLoadSet`](@ref)\n`ink::Ink`: [`Ink`](@ref)\n`init::AbstractResult`: [`AbstractResult`](@ref)\n`otherResults::AbstractOtherResults=OtherResults()`: [`AbstractOtherResults`](@ref)\n`initLay::Int`: The thickness of powder to use for preheat loads, given in number of layers thick\n`file::String`: File name\n`description::String=\"\"`: A short description of what is being simulated\n`options::Options=Options()`: Simulation options\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Simulation-Geometry","page":"Main API","title":"Simulation Geometry","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Geometry(::Any,::Any,::Any)","category":"page"},{"location":"reference/api/#HSSSimulations.Types.Geometry-Tuple{Any, Any, Any}","page":"Main API","title":"HSSSimulations.Types.Geometry","text":"Geometry(\nsimSize, Δx, Δt;\nΔy=Δx, Δz=Δx, name=\"NA\", Δh=0,\noffset=(0.0, 0.0), buildSize=nothing,\nforce=false,\n\n)\n\nConstructor for the Geometry type that is is used to store all of the geometry information (and time step length for some reason) for a rectangular build volume of the machine being simulated (given as the buildSize). It also saves the information for the subset of the build volume to actually be simulated (of size simSize, offset form the machine origin by offset), if the full build volume is not being simulated. If no buildSize is given then it is assumed to be just big enougth to fit the simSize with the given offset.\n\nΔh is the layer height in meters. If it is given as 0 (or not given) then it is assumed that the simulation isn't representing a full build, but instead something like the preheat or cooldown phase. In this case no layer recoat logic can be run (make sure not to include a recoating Types.Load).\n\nΔt is the time step (in seconds) and Δx, Δy and Δz are the node spacing (in meters). If not given then Δy and Δz default to the same as Δx. The timestep is included in the geometry as it is tied to the node spacing when it comes to making a stable simulation for the explicit finite difference method used in this model.\n\nIf the force argement is given then the divisible errors will be suppressed, this will result in the geometry not being properly represented.\n\ndanger: Use With Caution\nUse the force argument with great caution. It was only added to allow for the creation of geometries that were blocked due to floating point math errors. If it is used when things aren't actually divisible then it will result in the geometry not being properly represented, and a disconnect between what you think you are simulating and what is actually being simulated.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Ink","page":"Main API","title":"Ink","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Ink","category":"page"},{"location":"reference/api/#HSSSimulations.Types.Ink","page":"Main API","title":"HSSSimulations.Types.Ink","text":"struct Ink{T}\n\nDefines the volume of the ink placement within that (and therefore hopefully the part to be made).\n\nFields\n\nnodes::Array{T, 3} where T: The emmisivity of the models nodes, set to eₚ for nodes without ink.\nname::String: Just used for future reference of results\n\nThis is the emmisivity relative to the lamp. So the emmisivity of the ink over the range of the wavelengths that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Materials","page":"Main API","title":"Materials","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"PA2200","category":"page"},{"location":"reference/api/#HSSSimulations.Material.PA2200","page":"Main API","title":"HSSSimulations.Material.PA2200","text":"PA2200(\n    geometry::Geometry\n) -> MatProp{Interpolations.Extrapolation{Float64, 2, Interpolations.ScaledInterpolation{Float64, 2, Interpolations.BSplineInterpolation{Float64, 2, Matrix{Float64}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{UnitRange{Int64}, UnitRange{Int64}}}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Flat{Nothing}}, _A, _B, _C, _D, _E, _F, typeof(PA_Ċ), Array{Float64, 3}} where {_A, _B, _C, _D, _E, _F}\n\n\nAn example material based on PA2200, using a rate of consolidation based on melt state. With eyeball correction to consolidation rate.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Results","page":"Main API","title":"Results","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Result\nResult(::Any,::Any,::Any,::Any,::Any,::Any)\nResult(::Any,::Any,::Any,::Any,::Any)\nResult(::Any,::Any)\nResult(::Any,::Any,::Any)","category":"page"},{"location":"reference/api/#HSSSimulations.Res.Result","page":"Main API","title":"HSSSimulations.Res.Result","text":"struct Result{P<:AbstractArray} <: AbstractResult\n\nThe results from a single timestep, use directly to create the initial conditions. Also created for each time step during the simulation.\n\nFields\n\nT::AbstractArray: Temperature\nM::AbstractArray: Melt state\nC::AbstractArray: Consolidation state\nt::Float64: Time of timestep\ntₚ::Float64: The progress through the load step (0=start, 1=end)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.Res.Result-NTuple{6, Any}","page":"Main API","title":"HSSSimulations.Res.Result","text":"Result(geomSize, Tᵢ, Mᵢ, Cᵢ, t, tₚ) -> Result\n\n\nCreate a result with uniform fields\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#HSSSimulations.Res.Result-NTuple{5, Any}","page":"Main API","title":"HSSSimulations.Res.Result","text":"Result(T, M, C, t, tₚ) -> Result\n\n\nRe-expose the default constructor\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#HSSSimulations.Res.Result-Tuple{Any, Any}","page":"Main API","title":"HSSSimulations.Res.Result","text":"Result(geomSize, t) -> Result\n\n\nCreate a result filled with zeros\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#HSSSimulations.Res.Result-Tuple{Any, Any, Any}","page":"Main API","title":"HSSSimulations.Res.Result","text":"Result(geomSize, t, tₚ) -> Result\n\n\nCreate an empty result\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Boundaries","page":"Main API","title":"Boundaries","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"basicLoad\nBasicProblemParams","category":"page"},{"location":"reference/api/#HSSSimulations.Boundary.basicLoad","page":"Main API","title":"HSSSimulations.Boundary.basicLoad","text":"basicLoad(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nA basic Types.Load with a conduction boundary on the bottom surface and a convection boundary on the top. All other surfaces are symetrical boundaries.\n\nExamples\n\njulia> loadStep = basicLoad(5, 2)\n  x₁ : SymetryBoundary\n  x₂ : SymetryBoundary\n  y₁ : SymetryBoundary\n  y₂ : SymetryBoundary\n  z₁ : ConductionBoundary\n  z₂ : ConvectionBoundary\n  name : NA\n  tₗ : 5.0\n  skip : 2\n\nThis returns a single Load, for a single load step. To make a load set you will need an array of Loads.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#HSSSimulations.Boundary.BasicProblemParams","page":"Main API","title":"HSSSimulations.Boundary.BasicProblemParams","text":"A basic implementation of a Types.AbstractProblemParams struct to go along with basicLoad. For a more elaborate example see HSSParams\n\nFields\n\ncondCoef::Float64: The contact conduction coefficent for the bottom face\ncondTemp::Any: The temperature of the surface in contact with the bottom face\nconvCoef::Float64: The convection coefficent for the top face to the air above\nconvTemp::Any: The temperature of the air in contact with the top face\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Settings","page":"Main API","title":"Settings","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Options\npackage_groups","category":"page"},{"location":"reference/api/#HSSSimulations.Types.Options","page":"Main API","title":"HSSSimulations.Types.Options","text":"struct Options\n\nFields\n\ncompress::Union{Bool, TranscodingStreams.Codec}: How to compress the results file, can be set to true (to compress),    false (to leave uncompressed) or to a specific compression algorithm (see the JLD2    documentation for more details)\ndebug::Union{Bool, Vector{String}}: Whether or not to log debug information, can accept a list of strings to select only some    debugging groups, see package_groups\nshowProgress::Union{Bool, Float64}: Whether or not to show the progres meter, if a number is given that is used as the    update interval\nnotify::Bool: If true, simulations finishing will send a system notification using Alert.jl\n\nThe debug option is passed to the logGroups option of Solver.makeLogger, check that out for more information and package_groups for what log groups are available by default.\n\nnote: Note\nDepending on settings, the debug option might log a lot of things, the log file could end up somewhere in the region of 4x the size of the compressed results file, so make sure you clean them up after you're done.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.Types.package_groups","page":"Main API","title":"HSSSimulations.Types.package_groups","text":"A list of all of the log groups used in this package. They log the following things:\n\n\"core\": the start of a problem, loadstep, load or timestep has started\n\"solver\": the fdm solver\n\"mat\": material model\n\"bound\": boundary condition\n\"b_adv\": recoating and moving object boundaries\n\"hss\": HSS example functions\n\n\n\n\n\n","category":"constant"},{"location":"reference/api/#Results-File-Structure","page":"Main API","title":"Results File Structure","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"The last part of the API to cover is the format of the simulation results that are saved. These use the JLD2 package to save to a Hierarchical Data Format version 5 (HDF5) based format. Most of the information stored should be readable by any HDF5 compatible software or libraries, except the input problem, which requires the software to understand julia types (the easiest way is to just use juila, it's mostly saved in case it needs to be rerun).","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"By default, this is stored compressed using the ZlibCompressor compressor.","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"The results have the following structure:","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Tree                           Description\nResults\n│\n├─ Description                 - An overview of the problem that has been solved\n├─ Input                       - The full problem struct that has been solved\n├─ Start_Time                  - The computer's clock time at the end of the simulation\n├── Results\n│   ├─ MeltMax                 - The maximum melt state reached in the simulation\n│   │\n│   ├── Preheat-1              - List of loads run during the preheating load set\n│   │   ├─ 1\n│   │   ├─ 2\n│   │   └─ ⋯ (3 more entries)\n│   │\n│   ├── Layer-2                - 1st Layer\n│   │   ├─ 1                   - 1st Layer's 1st Load\n│   │   ├─ 2                   - 1st Layer's 2nd Load\n│   │   └─ ⋯ (6 more entries)  - And so on for the remaining loads\n│   │\n│   ├── Layer-3                - 2nd Layer\n│   │   ├─ 1 (5 entries)\n│   │   ├─ 2\n│   │   └─ ⋯ (6 more entries)\n│   │\n│   ├─ ⋯ (25 more entries)     - And so on for the remaining layers\n│   │\n│   └── Cooldown-28            - List of loads run during the cooldown load set\n│       ├─ 1\n│       ├─ 2\n│       └─ ⋯ (3 more entries)\n│\n├─ Results_Index               - A list of all load results indices within this file\n├─ Finish_Time                 - The computer's clock time at the end of the simulation\n└─ _types                      - Ignore (Used internally by JLD2)","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Where each of the loads has these fields:","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Tree           Description\n\nLoad\n├─ name        - The load's name\n├─ time        - 1D array of the times of the load's time steps\n├─ T           - 4D array of temperatures (X, Y, Z, time step)\n├─ M           - 4D array of melt states (X, Y, Z, time step)\n└─ C           - 4D array of consolidation states (X, Y, Z, time step)","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"tip: Tip\nRes.loadStepSaver, Solver.otherResults, are the two functions used for saving simulation results to the file. so looking at their implementation might help with if anything is not covered here. Solver.startMetadata and Solver.finishMetadata are also used to save a few extra bits of metadata to the file. I'd also recommend a tool like HDFView to get an idea for the structure of the results.","category":"page"},{"location":"reference/internal_api/#Internal-APIs","page":"Internal APIs","title":"Internal APIs","text":"","category":"section"},{"location":"reference/internal_api/","page":"Internal APIs","title":"Internal APIs","text":"These are things exported from modules, but not intended for external use.","category":"page"},{"location":"reference/internal_api/","page":"Internal APIs","title":"Internal APIs","text":"DocTestSetup = quote\n    using HSSSimulations\nend","category":"page"},{"location":"reference/internal_api/#Types","page":"Internal APIs","title":"Types","text":"","category":"section"},{"location":"reference/internal_api/","page":"Internal APIs","title":"Internal APIs","text":"Types.AbstractSimProperty\nTypes.Problem\nTypes.LoadTime\nTypes.LoadTime(::Any,::Any,::Any,::Any)\nTypes.LoadStep\nTypes.Indices\nTypes.Geometry","category":"page"},{"location":"reference/internal_api/#HSSSimulations.Types.AbstractSimProperty","page":"Internal APIs","title":"HSSSimulations.Types.AbstractSimProperty","text":"abstract type AbstractSimProperty\n\nThis is the parent type of all of the simulation property types. It exists mostly to define a show method for all of it's subtype. This just makes things nicer to look at the.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal_api/#HSSSimulations.Types.Problem","page":"Internal APIs","title":"HSSSimulations.Types.Problem","text":"struct Problem{T<:AbstractArray, Gh<:AbstractArray, M<:AbstractMatProp, R<:AbstractResult, OR<:AbstractOtherResults, P<:AbstractProblemParams}\n\nAn internal struct used for passing the many variables around the different function, it is built from a given problem struct, using a constructor in the problem module. There is probably a better way of doing this, but it works.\n\nFields\n\ngeometry::Geometry: Simulation geometry. Geometry\nmatProp::AbstractMatProp: Simulation material properties. AbstractMatProp\nparams::AbstractProblemParams: Parameters used for boundary conditions. AbstractProblemParams\nloadSets::Vector{AbstractLoadSet}: List of all load sets to run. AbstractLoadSet\notherResults::AbstractOtherResults: Results struct used to save data only once at the end. AbstractOtherResults\ninit::AbstractResult: Initial results. AbstractResult\ninitLay::Int64: The thickness of powder to use for preheat loads, given in number of layers thick\nink::Ink: Matrix of final emissivities. Ink\neᵗ::AbstractArray: Matrix of current emissivities\nFx::AbstractArray: Matrix of x axis Fourier numbers\nFy::AbstractArray: Matrix of y axis Fourier numbers\nFz::AbstractArray: Matrix of z axis Fourier numbers\nκ::AbstractArray: Matrix of thermal conductivities\nTᵗ⁻¹::AbstractArray: Ghost node padded matrix of previous time step\nresultsIndex::Vector{String}: index of results file\nfile::String: File name\ndescription::String: A short description of what is being simulated. To help remember what the simulation results are about\noptions::Options: Simulation options\n\n\n\n\n\n","category":"type"},{"location":"reference/internal_api/#HSSSimulations.Types.LoadTime","page":"Internal APIs","title":"HSSSimulations.Types.LoadTime","text":"struct LoadTime\n\nContains all of the time information for a LoadStep.\n\nFields\n\nΔt::Float64: Time between time steps\ntimes::Vector{Float64}: Array of all of the times in the load step\nunskipTimes::Vector{Float64}: Array of all none skipped times in the load step\ntₚ::Vector{Float64}: Array of percentage through timestep, same index as times\nutₚ::Vector{Float64}: Array of percentage through timestep, same index as unskipTimes\ntₛ::Float64: The time at the start of the load step\ntₑ::Float64: Time step end time\n\n\n\n\n\n","category":"type"},{"location":"reference/internal_api/#HSSSimulations.Types.LoadTime-NTuple{4, Any}","page":"Internal APIs","title":"HSSSimulations.Types.LoadTime","text":"LoadTime(tₛ, tₗ, Δt, skip) -> HSSSimulations.Types.LoadTime\n\n\nDefault Constructor for LoadTime.\n\nArguments\n\ntₛ::Float64: The time at the start of the load step\ntₗ: The lenght of the load step\nΔt::Float64: Time between time steps\nskip: How often to save results. See Why We Skip Some Results\n\n\n\n\n\n","category":"method"},{"location":"reference/internal_api/#HSSSimulations.Types.LoadStep","page":"Internal APIs","title":"HSSSimulations.Types.LoadStep","text":"struct LoadStep{R<:AbstractResult}\n\nAn internal struct for the propeties that are constant within a load step.\n\nFields\n\ntime::HSSSimulations.Types.LoadTime: See LoadTime\nsize::Tuple{Int64, Int64, Int64}: The x, y and z size in number of nodes (mostly just used for the z,    which may have changed from the same value in the Problem.geometry variable)\nind::HSSSimulations.Types.Indices: See Indices\nload::Load: See Load\ninit::AbstractResult: The initial results for the load. See AbstractResult\nname::String: Used for the progress meter\nlayerNum::Int64: Used for any Load functions that need the layer number. For preheat    and cooldown load sets this will be the initial thickness or the finial thickness in layers    respectively.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal_api/#HSSSimulations.Types.Indices","page":"Internal APIs","title":"HSSSimulations.Types.Indices","text":"mutable struct Indices\n\nStores the indices of the nodes, taking into account if the node represents a volume that contains powder or not. And also stores the node pais for the boundaries.\n\niᵣ are indices of real nodes, this is all nodes that represent space where there is currently powder. This will normally include every node, however before and during the recoat load it will not include all of the top layer, as powder has not been deposited there yet. iᵢ are the indices of 'imaginary' nodes, these are nodes that represent locations that do not currently contain powder. These is the same as the indices of all of the nodes minus the indicies of the real nodes (iᵣ).\n\nFields with a subscript 1 (₁) denote the boundary at the start of that axis, and subscript 2 (₂) dentoes the end of that boundary. eg. x₂ is the boundary [end,:,:] and y₁ is [:,1,:]. z₂ is a special case where it always represents the top surface of the build, even if a layer has not been compleatly deposited yet. y₂ is another special case, where it represents its normal face, but also represents the leading edge of deposited powder.\n\nThe first element of the tuple in the boundary indices is the cartiesian index (of the array without the ghost cells) for the real node, the second is the linear index of the same point and the third element is the linear index (of the array with the ghost cells) of the matching ghost node.\n\nFields\n\niᵣ::Vector{CartesianIndex{3}}: List of currently real nodes\niᵢ::Vector{CartesianIndex{3}}: List of currently imaginary nodes\nx₁::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\nx₂::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\ny₁::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\ny₂::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}: List of real/ghost node pairs for `[:,end,:]\nz₁::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\nz₂::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}: List of real/ghost node pairs for `[:,:,end]\niₘ::CartesianIndex{3}: The middle point of z₂, and it is currently only used for debugging/logging.\nΔH::Int64: The same as it is in Geometry, it is just copied over for convenience.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal_api/#HSSSimulations.Types.Geometry","page":"Internal APIs","title":"HSSSimulations.Types.Geometry","text":"struct Geometry <: HSSSimulations.Types.AbstractSimProperty\n\nDefines the geometry of the build volume (and the simulation volume within that (if only a subset of a build is being simulated).\n\nFields\n\nx::Float64: The size of the x axis of the model in meters\ny::Float64: The size of the y axis of the model in meters\nz::Float64: The size of the z axis of the model in meters\nX::Int64: The size of the x axis of the model in nodes\nY::Int64: The size of the y axis of the model in nodes\nZ::Int64: The size of the z axis of the model in nodes\nsize::Tuple{Int64, Int64, Int64}: Tuple of the XYZ sizes\nxoffset::Float64: The x axis offset of the model from the machines datum in meters\nyoffset::Float64: The y axis offset of the model from the machines datum in meters\nX_OFFSET::Int64: The x axis offset of the model from the machines datum in nodes\nY_OFFSET::Int64: The y axis offset of the model from the machines datum in nodes\nxbuild::Float64: The total x axis size of the machine from which the subset is taken in meters\nybuild::Float64: The total y axis size of the machine from which the subset is taken in meters\nX_BUILD::Int64: The total x axis size of the machine from which the subset is taken in nodes\nY_BUILD::Int64: The total y axis size of the machine from which the subset is taken in nodes\nΔx::Float64: The spacing of the nodes in meters in the x axis\nΔy::Float64: The spacing of the nodes in meters in the y axis\nΔz::Float64: The spacing of the nodes in meters in the z axis\nΔt::Float64: The spacing of timesteps in seconds\nNₗ::Int64: The number of layers in the model\nΔh::Float64: The layer height in nodes\nΔH::Int64: The layer height in meters\nname::String: Just used for future reference of results\n\n\n\n\n\n","category":"type"},{"location":"reference/internal_api/#Boundary","page":"Internal APIs","title":"Boundary","text":"","category":"section"},{"location":"reference/internal_api/","page":"Internal APIs","title":"Internal APIs","text":"Boundary.calcInds\nBoundary.padWithGhost!","category":"page"},{"location":"reference/internal_api/#HSSSimulations.Boundary.calcInds","page":"Internal APIs","title":"HSSSimulations.Boundary.calcInds","text":"calcInds(\n    res,\n    ghost,\n    ΔH,\n    recoatLoadSet\n) -> HSSSimulations.Types.Indices\n\n\nCalculates the indices at the start of a load. For build load sets this includes 'imaginary' nodes that don't yet represent a volume with powder in it (but will after recoat). recoatLoadSet should be set to true if the current load set includes powder recoating, and false if it does not.\n\nSee Types.Indices for more details on the struct returned by this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/internal_api/#HSSSimulations.Boundary.padWithGhost!","page":"Internal APIs","title":"HSSSimulations.Boundary.padWithGhost!","text":"padWithGhost!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    ls,\n    prob\n)\n\n\nWraps the temperature array with ghost cells and updates the Tᵗ⁻¹ array in the Problem with the new value. The ghost cells are calculated based on a the boundaries for each face provided in the current load. See Types.Load for more details on these boundaries.\n\n\n\n\n\n","category":"function"},{"location":"#Modelling-of-HSS-(and-related-technologies)","page":"Home","title":"Modelling of HSS (and related technologies)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the package created as a part of my (Oliver Leete) PhD thesis. Its goal is as the title suggests, to create a simulation of a High Speed Sintering (HSS) build by approximating the build volume as a single solid object. This is done by having a complex material model to approximate the thermal behaviour of the powder and how it changes when the powder starts to become part of a part.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation will try its best to follow the Diátaxis Documentation Framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are new to the package and want a guide on how to get started running simulations, check out the tutorials section. These tutorials are also available as notebooks in the example folder of the repo.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you have a grip on the basics, you can check out the recipes section for how-to guides on making larger changes to the simulations. The top of the page should have links to the parts of the API that it's helpful to have familiarised yourself with. The examples on each page will typically build up in complexity, so if you are struggling to follow a later example, have a look at the previous ones to see if it helps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The API is available in the references section, it's split into three levels. The main API contains everything required for a normal simulation. The advanced API covers functions and types that can be useful for getting some more control over your simulations (like in the ways shown in some of the recipes). Post processing shows the included tools to help process the simulation output. And the internals cover the functions that are intended to be used purely internally, for if you want to have a crack at modifying the codebase itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, if you want to know more about what is being simulated, why you'd want to simulate it, and why some of the choices have been made, check out the explanations section (and my thesis). There should also be a brief overview of the structure of the code to help if you want to modify the code to do things that aren't possible with the API alone. Although, as always, documentation can fall behind code, so trust what the code says more than the docs.","category":"page"},{"location":"#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are reading this I have probably finished my PhD, so it is unlikely I will be making any major improvements to this codebase. However, I will try to keep an eye on the original repository (the one on my personal GitHub account), so if you add any cool new features feel free to open a pull request there.","category":"page"}]
}
