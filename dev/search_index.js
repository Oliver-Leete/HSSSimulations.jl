var documenterSearchIndex = {"docs":
[{"location":"howtos/howto_matprop/#Material-Model-Recipes","page":"Material Model Recipes","title":"Material Model Recipes","text":"","category":"section"},{"location":"howtos/howto_matprop/#A-Basic-Material-Model","page":"Material Model Recipes","title":"A Basic Material Model","text":"","category":"section"},{"location":"howtos/howto_matprop/","page":"Material Model Recipes","title":"Material Model Recipes","text":"This material model just acts like a normal temperature dependent solid. Useful for comparing against to see the impact of your model. As it does not save the melt or consolidation state it can be combined with Basic Results to save on storage space.","category":"page"},{"location":"howtos/howto_matprop/","page":"Material Model Recipes","title":"Material Model Recipes","text":"\"\"\"\nA basic material model that doesn't include any melting or consolidation.\n\n# Fields\n\n  - `ρ, c, κ`: Density, Specific heat capacity and Thermal conductivity\n  - `eₚ`: Emmisivity of the powder\n    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths\n    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n  - `eₚ`: Emmisivity of the powder with ink on it\n    This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths\n    that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n  - `Mₘ`: Used by the material model to track the maximum melt state reached per node.\n\"\"\"\nstruct BasicMatProp{T1,T2,T3} <: Material.AbstractMatProp\n    ρ::T1\n    c::T2\n    κ::T3\n    eₚ::Float64\n    eᵢ::Float64\n    name::String\n    Mₘ::Array{Float64,3}\nend","category":"page"},{"location":"howtos/howto_matprop/","page":"Material Model Recipes","title":"Material Model Recipes","text":"function Material.calcMatProps!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T,Gh,Mp,R,OR,B},\n    ind,\n) where {T<:Any,Gh<:Any,Mp<:BasicMatProp,OR<:Any,R<:Any,B<:Any}\n    mp = prob.matProp\n    (; Δx, Δy, Δz, Δt) = prob.geometry\n\n    Threads.@threads for i in ind\n        ρ = mp.ρ(0, 0)\n        prob.κ[i] = mp.κ(0, pts.T[i], 0)\n        c = mp.c(pts.T[i])\n\n        α = prob.κ[i] / (ρ * c)\n        prob.Fx[i] = α * (Δt / (Δx^2))\n        prob.Fy[i] = α * (Δt / (Δy^2))\n        prob.Fz[i] = α * (Δt / (Δz^2))\n    end\n    @debug \"material properties\" _group = \"mat\" prob.Fx[ind[end]] prob.Fy[ind[end]] prob.Fz[ind[end]] prob.κ[ind[end]]\n    return\nend","category":"page"},{"location":"howtos/howto_problem/#Problem-Solver-Recipes","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"","category":"section"},{"location":"howtos/howto_problem/#A-Problem-Solver-That-Waits-For-a-Bed-Temperature-Before-Starting-the-Build","page":"Problem Solver Recipes","title":"A Problem Solver That Waits For a Bed Temperature Before Starting the Build","text":"","category":"section"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"For when the default problem solver isn't enough it is always possible to make your own.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"For this example we will make a problem solver that stops the machine's preheat when a certain top surface temperature has been reached, instead of waiting a set amount of time. As loads are defined as being a fixed time length this can't be done with the standard logic.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"The new problem solver function:","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"\nwhile targetLower < mean(prevResult.T[:, :, end]) < targetUpper\n    prevResult = loadSetSolver!(LayerPreheatLoadSet(problem.preheatLoads, start), prevResult, prob)\nend","category":"page"},{"location":"howtos/howto_problem/#A-Problem-Solver-That-Waits-For-a-Bed-Temperature-Before-Starting-Each-Layer","page":"Problem Solver Recipes","title":"A Problem Solver That Waits For a Bed Temperature Before Starting Each Layer","text":"","category":"section"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"To emulate the behaviour of a machine waiting after each layer until the bed temperature has stabilised.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"This function moves the wait for temperature logic into the layer loop, to allow for simulations of machines that follow do this. To do this a new Types.AbstractLoadSet needs to be defined (see Load Set Types on how WaitLoadSet was made). As there is no default field in the problem struct to store wait loads, here we are instead passing them straight into our problem solver function as the waitLoads parameter.","category":"page"},{"location":"howtos/howto_problem/","page":"Problem Solver Recipes","title":"Problem Solver Recipes","text":"function layerTempWaitProblemSolver(problem::Problem, targetLower, targetUpper, waitLoads)\n    for i in start:finish\n        while targetLower < mean(prevResult.T[:, :, end]) < targetUpper\n            prevResult = loadSetSolver!(WaitLoadSet(waitLoads, i), prevResult, G)\n        end\n        prevResult = loadSetSolver!(BuildLoadSet(problem.buildLoads, i), prevResult, G)\n    end\nend","category":"page"},{"location":"howtos/howto_result/#Result-Type-Recipes","page":"Result Type Recipes","title":"Result Type Recipes","text":"","category":"section"},{"location":"howtos/howto_result/#Basic-Results","page":"Result Type Recipes","title":"Basic Results","text":"","category":"section"},{"location":"howtos/howto_result/","page":"Result Type Recipes","title":"Result Type Recipes","text":"A basic result type that only stores the temperature, can be used with A Basic Material Model.","category":"page"},{"location":"howtos/howto_result/","page":"Result Type Recipes","title":"Result Type Recipes","text":"warning: Warning\nAs this struct is what stores the data during the simulation, if this is used with the normal material model you will get an error, as it needs the M and C fields that we have removed.","category":"page"},{"location":"howtos/howto_result/","page":"Result Type Recipes","title":"Result Type Recipes","text":"As well as defining the type, it helps to have a few convenient constructors, some of these will be needed for the type to function in the simulation. It also needs an implementation of Results.loadStepSaver.","category":"page"},{"location":"howtos/howto_result/","page":"Result Type Recipes","title":"Result Type Recipes","text":"struct BasicResult{P<:AbstractArray} <: AbstractResult\n    \"Temperature\"\n    T::P\n    \"Time of timestep\"\n    t::Float64\n    \"The progress through the load step (0=start, 1=end)\"\n    tₚ::Float64\nend\n\n\"\"\"\nCreate an empty result\n\"\"\"\nfunction BasicResult(geomSize, t, tₚ)\n    T = Array{Float64}(undef, geomSize...)\n    return BasicResult{typeof(T)}(T, t, tₚ)\nend\n\n\"\"\"\nCreate a result with uniform fields\n\"\"\"\nfunction BasicResult(geomSize, Tᵢ, t, tₚ)\n    T = fill(Tᵢ, geomSize)\n    return BasicResult{typeof(T)}(T, t, tₚ)\nend\n\n\"\"\"\nFunction to save the results for each load step\n\"\"\"\nfunction Results.loadStepSaver(\n    loadResultsFolder,\n    loadResults::StructVector{T},\n) where {T<:BasicResult}\n    loadResultsFolder[\"time\"] = loadResults.t\n    loadResultsFolder[\"T\"] = stack(loadResults.T)\n    return\nend","category":"page"},{"location":"howtos/howto_mat/#Material-Recipes","page":"Material Recipes","title":"Material Recipes","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"EditURL = \"../../lit/res_tut.jl\"","category":"page"},{"location":"tutorials/4_res_tut/#Tutorial-4:-Saving-More-Results","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"using HSSSimulations\nusing .Types\nusing .Results\nusing .HSSBound","category":"page"},{"location":"tutorials/4_res_tut/#Overview","page":"Tutorial 4: Saving More Results","title":"Overview","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"This tutorial will go over both of the ways to save data from the simulation. One method saves results for every time step (well, the ones that the results aren't skipped for) of the simulation. The other, simpler, method saves some results at the end of the simulation.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"For this tutorial we will save some of the information about the overhead heaters. The temperature of the heaters will be saved at every time step. And a list of layers where the power was updated will be saved (along) with every layer that they're saved for.","category":"page"},{"location":"tutorials/4_res_tut/#Setting-Up-the-Time-Step-Results","page":"Tutorial 4: Saving More Results","title":"Setting Up the Time Step Results","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"To store results for each time step we will need to make a new AbstractResult type. This is very similar to the built in Result type, with the addition of the O field, where we'll store the overhead heater temperature. This has to be an array of some kind instead of just a float64 to allow for the value to be mutable (so we can update it once it has been calculated).","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"struct OverheadResult{P<:AbstractArray,V<:AbstractArray} <: AbstractResult\n    \"Temperature\"\n    T::P\n    \"Melt state\"\n    M::P\n    \"Consolidation state\"\n    C::P\n    \"Overhead Heater Temperature\"\n    O::V\n    \"Time of timestep\"\n    t::Float64\n    \"The progress through the load step (0=start, 1=end)\"\n    tₚ::Float64\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"warning: Warning\nAs this struct is what stores the data during the simulation, all subtypes MUST have the T, t and tₚ fields, and if you want to use it with the default material model it will also need the M and C fields.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"In addition, we'll also need some constructors for our new type, one empty one that is used in the simulation code:","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"function OverheadResult(geomSize, t, tₚ)\n    T = Array{Float64}(undef, geomSize...)\n    M = Array{Float64}(undef, geomSize...)\n    C = Array{Float64}(undef, geomSize...)\n    O = Vector{Float64}(undef, 1)\n    return OverheadResult{typeof(T),typeof(O)}(T, M, C, O, t, tₚ)\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"And one to create one filled with given values, that we'll use to create our initial conditions result:","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"function OverheadResult(geomSize, Tᵢ, Mᵢ, Cᵢ)\n    T = fill(Tᵢ, geomSize)\n    M = fill(Mᵢ, geomSize)\n    C = fill(Cᵢ, geomSize)\n    O = Vector{Float64}(undef, 1)\n    return OverheadResult{typeof(T),typeof(O)}(T, M, C, O, 0.0, 0.0)\nend","category":"page"},{"location":"tutorials/4_res_tut/#Recording-the-Time-Step-Results","page":"Tutorial 4: Saving More Results","title":"Recording the Time Step Results","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"We have the new types ready to store the data, so now we can update some functions to actually fill them with data. The function we care about is the one that finds the new temperature for the overhead heaters, which conveniently is just one of the arguments to HSSParams. So we can just make a function that we'll pass in when calling HSSParams. This is basically just the default function, but with the added step cts.O[1] = oveheadTemp to save our result.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"function overheadHeatupFunc(powerIn::Float64, prevOverheadTemp::Float64, cts)\n    overheadTemp = HSSBound.overheadTempFunc(\n        powerIn,\n        x -> (0.596x - 12.2),\n        118.923,\n        geometry.Δt,\n        prevOverheadTemp,\n    )\n    cts.O[1] = overheadTemp\n    return overheadTemp\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"As well as recording the results, we also need to save them. This is done with the Results.loadStepSaver function. We can create a method for this function that uses our OverheadResult type. Although it can't be dispatched on directly, instead we dispatch on a type from the StructArrays package, with our type as its type parameter. This is handily rexported by the Results module, so we can use it from there.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"The Results.loadStepSaver function is given a folder of the output file that we can then save the contents of loadResults to. loadResults is acts as a struct who's fields are vectors of the fields of our OverheadResult struct. But we can use stack to turn the vectors of arrays into higher dimension arrays before saving them. This will make them the right format to work with the built in post processing functions.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"function Results.loadStepSaver(\n    loadResultsFolder,\n    loadResults::Results.StructVector{T},\n) where {T<:OverheadResult}\n    loadResultsFolder[\"time\"] = loadResults.t\n    loadResultsFolder[\"T\"] = stack(loadResults.T)\n    loadResultsFolder[\"M\"] = stack(loadResults.M)\n    loadResultsFolder[\"C\"] = stack(loadResults.C)\n    loadResultsFolder[\"O\"] = stack(loadResults.O)\n    return\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"Before this function is called, the name of the load has already been saved to the name field, so we don't have to worry about that here (just don't try and save something else to the name field here, it will error).","category":"page"},{"location":"tutorials/4_res_tut/#Saving-Results-at-the-End","page":"Tutorial 4: Saving More Results","title":"Saving Results at the End","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"Compared to saving results for every time step, saving results at the end is much easier. The downside is that we can only save things that we have access to at the end. And the only things we have access to at the end are the contents of Problem. Luckely, there is a placeholder field in Problem called otherResults. To use this we can make an AbstractOtherResults that stores whatever data we want. For this we'll make one that stores some information about the overhead heater controller.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"We'll store a list of layers that caused the overhead heater to update, along with the time of the update and the new power.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"struct OverheadContRes <: AbstractOtherResults\n    layerChanged::Vector{Int}\n    timeChanged::Vector{Float64}\n    newPower::Vector{Float64}\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"To save this data we will use the HSSBound module and make a new version of the constructor for HSSBound.OverheadsBoundary that dispatches on our new type. This is just the same as the default method, but with three push! statements added.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"function HSSBound.OverheadsBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T,Gh,Mp,R,OR,B},\n    ls::Types.LoadStep,\n) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:OverheadContRes,B<:Any}\n    param = prob.params","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"Overhead update logic","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"    if ls.layerNum - param.overheadLayerStep >= param.lastUpdatedOverhead\n        param.lastUpdatedOverhead = ls.layerNum\n        surfaceCurrent = pts.T[ls.ind.z₂[1][1]]\n        if surfaceCurrent > (param.surfaceTarget + param.surfaceTol)\n            overheadPower = param.overheadPower - param.overheadPowerStep\n        elseif surfaceCurrent < (param.surfaceTarget - param.surfaceTol)\n            overheadPower = param.overheadPower + param.overheadPowerStep\n        else\n            overheadPower = param.overheadPower\n        end\n        param.overheadPower = clamp(overheadPower, 0, param.overheadMaxPower)\n\n        push!(prob.otherResults.layerChanged, ls.layerNum)\n        push!(prob.otherResults.timeChanged, cts.t)\n        push!(prob.otherResults.newPower, param.overheadPower)\n\n        @debug \"Overhead Power updated\" _group = \"hss\" surfaceCurrent overheadPower\n    end\n    overheadTemp = param.overheadHeatupFunc(param.overheadPower, param.overheadTemp, cts)\n    param.overheadTemp = overheadTemp\n\n    airTemp = param.airHeat(cts.t)\n    surfaceTemp = param.surfaceHeat(cts.t)\n    ε = prob.matProp.ε\n    h = param.convectionCoef\n    Po = param.percentOverhead\n\n    @debug \"OverheadsBoundary\" _group = \"hss\" cts.tₚ overheadTemp surfaceTemp airTemp\n    return OverheadsBoundary(overheadTemp, surfaceTemp, ε, airTemp, h, Po)\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"Also, the other contents of a few of Problem's fields can be customised by us, the matProp field contains the AbstractMatProp struct for the simulation, and the params field contains the simulation's AbstractProblemParams struct. So if we were making a new material model then we could use it's struct to store something and then save it all at the end, or the same for boundary conditions with the parameters struct.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"In addition to our otherResults struct, we will also save a couple of things that are already available from the default structs. The maximum melt state is from the MatProp struct (and is normally saved by this function anyway), and coolStart is from the HSSParams struct (and is not normally saved).","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"We'll make a method for otherResults that dispatches on our OverheadContRes struct. This method saves MeltMax and CoolStart to the top level results folder of the output file, and all of our overhead controller stuff to its own subfolder of the results.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"function Results.otherResults(\n    prob::Types.Problem{T,Gh,Mp,R,OR,B},\n    file,\n) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:OverheadContRes,B<:Any}\n    file[\"MeltMax\"] = prob.matProp.Mₘ\n    file[\"CoolStart\"] = prob.params.coolStart\n    file[\"Overheads/layerChanged\"] = prob.otherResults.layerChanged\n    file[\"Overheads/timeChanged\"] = prob.otherResults.timeChanged\n    file[\"Overheads/newPower\"] = prob.otherResults.newPower\n    return\nend","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"If we didn't want to store any data outside of what is incleded anyway from the material property or parameters struct, then we could have just made our new AbstractOtherResults struct empty and still used it to dispatch a method for Results.otherResults.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"In fact, as the default OtherResults struct is empty and isn't used, you can replace it with an empty struct of your own to use to dispatch methods of other functions. So if you wanted to change the behavour of one of the boundaries, or of the material model, but don't want to have to replace those structs, then just use the otherResults. I'll leave it as an exercise for the reader to rewrite the previous tutorial using this method to make things shorter.","category":"page"},{"location":"tutorials/4_res_tut/#The-Rest-of-the-Setup","page":"Tutorial 4: Saving More Results","title":"The Rest of the Setup","text":"","category":"section"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"From here on it's similar to our other simulations. The one exceptions being the fact that we need to pass our overheadHeatupFunc into HSSParams and the fact that we need to pass an empty OverheadContRes into the problem. Creating a Geometry first to feed into the HSSParams. We'll also change some of the settings of the geometry so that it goes a bit faster but be less accurate, if you want to try this out on a full simulation feel free to use the geometry from the full build tutorial.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"geometry = Geometry(\n    (0.016, 0.016, 0.0122),\n    0.001,\n    1e-2;\n    Δz=0.003 / 30,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers\",\n)","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"Then the new stuff","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"params = HSSParams(geometry; overheadHeatupFunc=overheadHeatupFunc)\notherResults = OverheadContRes(Vector{Int}(), Vector{Float64}(), Vector{Float64}())","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"We also need to make sure to use our new results struct for our initial conditions, this will tell the simulation to use it for the rest of the time steps.","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"init = OverheadResult((geometry.X, geometry.Y, geometry.Z), 25.0, 0.0, 0.0)","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"And the rest of it","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"loadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)\nmaterial = PA2200(geometry)\n\ninitialLayer = 30\n\ninkArray = fill(material.eₚ, (geometry.X, geometry.Y, geometry.Z))\ninkArray[5:end-4, 5:end-4, 60:end-10] .= material.eᵢ\nink = Ink(inkArray, \"Sample square\")\n\nfile = \"results_tutorial.jld2\"\ndescription = \"A simulation to test out saving overhead heater results\"\n\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    loadSets=loadSets,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    otherResults=otherResults,\n    description=description,\n)\n\nresultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"","category":"page"},{"location":"tutorials/4_res_tut/","page":"Tutorial 4: Saving More Results","title":"Tutorial 4: Saving More Results","text":"This page was generated using Literate.jl.","category":"page"},{"location":"doc_index/#Function-Index","page":"Function Index","title":"Function Index","text":"","category":"section"},{"location":"doc_index/","page":"Function Index","title":"Function Index","text":"","category":"page"},{"location":"howtos/howto_param/#Problem-Parameters-Recipes","page":"Problem Parameters Recipes","title":"Problem Parameters Recipes","text":"","category":"section"},{"location":"howtos/howto_param/#A-Variable-Heat-Flux-Parameter-Set","page":"Problem Parameters Recipes","title":"A Variable Heat Flux Parameter Set","text":"","category":"section"},{"location":"howtos/howto_param/","page":"Problem Parameters Recipes","title":"Problem Parameters Recipes","text":"This parameter set is about as basic as it gets. It's made to be used alongside the boundary defined in A Variable Heat Flux Boundary it just needs the heat flux field to be set to a something that is callable.","category":"page"},{"location":"howtos/howto_param/","page":"Problem Parameters Recipes","title":"Problem Parameters Recipes","text":"struct VariableHeatFluxParams{T1} <: AbstractProblemParams\n    heatflux::T1\nend","category":"page"},{"location":"howtos/howto_param/","page":"Problem Parameters Recipes","title":"Problem Parameters Recipes","text":"As an example, here we make the parameter set with a function that defines the heat flux to be 3 watts times the current time (so 10 seconds in, the heat flux would be 30 watts).","category":"page"},{"location":"howtos/howto_param/","page":"Problem Parameters Recipes","title":"Problem Parameters Recipes","text":"VariableHeatFluxParams(t -> t * 3)","category":"page"},{"location":"reference/boundary/#Boundary-Model","page":"Boundary Model","title":"Boundary Model","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary","page":"Boundary Model","title":"HSSSimulations.Boundary","text":"The functions for calculating the ghost nodes needed to solve the boundary conditions. Basic boundary conditions are also included.\n\n\n\n\n\n","category":"module"},{"location":"reference/boundary/#Parameters","page":"Boundary Model","title":"Parameters","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Types.AbstractProblemParams","category":"page"},{"location":"reference/boundary/#HSSSimulations.Types.AbstractProblemParams","page":"Boundary Model","title":"HSSSimulations.Types.AbstractProblemParams","text":"abstract type AbstractProblemParams <: HSSSimulations.Types.AbstractSimProperty\n\nThe Problem struct contains a field called boundary that is of this type. The purpose of this field is to store any boundary condition inputs that changes over the course of a build, such as the air temperature in the machine. As this is an abstract type a new struct can be made, that is a subtype of AbstractProblemParams, to contain the required variables for a given simulation. An example of this is given in HSSParams.\n\nAny new subtype will need it's own boundaries written (the examples given are only meant to work with the HSSParams example).\n\nSee the Problem Parameters Recipes for some insperation for implementing your own.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#Load-Sets","page":"Boundary Model","title":"Load Sets","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"These are not actually memebers of the Boundary module, but they are an integral part of how the boundary conditions are set up for a simulation so they are included here instead of in the Solver documentation.","category":"page"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Types.AbstractLoadSet\nSolver.loadSetSolver!\nSolver.loadSetSolver!(::FixedLoadSet,::AbstractResult,::Int,::Problem{T,Gh,Mp,R,OR,B}) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nSolver.loadSetSolver!(::LayerLoadSet,::AbstractResult,::Int,::Problem{T,Gh,Mp,R,OR,B}) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\ninnerLoadSetSolver!","category":"page"},{"location":"reference/boundary/#HSSSimulations.Types.AbstractLoadSet","page":"Boundary Model","title":"HSSSimulations.Types.AbstractLoadSet","text":"abstract type AbstractLoadSet <: HSSSimulations.Types.AbstractSimProperty\n\nThis struct holds the information for a load set, primarily the list of loads to be solved, but also some extra bits. Subtypes should implement a method for the Solver.loadSetSolver! function.\n\nA simulation problem contains a list of load sets that are solved in order. Load sets of different types can be combined to create more complex build behavour. For example, the default HSS load sets include one fixed load set, for preheating; one layer load set, for all of the layers in the build; and another fixed load set, for cooldown after the build.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#HSSSimulations.Solver.loadSetSolver!","page":"Boundary Model","title":"HSSSimulations.Solver.loadSetSolver!","text":"loadSetSolver!(\n    loadSet<:AbstractLoadSet\n    initResult::AbstractResult,\n    layerNum::Int,\n    prob::Problem{T,Gh,Mp,R,OR,B},\n) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\n\nThis function is run once for each LoadSet passed in to the problem, and dispatched on the type of that load set. For basic load sets, like FixedLoadSet, it should basically just pass the arguments on to the innerLoadSetSolver! function, the one exception being the list of loads being passed in instead of the AbstractLoadSet struct. For more complicated load sets, like LayerLoadSet, this should include the logic used for that load set. For LayerLoadSet this is a loop that loops over the list of loads once for each layer, incrementing the layer number as it goes.\n\nFor examples see the source code for the two default implementations.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{FixedLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}","page":"Boundary Model","title":"HSSSimulations.Solver.loadSetSolver!","text":"loadSetSolver!(\n    loadSet::FixedLoadSet,\n    initResult::AbstractResult,\n    layerNum::Int64,\n    prob::Problem{T, Gh, Mp, R, OR, B}\n)\n\n\n\n\n\n\n","category":"method"},{"location":"reference/boundary/#HSSSimulations.Solver.loadSetSolver!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{LayerLoadSet, AbstractResult, Int64, Problem{T, Gh, Mp, R, OR, B}}} where {T, Gh, Mp, R, OR, B}","page":"Boundary Model","title":"HSSSimulations.Solver.loadSetSolver!","text":"loadSetSolver!(\n    loadSet::LayerLoadSet,\n    initResult::AbstractResult,\n    initLayerNum::Int64,\n    prob::Problem{T, Gh, Mp, R, OR, B}\n) -> Tuple{AbstractResult, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"reference/boundary/#HSSSimulations.Solver.innerLoadSetSolver!","page":"Boundary Model","title":"HSSSimulations.Solver.innerLoadSetSolver!","text":"innerLoadSetSolver!(\n    loads::Vector{Load},\n    initResult::AbstractResult,\n    layerNum,\n    prob::Problem;\n    name,\n    isRecoatLoadSet,\n    prevLayerNum\n)\n\n\nSolves a load set of a problem, iterating over and solving the loads in the given load set in order. The results for a load is saved to the file after solving it.\n\nIf the list of loads passed given include powder deposition, the recoat kwarg should be set to true, with the layerNum set to the thickness of the powder bed in layers that is desired at the end of the loads. If this is more than one layer thicker than the previous value, then the previous values should also be passed in to prevLayerNum.\n\nIt also helps to provide a unique name. This is the name that will be used to store the results from runnning the list of loads in the output file, and also will be used as the label in the progress meter. If no name is given then the current time is used instead. If the name given is not unique then you will get a run time error when it tries to save results to a place that is already taken.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#Loads","page":"Boundary Model","title":"Loads","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.Load()\nTypes.Load","category":"page"},{"location":"reference/boundary/#HSSSimulations.Types.Load-Tuple{}","page":"Boundary Model","title":"HSSSimulations.Types.Load","text":"Types.Load(;\n    name=\"default\", tₗ=1, skip=1,\n    x₁=SymetryBoundary, x₂=SymetryBoundary,\n    y₁=SymetryBoundary, y₂=SymetryBoundary,\n    z₁=SymetryBoundary, z₂=SymetryBoundary,\n)\n\nDefault constructor for Types.Load. All of the boundaries defaults to symetry boundaries (see Boundary.SymetryBoundary). See Boundary.ConductionBoundary and Boundary.ConvectionBoundary, for some more built in loads. And HSS Boundary for more complicated loads.\n\nThe z₂ load is run before any others, so any calculations that need to be done first should be put there, such as recoating.\n\nExamples\n\njulia> Load(; name=\"test\", tₗ=1, skip=1, x₁=ConductionBoundary, y₂=ConvectionBoundary)\n  x₁ : ConductionBoundary\n  x₂ : SymetryBoundary\n  y₁ : SymetryBoundary\n  y₂ : ConvectionBoundary\n  z₁ : SymetryBoundary\n  z₂ : SymetryBoundary\n  name : test\n  tₗ : 1.0\n  skip : 1\n\n\n\n\n\n","category":"method"},{"location":"reference/boundary/#HSSSimulations.Types.Load","page":"Boundary Model","title":"HSSSimulations.Types.Load","text":"struct Load{X₁<:AbstractBoundary, X₂<:AbstractBoundary, Y₁<:AbstractBoundary, Y₂<:AbstractBoundary, Z₁<:AbstractBoundary, Z₂<:AbstractBoundary} <: HSSSimulations.Types.AbstractSimProperty\n\nFields\n\nx₁::Type{X₁} where X₁<:AbstractBoundary: The boundary condition for the start of the x axis ([1,:,:])\nx₂::Type{X₂} where X₂<:AbstractBoundary: The boundary condition for the end of the x axis ([end,:,:])\ny₁::Type{Y₁} where Y₁<:AbstractBoundary: The boundary condition for the start of the y axis ([:,1,:])\ny₂::Type{Y₂} where Y₂<:AbstractBoundary: The boundary condition for the end of the y axis ([:,end,:])\nz₁::Type{Z₁} where Z₁<:AbstractBoundary: The boundary condition for the start of the z axis ([:,:,1])\nz₂::Type{Z₂} where Z₂<:AbstractBoundary: The boundary condition for the end of the z axis ([:,:,end])\nname::String: Used to annotate the results\ntₗ::Float64: The duration of the load in seconds\nskip::Int64: The distance between results to save (see Why We Skip Some Results)\n\nEach of the boundaries given must satisfy Boundary isa Type{T} where T <: AbstractBoundary. This is to say that they should be the type itself, not an instance of that type. Additionally it should be a subtype of AbstractBoundary and meet all of the requirements outlined in the that documentation.\n\nnote: Note\nIf the Load is in a BuildLoadSet then one of the boundaries in one of the loads in the set should call the recoating logic so that new powder is actuall being layed down. This should always be done in the z₂ boundary, as it is a special case that ensures the indicies are updated for all other boundaries.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#Boundary","page":"Boundary Model","title":"Boundary","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Types.boundaryHeatTransferRate\nTypes.AbstractBoundary","category":"page"},{"location":"reference/boundary/#HSSSimulations.Types.boundaryHeatTransferRate","page":"Boundary Model","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p<:AbstractBoundary) -> ϕ⃗::Float64\n\nUsed to calculate the heat flux denstity (ϕ⃗, in wm⁻²) into the model at a node on the relavant face for a given boundary condition. They are run per node, for each node on the face. The function should return a single numeric value that represents the heat flux density into the model.\n\nArguments\n\nT     : The temperature of the node for which the ghost node is being calculated\ni     : The cartesian index of the node for which the ghost node is being calculated\np     : The boundary struct for the current boundary (see AbstractBoundary)\n\nSee the implementations of this for examples, and Boundary Recipes for some additional examples along with the relevant boundary structs.\n\nnote: Note\nA positive heat flow equates to heat flowing into the model and negative out of the model.\n\nwarning: Warning\nAs this is run for every node on the face every time step, try to avoid complex computations. Where possible, put them in the constructor of the AbstractBoundary instead, as that is only run once per face per timestep.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Types.AbstractBoundary","page":"Boundary Model","title":"HSSSimulations.Types.AbstractBoundary","text":"Subtypes of this define a boundary for a single face of the model. An instance of the subtype is created per boundary each time step.\n\nThe fields of the subtype should contain all of the information needed to calculate the heatflow on that boundary (except for the information already passed in to Types.boundaryHeatTransferRate).\n\nEach subtype of this should have a constructor that satisfies the following signature:\n\n<Boundary>(pts::AbstractResult, cts::AbstractResult, prob::Problem, ls::LoadStep)\n\nArguments\n\npts  : The results from the previous timestep. See Result\ncts  : The results from the current timestep. See Result\nprob : The 'global' variables of the simulation. See Problem\nls   : The per load step variables. See Types.LoadStep\n\nFor examples see the default subtypes, and their constructors. Boundary Recipes has examples of some of the extra things that can be done with new AbstractBoundarys.\n\nwarning: Warning\nThe constructor for z₂ is the only one that is run before the indices lists are set for that load. So any updating of the indices, such as that done by recoating!, should be done in that boundary constructor.\n\nwarning: Warning\ncts.T is unknown when this function is called, use the temperature from the previous time step insted (pts.T).\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#Symmetry","page":"Boundary Model","title":"Symmetry","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.SymetryBoundary\nBoundary.boundaryHeatTransferRate(::Any,::Any,::SymetryBoundary)","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary.SymetryBoundary","page":"Boundary Model","title":"HSSSimulations.Boundary.SymetryBoundary","text":"struct SymetryBoundary <: AbstractBoundary\n\nA boundary for a face that has no heatflow (such as a face on a symetrical boundary). Used as the default boundary in Types.Load.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SymetryBoundary}","page":"Boundary Model","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(\n    _,\n    _,\n    _::SymetryBoundary\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"reference/boundary/#Conduction","page":"Boundary Model","title":"Conduction","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.ConductionBoundary\nBoundary.boundaryHeatTransferRate(::Any,::Any,::ConductionBoundary)\nBoundary.conductionFlow","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary.ConductionBoundary","page":"Boundary Model","title":"HSSSimulations.Boundary.ConductionBoundary","text":"struct ConductionBoundary <: AbstractBoundary\n\nA boundary for a face that has a source of contact conductive heat flow.\n\nFields\n\ntemp::Float64: Temperature of object being contacted\ncoef::Float64: Coefficient of contact conduction\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConductionBoundary}","page":"Boundary Model","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, _, p::ConductionBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/boundary/#HSSSimulations.Boundary.conductionFlow","page":"Boundary Model","title":"HSSSimulations.Boundary.conductionFlow","text":"conductionFlow(T1, T2, h)\n\n\nCalculates a heat flux density (ϕ⃗, in wm⁻²) for a given contact conduction coefficient, h, between points at temperature T1 (the node on the boundary) and T2 (the wall in contact with the node).\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#Convection","page":"Boundary Model","title":"Convection","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.ConvectionBoundary\nBoundary.boundaryHeatTransferRate(::Any,::Any,::ConvectionBoundary)\nBoundary.convectionFlow","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary.ConvectionBoundary","page":"Boundary Model","title":"HSSSimulations.Boundary.ConvectionBoundary","text":"struct ConvectionBoundary <: AbstractBoundary\n\nA boundary for a face that has a source of convective heat flow.\n\nFields\n\ntemp::Float64: Air temperature\ncoef::Float64: Convection coefficient\n\n\n\n\n\n","category":"type"},{"location":"reference/boundary/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, ConvectionBoundary}","page":"Boundary Model","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, _, p::ConvectionBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/boundary/#HSSSimulations.Boundary.convectionFlow","page":"Boundary Model","title":"HSSSimulations.Boundary.convectionFlow","text":"convectionFlow(T1, T∞, h)\n\n\nCalculates a heat flux density (ϕ⃗, in wm⁻²) for a given convection coefficient, h, between a point at temperature T1 and a fluid with temperature T∞.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#Radiation","page":"Boundary Model","title":"Radiation","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.radiationFlow","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary.radiationFlow","page":"Boundary Model","title":"HSSSimulations.Boundary.radiationFlow","text":"radiationFlow(T1, T∞, ε)\n\n\nCalculates a heat flux density (ϕ⃗, in wm⁻²) for a given emmisivity, ε, between a point at temperature T1 and infinity at temperature T∞. The temperature arguments should both be in the units °C.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#Utilities","page":"Boundary Model","title":"Utilities","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.movingObjOverlap\nBoundary.recoating!","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary.movingObjOverlap","page":"Boundary Model","title":"HSSSimulations.Boundary.movingObjOverlap","text":"movingObjOverlap(\n    geometry::Geometry,\n    movingObj,\n    objPos::Tuple{Int64, Int64}\n) -> Vector\n\n\nMakes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos left and right edge are given by objPos. The overlap is filled with the value passed as movingObj.\n\nThe difference between the first and second value of the objPos Tuple multipled by the spacing in the y-axis (Δy) should match the width of the moving object.\n\nExamples\n\njulia> geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));\n\njulia> movingObjOverlap(geometry, true, (2, 4))\n3-element Vector{Bool}:\n 1\n 1\n 0\n\n\n\n\n\nmovingObjOverlap(\n    geometry::Geometry,\n    movingObj::AbstractVector,\n    objPos::Int64\n) -> Any\n\n\nMakes a vector the length of the y-axis of the simulation. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by objPos. The overlap is filled with the matching values from the vector movingObj.\n\nThe length of the vector multipled by the spacing in the y-axis (Δy) should match the width of the moving object.\n\nExamples\n\njulia> geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));\n\njulia> movingObjOverlap(geometry, [1, 2, 3, 4, 5], 6)\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> movingObjOverlap(geometry, [1, 2, 3, 4, 5], 8)\n3-element Vector{Int64}:\n 0\n 1\n 2\n\n\n\n\n\nmovingObjOverlap(\n    geometry::Geometry,\n    movingObj::AbstractMatrix,\n    objPos::Int64\n) -> Any\n\n\nMakes a matrix with the same dimensions as the top surface of the simulation area. It represents the overlap between the simulation area an object that moves in the y-axis, whos right edge are given by objPos. The overlap is filled with the matching values from the matrix movingObj.\n\nAlso for Matrix inputs, the length of the first axis multipled by the spacing in the x-axis (Δx) should match the depth of the moving object and the length of the second axis multipled by the spacing in the y-axis (Δy) should match the width of the moving object.\n\nExamples\n\njulia> geometry = Geometry((0.015, 0.015, 0.010), 0.005, 0.010; offset=(0, 0.01));\n\njulia> movingObjOverlap(geometry, [1 2 3; 4 5 6; 7 8 9], 4)\n3×3 Matrix{Int64}:\n 2  3  0\n 5  6  0\n 8  9  0\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Boundary.recoating!","page":"Boundary Model","title":"HSSSimulations.Boundary.recoating!","text":"recoating!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep,\n    recoatDist,\n    temp\n)\n\n\nPowder recoating logic. This updates the indices and fills the new real indices with the initial results provided in the simulation's Problem, except the temperature, which is set to temp. This allows for the new powder temp to be set to the temperature of the powder in the hopper, or feed bed, at that time in the build. This always runs in the positive y axis, so new powder is always deposited starting from [:, 1, :] and going to [:, end, :].\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#Internals","page":"Boundary Model","title":"Internals","text":"","category":"section"},{"location":"reference/boundary/","page":"Boundary Model","title":"Boundary Model","text":"Boundary.calcInds\nBoundary.padWithGhost!\nBoundary.updateInds!\nBoundary.ghostCalc!\nBoundary.boundaryTemp\nBoundary.σ","category":"page"},{"location":"reference/boundary/#HSSSimulations.Boundary.calcInds","page":"Boundary Model","title":"HSSSimulations.Boundary.calcInds","text":"calcInds(\n    resultsArray::AbstractArray,\n    ghostArray::AbstractArray,\n    ΔH::Int64,\n    isRecoatLoadSet::Bool\n) -> HSSSimulations.Types.Indices\n\n\nCalculates the indices at the start of a load. For build load sets this includes 'imaginary' nodes that don't yet represent a volume with powder in it (but will after recoat). isRecoatLoadSet should be set to true if the current load set includes powder recoating, and false if it does not. ΔH is the same as that found in the Geometry struct.\n\nSee Types.Indices for more details on the struct returned by this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Boundary.padWithGhost!","page":"Boundary Model","title":"HSSSimulations.Boundary.padWithGhost!","text":"padWithGhost!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    ls,\n    prob\n)\n\n\nWraps the temperature array with ghost cells and updates the Tᵗ⁻¹ array in the Problem with the new value. The ghost cells are calculated based on a the boundaries for each face provided in the current load. See Types.Load for more details on these boundaries.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Boundary.updateInds!","page":"Boundary Model","title":"HSSSimulations.Boundary.updateInds!","text":"updateInds!(\n    indStruct::HSSSimulations.Types.Indices,\n    resultsArray::AbstractArray,\n    ghostArray::AbstractArray,\n    recoatDist::Int64\n)\n\n\nUpdates an indices struct during a load step. Used to update the real and imaginary nodes during recoat of the powder layer based on the recoatDist (how far through the layer the powder has been deposited in number of nodes into the simulation area).\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Boundary.ghostCalc!","page":"Boundary Model","title":"HSSSimulations.Boundary.ghostCalc!","text":"ghostCalc!(Tᵗ⁻¹, T, params, indices, gdist, κ)\n\n\nFills in the ghost nodes for the boundary on the face defined by indices using the boundaryHeatTransferRate function for the type of the boundary parametre (params) given.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Boundary.boundaryTemp","page":"Boundary Model","title":"HSSSimulations.Boundary.boundaryTemp","text":"boundaryTemp(ϕ⃗, T, κ, gdist) -> Any\n\n\nCalculates a temperature for a ghost cell that will give the heat flux density (ϕ⃗, in wm⁻²) to a node with a temperature of T. gdist is the distance between the ghost and real node in meters, eg. for a z boundary it would be Δz.\n\n\n\n\n\n","category":"function"},{"location":"reference/boundary/#HSSSimulations.Boundary.σ","page":"Boundary Model","title":"HSSSimulations.Boundary.σ","text":"Stefan-Boltzmann constant\n\n\n\n\n\n","category":"constant"},{"location":"howtos/howto_subsets/#Simulating-Subsets-of-a-Build","page":"Simulating Subsets of a Build","title":"Simulating Subsets of a Build","text":"","category":"section"},{"location":"howtos/howto_subsets/#A-Single-Layer","page":"Simulating Subsets of a Build","title":"A Single Layer","text":"","category":"section"},{"location":"howtos/howto_subsets/","page":"Simulating Subsets of a Build","title":"Simulating Subsets of a Build","text":"This simulates a single layer deposited on top of a uniformly preheated powder bed.","category":"page"},{"location":"howtos/howto_subsets/","page":"Simulating Subsets of a Build","title":"Simulating Subsets of a Build","text":"geometry = Geometry(\n    (0.016, 0.016, 0.031),\n    0.001,\n    1.5e-3;\n    Δz=0.003 / 90,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 1 layer of build\",\n)\nmaterial = PA2200(geometry)\nparams = HSSParams(geometry)\nloadSets = HSSLoads(1, geometry; nrPreheat=0, lenPreheat=0.0, nrCool=0, lenCool=0.0)\n\ngeomsize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(geomsize, 160.0, 0.0, 0.0, 1000.0)\ninitialLayer = 30\n\ninkArray = fill(material.eₚ, size)\nink = Ink(inkArray, \"Empty\")\n\nfile = tempname()\ndescription = \"A single layer simulation with no ink\"\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    preheatLoads=preheatLoads,\n    buildLoads=buildLoads,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    description=description,\n)\n\nresultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"reference/res/#Simulation-Results","page":"Simulation Results","title":"Simulation Results","text":"","category":"section"},{"location":"reference/res/","page":"Simulation Results","title":"Simulation Results","text":"Results","category":"page"},{"location":"reference/res/#HSSSimulations.Results","page":"Simulation Results","title":"HSSSimulations.Results","text":"Contains a concrete time step and final results type and the functions needed to process the results for these types.\n\n\n\n\n\n","category":"module"},{"location":"reference/res/#Time/Load-Step-Results","page":"Simulation Results","title":"Time/Load Step Results","text":"","category":"section"},{"location":"reference/res/","page":"Simulation Results","title":"Simulation Results","text":"Types.AbstractResult\nResults.loadStepSaver\nResults.loadStepSaver(::Any, ::StructVector{T}) where {T<:Result}","category":"page"},{"location":"reference/res/#HSSSimulations.Types.AbstractResult","page":"Simulation Results","title":"HSSSimulations.Types.AbstractResult","text":"abstract type AbstractResult <: HSSSimulations.Types.AbstractSimProperty\n\nThis as the abstract type for the results from a single simulation time step. These are save at the end of every load step for each of the time steps in that load step (ignoring time steps that are skipped over based on the load steps skip value).\n\nSee Tutorial 4: Saving More Results and Result Type Recipes for how to make your own subtype.\n\nwarning: Warning\nAs this struct is what stores the data during the simulation, all subtypes MUST have the T, t and tₚ fields, and if used with the default material model it will also need the M and C fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/res/#HSSSimulations.Results.loadStepSaver","page":"Simulation Results","title":"HSSSimulations.Results.loadStepSaver","text":"loadStepSaver(loadResultsFolder, loadResults::StructVector{T}) where {T<:AbstractResult}\n\nSaves the results of a load step into the folder for the current load step in the output file of the problem, given by the loadResultsFolder argument.\n\nAny new methods for this function should dispatch on the type parameter of the loadResults, and save any desired results to the file like so:\n\nfunction loadStepSaver(loadResultsFolder, loadResults::StructVector{T}) where {T<:AbstractResult}\n    loadResultsFolder[\"time\"] = loadResults.t\n    loadResultsFolder[\"T\"] = stack(loadResults.T)\n    return\nend\n\nnote: Note\nstack is used as a very efficient way of converting the vector of 3D arrays from the StructVector in to a 4D array.\n\n\n\n\n\n","category":"function"},{"location":"reference/res/#HSSSimulations.Results.loadStepSaver-Union{Tuple{T}, Tuple{Any, StructVector{T}}} where T<:Result","page":"Simulation Results","title":"HSSSimulations.Results.loadStepSaver","text":"loadStepSaver(\n    loadResultsFolder,\n    loadResults::StructArray{T<:Result, 1}\n)\n\n\nSaves the results for the temperature, melt state and consolidation state as 4D arrays of X,Y,Z and t. And the time is saved as a 1D Array.\n\n\n\n\n\n","category":"method"},{"location":"reference/res/#End-of-Simulation-Results","page":"Simulation Results","title":"End of Simulation Results","text":"","category":"section"},{"location":"reference/res/","page":"Simulation Results","title":"Simulation Results","text":"Types.AbstractOtherResults\nResults.otherResults\nResults.otherResults(::Problem{T,Gh,Mp,R,OR,B}, ::Any) where {T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/res/#HSSSimulations.Types.AbstractOtherResults","page":"Simulation Results","title":"HSSSimulations.Types.AbstractOtherResults","text":"abstract type AbstractOtherResults <: HSSSimulations.Types.AbstractSimProperty\n\nThis as the abstract type for the results that are saved only at the end of the simulation. This is useful to store things that do not change every time step, without requiring any changes to the material property or params structs. However those structs can also be used to store such things, such as is done for Mₘ in the MatProp struct.\n\nAs the default implementation does nothing, and nothing normally dispatches on it, it can be replaced by another empty type to use a new method for any function that dispatches on Problem (I think that's all of the user facing API).\n\nSee Tutorial 4: Saving More Results and Result Type Recipes for how to make your own subtype.\n\n\n\n\n\n","category":"type"},{"location":"reference/res/#HSSSimulations.Results.otherResults","page":"Simulation Results","title":"HSSSimulations.Results.otherResults","text":"otherResults(prob<:Problem, file)\n\nRuns at the end of the simulation to save any additional results that only need to be saved once, as opposed to for every nth time step. The Types.Problem type and any of its type parameters can be dispatched on.\n\nSee AbstractOtherResults for a place to store random data, and Tutorial 4: Saving More Results for a detailed guide.\n\n\n\n\n\n","category":"function"},{"location":"reference/res/#HSSSimulations.Results.otherResults-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp, R, OR, B}","page":"Simulation Results","title":"HSSSimulations.Results.otherResults","text":"otherResults(problem::Problem{T, Gh, Mp, R, OR, B}, file)\n\n\nDefault otherResults method that just saves the maximum melt state reached for each node.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"EditURL = \"../../lit/basic_tut.jl\"","category":"page"},{"location":"tutorials/2_basic_tut/#Tutorial-2:-Warm-up-and-Cool-down-only","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"using HSSSimulations","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"This tutorial will cover how to create a basic simulation problem, solve it, and inspect the results. This basic simulation will only simulate a solid block without, no layers or anything else fancy.","category":"page"},{"location":"tutorials/2_basic_tut/#Defining-the-Problem","page":"Tutorial 2: Warm-up and Cool-down only","title":"Defining the Problem","text":"","category":"section"},{"location":"tutorials/2_basic_tut/#Geometry","page":"Tutorial 2: Warm-up and Cool-down only","title":"Geometry","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"First we'll start by defining the finite difference geometry for the problem. This is done by creating an instance of Geometry as shown below. The first argument is the size of the simulation in meters (here it is 10 mm x 10 mm x 30 mm), the second is the spacing between the finite difference nodes, and the third is the time step. Finally, a name has been given to make it easier to figure out what we're looking at if we come back to this in the future.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"geometry = Geometry(\n    (0.010, 0.010, 0.030),\n    0.0005,\n    0.001;\n    name=\"Basic Simulation Tutorial\",\n)","category":"page"},{"location":"tutorials/2_basic_tut/#Material","page":"Tutorial 2: Warm-up and Cool-down only","title":"Material","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"For the material we will use the default material model along with the example material, PA2200 (for information on defining a new material or material model see Material Recipes.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"material = PA2200(geometry)","category":"page"},{"location":"tutorials/2_basic_tut/#Boundary-and-Loads","page":"Tutorial 2: Warm-up and Cool-down only","title":"Boundary and Loads","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"For the boundary conditions we will borrow some things from the boundary example module HSS Boundary.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"params = HSSParams(\n    geometry;\n    overheadPower=300.0,\n    name=\"Overhead heat and cool\",\n)","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"First we make the Types.AbstractProblemParams we will be using, a HSSParams struct (This includes way more than we need here, but it will still work. If you want to define a simpler struct have a look at Problem Solver Recipes).","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"skipper = 20\ncooldownLoads = vcat(\n    [HSSBound.loadOverheads(3.0, skipper) for _ in 1:2],\n    [HSSBound.loadCooldown(3.0, skipper) for _ in 1:2],\n)","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"Next we make an array of the load conditions we want to simulate. For this example we will be putting all of our loads in the cooldown loads, as we aren't dealing with layers we don't need the build loads, and the preheat loads are run before any layers are deposited, so they can't really be used here.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"Put simply, this will simulate 1.5 minutes (3x30 seconds) of heating from the overhead heaters (HSSBound.loadOverheads) followed by 15 minutes of cooling (HSSBound.loadCooldown). The skipper is how often the results will be saved, here we are saying to only save one result for every 20 time steps (See Why We Skip Some Results for more information on why).","category":"page"},{"location":"tutorials/2_basic_tut/#Initial-Conditions","page":"Tutorial 2: Warm-up and Cool-down only","title":"Initial Conditions","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"Next up is the initial results. Before we define them, we'll make life a little easier for ourselves by making a tuple to represent the simulation size (unlike the one we used earlier, this one is the simulation size in number of nodes, instead of in meters).","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"geomSize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(geomSize, 25.0, 0.0, 0.0)\ninitLay = geometry.Z","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"The initial condition (made as a Result) here will set all the simulation to 25 °C and set the melt state and consolidation state to zero.","category":"page"},{"location":"tutorials/2_basic_tut/#Ink","page":"Tutorial 2: Warm-up and Cool-down only","title":"Ink","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"inkArray = fill(material.eₚ, geomSize)\nink = Ink(inkArray, \"No ink\")","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"We'll use the size tuple again to make an array to hold our Ink values. This array stores the emissivity for all the points in the simulation, as we are not printing any ink for this simulation we will just set it all to the powder's emissivity.","category":"page"},{"location":"tutorials/2_basic_tut/#Construct-The-Problem","page":"Tutorial 2: Warm-up and Cool-down only","title":"Construct The Problem","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"With everything set up the last step is to give it a little description, decide where to save the results to and then create the Problem (ignore the geometry.Z, we'll cover that in the Tutorial 1: Full Build).","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"note: Note\nThe file path given here will save the results to the temporary directory on a Unix based system. If you are using windows, or want to save the file elsewhere then you should change the path.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"file = tempname()\ndescription = \"A basic simulation to teach us how to use this package\"\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=geometry.Z,\n    ink=ink,\n    file=file,\n    description=description,\n)","category":"page"},{"location":"tutorials/2_basic_tut/#Solving-the-Problem","page":"Tutorial 2: Warm-up and Cool-down only","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"Now the complicated bit. We need to run the following:","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"resultFile, finalResult = problemSolver(problem)","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"No really, that's it. That one line will solve your problems for you (well, your simulation problems). It might take a while, but once it starts solving the loads you should get some nice progress bars to reassure you that it hasn't just crashed.","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"The resultFile returned is just the file path to read the results from, as the simulation results can get quite big in their uncompressed form they aren't all kept in memory (also why we set the skip to 20 earlier, otherwise the results would be 20x as big). However, the final time step is returned, captured here in the finalResult variable. Just in case you quickly need the end results.","category":"page"},{"location":"tutorials/2_basic_tut/#Inspecting-the-Results","page":"Tutorial 2: Warm-up and Cool-down only","title":"Inspecting the Results","text":"","category":"section"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"Now we have solved the problem, we should probably have a look at what the results were. Firstly we can get a good overview of the results using the","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"","category":"page"},{"location":"tutorials/2_basic_tut/","page":"Tutorial 2: Warm-up and Cool-down only","title":"Tutorial 2: Warm-up and Cool-down only","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/howto_loadset/#loadsettype","page":"Load Set Type Recipes","title":"Load Set Type Recipes","text":"","category":"section"},{"location":"howtos/howto_loadset/","page":"Load Set Type Recipes","title":"Load Set Type Recipes","text":"Before reading this, it might be a good idea to have a look at AbstractLoadSet.","category":"page"},{"location":"howtos/howto_loadset/","page":"Load Set Type Recipes","title":"Load Set Type Recipes","text":"The previous tutorials have been removed as they were obsoleted by new features, stay tuned for their replacements.","category":"page"},{"location":"howtos/howto_load/#Load-Recipes","page":"Load Recipes","title":"Load Recipes","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"You might want to check out Load","category":"page"},{"location":"howtos/howto_load/#A-Cooling-Recoat-Load-and-Load-Set","page":"Load Recipes","title":"A Cooling Recoat Load and Load Set","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"This load will and load set use the boundary that we created in A Cooling Recoat Boundary","category":"page"},{"location":"howtos/howto_load/#Loads","page":"Load Recipes","title":"Loads","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"When making a load, we only need to define the boundaries that are different from the default, any undefined boundaries are left as SymetryBoundarys.","category":"page"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"Well make a function to create a new Load that takes a time length and a skip ([Why We Skip Some Results]@ref).","category":"page"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"function loadRecoatCoolStroke(tₗ, skip)\n    return Load(;\n        # Lets give it a name we'll be able to recognise later\n        name = \"Cooldown Recoat\",\n        tₗ   = tₗ,\n        skip = skip,\n        # Set the bottom boundary\n        z₁=PistonCoolBoundary,\n        # Set the top boundary\n        z₂=RecoatCoolBoundary,\n    )\nend","category":"page"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"Well also make a matching load to go with the matching boundary from A Cooling Recoat Return Boundary.","category":"page"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"function loadRecoatCoolReturnStroke(tₗ, skip)\n    return Load(;\n        name = \"Cooldown Return\",\n        tₗ   = tₗ,\n        skip = skip,\n        z₁   = PistonCoolBoundary,\n        z₂   = RecoatCoolReturnBoundary,\n    )\nend","category":"page"},{"location":"howtos/howto_load/#Load-Set","page":"Load Recipes","title":"Load Set","text":"","category":"section"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"The load sets that are given to the solver are actually just a list of loads. So here we'll just make a function that returns a list of the loads we want. This one works for a recoater that spends 7 seconds over the bed with one second between each time it's over the bed.","category":"page"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"function cooldownLoadSet(skip)\n    return [\n        # A load without any carriage movement to represent when the carriage\n        # isn't above the bed\n        loadCooldown(1.0, skip),\n        loadRecoatStroke(7.0, skip),\n        loadCooldown(1.0, skip),\n        loadRecoatReturnStroke(7.0, skip),\n        loadCooldown(1.0, skip),\n    ]\nend","category":"page"},{"location":"howtos/howto_load/","page":"Load Recipes","title":"Load Recipes","text":"If we wanted this to have custom behaviour in the problem we might want to define a new LoadSet type or if you want even more complicated behaviour, have a look at Problem Solver Recipes.","category":"page"},{"location":"reference/postprocessing/#Post-Processing","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"reference/postprocessing/","page":"Post Processing","title":"Post Processing","text":"PostProcessing","category":"page"},{"location":"reference/postprocessing/#HSSSimulations.PostProcessing","page":"Post Processing","title":"HSSSimulations.PostProcessing","text":"Some functions to ease the post processing of the simulation results.\n\n\n\n\n\n","category":"module"},{"location":"reference/postprocessing/#External","page":"Post Processing","title":"External","text":"","category":"section"},{"location":"reference/postprocessing/","page":"Post Processing","title":"Post Processing","text":"PostProcessing.makeIndex","category":"page"},{"location":"reference/postprocessing/#HSSSimulations.PostProcessing.makeIndex","page":"Post Processing","title":"HSSSimulations.PostProcessing.makeIndex","text":"makeIndex(group)\n\nwarning: Warning\nThis function is hard coded to only make an index for two levels deep, this is meant to work with the loadsets and loads as the two levels.\n\n\n\n\n\n","category":"function"},{"location":"reference/postprocessing/#Internal","page":"Post Processing","title":"Internal","text":"","category":"section"},{"location":"howtos/howto_bound/#Boundary-Recipes","page":"Boundary Recipes","title":"Boundary Recipes","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"AbstractBoundary and boundaryHeatTransferRate are your places to go for more information.","category":"page"},{"location":"howtos/howto_bound/#A-Fixed-Heat-Flux-Boundary","page":"Boundary Recipes","title":"A Fixed Heat Flux Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"struct FixedHeatFluxBoundary <: AbstractBoundary\n    # Here goes the parameters that we will have access to in this boundaries\n    # method for the boundaryHeatTransferRate. We wont actually have any for\n    # this boundary\n    # heat flux we want to use as the fixed value.\n\n    # Our new boundary has to have a constructor that meets the signature\n    # requirements detailed in the AbstractBoundary documentation. For this\n    # boundary we don't need any of the inputs so we'll just discard them.\n    FixedHeatFluxBoundary(_, _, _, _) = new()\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"This boundary needs to implement a method for the boundaryHeatTransferRate function. This is what will be called on each node of the simulation that is on the boundary. As with the constructor, our simple boundary can ignore all the fields.","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"function Types.boundaryHeatTransferRate(_, _, _::FixedHeatFluxBoundary)\n    # Return a floating point representing the heat flux density\n    return 10.0\nend","category":"page"},{"location":"howtos/howto_bound/#A-Variable-Heat-Flux-Boundary","page":"Boundary Recipes","title":"A Variable Heat Flux Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"Let's raise the stakes a little (but not much), we'll make a new boundary that has a heat flux density that changes depending only on the current time of the simulation. We'll have to make a new AbstractProblemParams (the one used here is from A Variable Heat Flux Parameter Set )","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"struct FixedHeatFluxBoundary <: Types.AbstractBoundary\n    # All we need for this one is the heat flux we want to.\n    heatFluxDensity::Float64\n\n    # Our new boundary has to have a constructor that meets the signature\n    # requirements detailed in the AbstractBoundary documentation. For this\n    # boundary we only actually need two of the inputs, so we'll just discard\n    # the rest of them.\n    function RecoatCoolBoundary(_, cts, prob::Problem, _)\n        # Normally a boundary's constructor would use the params field that we\n        # gave to the problem quite a bit, so it's handy to make it easier to\n        # access. In this case it will only be used once, but I'll keep this\n        # here out of good habit anyway.\n        param = prob.params\n\n        # The current time step (cts) is given in, so lets grab its time to use\n        # in our heat flux function.\n        time = cts.t\n        heatflux = param.heatflux(time)\n\n        # Another useful field in prob is the problems geometry. Here we'll use\n        # this to find out the area of a node, to convert our heat flux into a\n        # heat flux density.\n        geom = prob.geometry\n        # Finding the area of the face of a node parallel to the y-axis\n        area = geom.X * geom.Z\n        heatfluxdensity = heatflux / area\n\n        return new(heatfluxdensity)\n    end\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"function Types.boundaryHeatTransferRate(_, _, p::FixedHeatFluxBoundary)\n    # Return a floating point representing the heat flux density\n    return p.heatfluxdensity\nend","category":"page"},{"location":"howtos/howto_bound/#A-Cooling-Recoat-Boundary","page":"Boundary Recipes","title":"A Cooling Recoat Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"This boundary behaves very similarly to the built-in boundary RecoatBoundary, but it uses the temperatures for the air and internal surfaces. It also conditionally calls coolingStart to make sure that the start time of the cool down stage is set. And the lamp is turned off (even if there is a recoat lamp power set).","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"struct RecoatCoolBoundary <: Types.AbstractBoundary\n    # All of the parameters we need to pass into the boundaryHeatTransferRate function\n    overheadTemp::Float64\n    surfaceTemp::Float64\n    eₗ::Array{Float64,3}\n    ε::Float64\n    airTemp::Float64\n    h::Float64\n    shadow::Vector{Bool}\n    Po::Float64\n\n    function RecoatCoolBoundary(pts, cts, prob::Problem, ls::Types.LoadStep)\n        param = prob.params\n\n        # Use an overhead power of 0 w\n        param.overheadTemp = overheadTemp = param.overheadHeatupFunc(0.0, param.overheadTemp, cts)\n\n        # If the coolStart hasn't been set, set it\n        if isnan(prob.params.coolStart)\n            coolingStart(pts.t, cts.t, prob.params)\n        end\n\n        # Find how far through the cooling parameters the current time step is\n        tAir = (cts.t - param.coolStart) + param.airCoolStart\n        tSurface = (cts.t - param.surfaceCoolStart)\n\n        # Use the Cool parameters to find the air and surface temperatures\n        airTemp = param.airCool(tAir)\n        surfaceTemp = param.surfaceCool(tSurface)\n\n        # Get the other parameters to pass through\n        eₗ = prob.eᵗ\n        ε = prob.matProp.ε\n        h = param.convectionCoef\n        Po = param.percentOverhead\n\n        # Calculate the position of the carriage and therefor its shadow\n        pos = ceil(Int, (param.carriageWidth + prob.geometry.Y_BUILD) * cts.tₚ)\n        shadowPos = (pos - param.carriageWidth, pos)\n        shadow = movingObjOverlap(prob.geometry, true, shadowPos)\n\n        # Calculate the distance across the bed the recoater has traveled, and\n        # use it to set the new nodes\n        recoatDist = pos - param.recoatOffset\n        if prob.geometry.Y_OFFSET < recoatDist <= prob.geometry.Y_OFFSET + prob.geometry.Y\n            recoatDist = recoatDist - prob.geometry.Y_OFFSET\n            recoating!(pts, cts, prob, ls, recoatDist, surfaceTemp)\n        end\n\n        # Any new powder put down is set to have the machines ambient air\n        # temperature as it's initial temperature\n        z₂ᵣ = map(first, ls.ind.z₂)\n        for i in z₂ᵣ\n            if pts.T[i] == prob.init.T[i]\n                pts.T[i] = airTemp\n            end\n        end\n\n        return new(overheadTemp, surfaceTemp, eₗ, ε, airTemp, h, shadow, Po)\n    end\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"The new method for the boundaryHeatTransferRate is the same as the method use for the RecoatBoundary but without the lamp logic.","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"function Types.boundaryHeatTransferRate(T, i, p::RecoatCoolBoundary)\n    shadow = p.shadow[i[2]]\n    eₗ = p.eₗ[i]\n    return (\n        convectionFlow(T, p.airTemp, p.h) +\n        radiationFlow(T, p.surfaceTemp, p.ε) * (shadow || (1 - p.Po)) +\n        radiationFlow(T, p.overheadTemp, p.ε) * !shadow * p.Po\n    )\nend","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"Have a look at A Cooling Recoat Load and Load Set to see how to use this in a load.","category":"page"},{"location":"howtos/howto_bound/#A-Cooling-Recoat-Return-Boundary","page":"Boundary Recipes","title":"A Cooling Recoat Return Boundary","text":"","category":"section"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"To make use of the above boundary, it would be handy to have a load that represents the recoat carriage returning to its initial position (going in the other direction to the above load).","category":"page"},{"location":"howtos/howto_bound/","page":"Boundary Recipes","title":"Boundary Recipes","text":"struct RecoatCoolReturnBoundary <: AbstractBoundary\n    overheadTemp::Float64\n    surfaceTemp::Float64\n    eₗ::Array{Float64,3}\n    ε::Float64\n    airTemp::Float64\n    h::Float64\n    shadow::Vector{Bool}\n    Po::Float64\n\n    function RecoatCoolReturnBoundary(pts, cts, prob::Problem, ls::Types.LoadStep)\n        param = prob.params\n        param.overheadTemp = overheadTemp = param.overheadHeatupFunc(0.0, param.overheadTemp, cts)\n\n        # We'll still call this, in case we want to use this boundary before the previous one\n        if isnan(param.coolStart)\n            coolingStart(pts.t, cts.t, param)\n        end\n\n        tAir = (cts.t - param.coolStart) + param.airCoolStart\n        tSurface = (cts.t - param.coolStart) + param.surfaceCoolStart\n        airTemp = param.airCool(tAir)\n        surfaceTemp = param.surfaceCool(tSurface)\n        eₗ = prob.eᵗ\n        ε = prob.matProp.ε\n        h = param.convectionCoef\n        Po = param.percentOverhead\n\n        # Calculate the position of the carriage on its return stroke\n        pos = ceil(Int, (param.carriageWidth + prob.geometry.Y_BUILD) * (1 - cts.tₚ))\n        shadowPos = (pos - param.carriageWidth, pos)\n        shadow = movingObjOverlap(prob.geometry, true, shadowPos)\n\n        # No need to run any of the recoat logic for this one\n        return new(overheadTemp, surfaceTemp, eₗ, ε, airTemp, h, shadow, Po)\n    end\nend\n\nfunction Types.boundaryHeatTransferRate(T, i, p::RecoatCoolReturnBoundary)\n    shadow = p.shadow[i[2]]\n    eₗ = p.eₗ[i]\n    return (\n        convectionFlow(T, p.airTemp, p.h) +\n        radiationFlow(T, p.surfaceTemp, p.ε) * (shadow || (1 - p.Po)) +\n        radiationFlow(T, p.overheadTemp, p.ε) * !shadow * p.Po\n    )\nend","category":"page"},{"location":"reference/solver/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"reference/solver/","page":"Solver","title":"Solver","text":"Solver","category":"page"},{"location":"reference/solver/#HSSSimulations.Solver","page":"Solver","title":"HSSSimulations.Solver","text":"The core logic for setting up and solving a simulation, including the heat transfer solver.\n\n\n\n\n\n","category":"module"},{"location":"reference/solver/","page":"Solver","title":"Solver","text":"All the public functions in this module have been covered already in the main API section, and the Load Sets section.","category":"page"},{"location":"reference/solver/#Internal","page":"Solver","title":"Internal","text":"","category":"section"},{"location":"reference/solver/","page":"Solver","title":"Solver","text":"Solver.makeLogger","category":"page"},{"location":"reference/solver/#HSSSimulations.Solver.makeLogger","page":"Solver","title":"HSSSimulations.Solver.makeLogger","text":"makeLogger(debugGroups, logFile) -> LoggingExtras.TeeLogger\n\n\ndebugGroups is a list of groups of debug messages to log to the logFile. If it is set to true then all log groups in the package are used (see package_groups), if it is set to false then no log groups are used.\n\nUser log groups can be added to the list, simple add your own string to the list and then set debug messages with the _group field set to your string.\n\nThere is a special group called \"misc\" that will catch any group not in the package_groups list or in any additional group given by the user to the debugGroups list.\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#Load-Step-Solver","page":"Solver","title":"Load Step Solver","text":"","category":"section"},{"location":"reference/solver/","page":"Solver","title":"Solver","text":"Solver.loadSolver!","category":"page"},{"location":"reference/solver/#HSSSimulations.Solver.loadSolver!","page":"Solver","title":"HSSSimulations.Solver.loadSolver!","text":"loadSolver!(\n    ls::HSSSimulations.Types.LoadStep,\n    results,\n    prob::Problem\n) -> AbstractResult\n\n\nSolves a single load and returns an array of the results.\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#Time-Step-Solver","page":"Solver","title":"Time Step Solver","text":"","category":"section"},{"location":"reference/solver/","page":"Solver","title":"Solver","text":"Solver.timeSolver!\nSolver.nanfiller!\nSolver.fdmSolver!","category":"page"},{"location":"reference/solver/#HSSSimulations.Solver.timeSolver!","page":"Solver","title":"HSSSimulations.Solver.timeSolver!","text":"timeSolver!(\n    cts::AbstractResult,\n    pts::AbstractResult,\n    ls::HSSSimulations.Types.LoadStep,\n    prob::Problem\n)\n\n\nSolves a timestep by calculating new material propeties, setting ghost node boundary conditions, using an explicit finited difference method and then conditionally recoating the poweder (if the load specifies). The results are stored in the Results struct cr that is passed into the function.\n\nArguments\n\ncts : The struct that will be used to store the results from this solver.\npts : The results struct with the results from the previous step.\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#HSSSimulations.Solver.nanfiller!","page":"Solver","title":"HSSSimulations.Solver.nanfiller!","text":"nanfiller!(cts, indᵢ)\n\n\nFills non real cells with NaNs instead of the undef value there currently. Using NaN instead of zero both allows for a check to see if the cell has been initialised and makes them not show up in plots.\n\nThis needs to be called on all loads (not just recoat loads) as on the loads before recoat there are still imaginary nodes that need filling (for pretty plotting).\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#HSSSimulations.Solver.fdmSolver!","page":"Solver","title":"HSSSimulations.Solver.fdmSolver!","text":"fdmSolver!(cts, indᵣ, p)\n\n\nUses the explicit time step finite difference heat form of the heat equation to calculate the new results using ghost cell boundary conditions.\n\nIn simple terms this takes the avarage for all nodes for the one around the one being calculated (from the previous time step), and uses the difference between that and the temperature of the current node (for the previous time step) multiplied by the fourier number Fo to calculate the temperature of that node for the current timestep. This is done for all nodes. As ghost nodes are used, this function is the same for all nodes and doesn't need special logic for boundary nodes.\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#Metadata-Saving","page":"Solver","title":"Metadata Saving","text":"","category":"section"},{"location":"reference/solver/","page":"Solver","title":"Solver","text":"Solver.startMetadata\nSolver.finishMetadata\nTypes.makeDescription","category":"page"},{"location":"reference/solver/#HSSSimulations.Solver.startMetadata","page":"Solver","title":"HSSSimulations.Solver.startMetadata","text":"startMetadata(problem, file)\n\n\nAdds metadata to the results file. The data added here is stuff that is available at the start of the simulation, such as the problem description, the problem input and the start time.\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#HSSSimulations.Solver.finishMetadata","page":"Solver","title":"HSSSimulations.Solver.finishMetadata","text":"finishMetadata(problem::Problem, file)\n\n\nAdds metadata to the results file. The data added here is stuff that is not available until the end of the simulation, such as the melt max array, the results index array and the simulation end time.\n\n\n\n\n\n","category":"function"},{"location":"reference/solver/#HSSSimulations.Types.makeDescription","page":"Solver","title":"HSSSimulations.Types.makeDescription","text":"makeDescription(problem::Problem) -> Any\n\n\nPrimaraly used for the show method for the Problem struct, but seperated into it's own function so the same formatting can be used for making a string to save to the results file. This is useful for having a summary of the simulation setup attached to the results for quick reference (The full problem struct is also saved, but that requires loading the results in a julia instance to read properly).\n\n\n\n\n\n","category":"function"},{"location":"howtos/howto_intro/#Recipes-Introduction","page":"Recipes Introduction","title":"Recipes Introduction","text":"","category":"section"},{"location":"howtos/howto_intro/","page":"Recipes Introduction","title":"Recipes Introduction","text":"Unlike the tutorials provided, these recipes are not step-by-step directions, but instead they are chunks of code that can be used to do a thing. These can either be used directly if the thing they do is what you want to do, or they can be used as inspiration to do something similar to what the recipe does.","category":"page"},{"location":"howtos/howto_intro/#Recipes","page":"Recipes Introduction","title":"Recipes","text":"","category":"section"},{"location":"howtos/howto_intro/","page":"Recipes Introduction","title":"Recipes Introduction","text":"Pages = [basename(x) for x in Main.recipe_pages[2:end]]\nDepth=2","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"EditURL = \"../../lit/full_tut.jl\"","category":"page"},{"location":"tutorials/1_full_tut/#Tutorial-1:-Full-Build","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"","category":"section"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"using HSSSimulations","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"This tutorial will cover how to create a simulation problem, solve it, and inspect the results. It differs from the Tutorial 2: Warm-up and Cool-down only (which I will assume you have gone through) by actually trying to simulate part of a printer build, instead of a contrived situation. This means we'll have preheat loads, layers being added and complex boundary conditions. Whilst the simulation is more complicated, some setup is actually easier, as this is what the package was built for.","category":"page"},{"location":"tutorials/1_full_tut/#Defining-the-Problem","page":"Tutorial 1: Full Build","title":"Defining the Problem","text":"","category":"section"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"Like before, we'll start by defining the geometry:","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"geometry = Geometry(\n    (0.016, 0.016, 0.0122),\n    0.001,\n    1.5e-3;\n    Δz=0.003 / 90,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers\",\n)","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"There are some additional arguments given here, let's go over them quickly. In the basic simulation we specified the node spacing as the second argument, and this specified the spacing in all three axis. Here we add a Δz argument, when this is given it overrides the node spacing for this one axis. This is useful as we want the spacing in the z-axis to be the same as the layer height, but using the same spacing in all axes would limit the size of the simulation. This leads nicely on to Δh, which is the layer thickness in meters (100 microns in this case).","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"note: Note\nA Δy argument can also be given to override the node spacing in the y-axis. There is no equivalent for the x-axis, instead just give the desired spacing as the default and use the Δz and Δy overrides to get the desired spacing.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"The last two are the buildSize and offset. It is often useful to simulate a subset of the build volume (mostly for memory and computational cost reasons), to do this we can specify the true size of the machine (buildSize) and where the simulation sits within it (offset). Both of these are given in meters.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"We'll use the other built-in material this time, a version of the PA2200 material used before that has the rate of change of consolidation state dependent on more than just temperature.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"material = PA2200(geometry)","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"This time around we can just use the load sets provided by HSSLoads, without having to muck about with it ourselves. Here we define the skip (in this case lets go for 10), and a few extra key word arguments that decide how many preheat and cooldown loads to have, along with how long they should be (so preheat time in this case is 90x10, for 900 seconds total).","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"note: Note\nMultiple short loads are used in cases where the load case stays the same for a while. The solver only saves results from memory to disk in between loads, so splitting it up reduces the memory requirement (at the cost of a slight increase in computational cost).","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"params = HSSParams(geometry)\nloadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"When we specify the initial results, we'll also specify the initialLayer, this will be used to tell the simulation how many layers worth of powder should be already deposited at the start of the simulation. Theses are the layers that will be simulated during the preheat load set.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"geomsize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(geomsize, 25.0, 0.0, 0.0)\ninitialLayer = 30","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"The Ink struct for this problem is going to have some actual ink in it. To do this we will fill a subset of the inkArray with a value of 1.0 this is making the assumption that our ink is a perfect absorber of our lamp's energy. And we'll also change the name of the Ink to represent this.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"inkArray = fill(material.eₚ, size)\ninkArray[5:end-4, 5:end-4, 90:end-30] .= material.eᵢ\nink = Ink(inkArray, \"Sample square\")","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"And like before we will give the problem a name and description and then create it.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"file = \"full_build_simulation_tutorial.jld2\"\ndescription = \"A full simulation of a sample square\"\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    preheatLoads=preheatLoads,\n    buildLoads=buildLoads,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    description=description,\n)","category":"page"},{"location":"tutorials/1_full_tut/#Solving-the-Problem","page":"Tutorial 1: Full Build","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"Like before, this part is simple for you. But now it is even more complicated for the computer.","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"resultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"tip: Performance Tips\nThe simulation will only run on one proccessor, but will run on as many threads as you can give it. So if you haven't already, try starting juila with the --threads=auto flag to give the simulation more threads to work with. If you are using a notebook you will need to look into how to make a kernel that uses multiple threads.If it is still running too slow you can try playing around with the geometry sizes, the x and y-axis node spacing or the time step (just be aware that changing node spacing and time step can lead to unstable simulations, normally resultsing in an out of bounds error). And if you run into memory issues you can try increasing the value of skip (Why We Skip Some Results).","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"","category":"page"},{"location":"tutorials/1_full_tut/","page":"Tutorial 1: Full Build","title":"Tutorial 1: Full Build","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/hssbound/#HSS-Boundary","page":"HSS Boundary","title":"HSS Boundary","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound","page":"HSS Boundary","title":"HSSSimulations.HSSBound","text":"All additional boundary conditions requried to simulate a HSS build that are not already included in Boundary.\n\nThe main two exports of this module are HSSParams and HSSLoads, which combined create everything needed to simulate the boundaries of a standard HSS build. Each load used by HSSLoads and some additional utilities are also exported to allow for more custom builds to be setup.\n\n\n\n\n\n","category":"module"},{"location":"reference/hssbound/#Parameters","page":"HSS Boundary","title":"Parameters","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSParams","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.HSSParams","page":"HSS Boundary","title":"HSSSimulations.HSSBound.HSSParams","text":"mutable struct HSSParams{T1, T2, T3, T4, T5, T6, T7, T8} <: AbstractProblemParams\n\nThe parameter struct for a standard HSS build. This is intended to proved the required parameters for the load sets produced by HSSLoads.\n\nSee HSSParams for the default constructor.\n\nnote: Note\nIf the fields below are not documented correctly in whatever method you are using to view this documentation, try looking directly at the source code.\n\nFields\n\nname::String\npistonHeat::Any\npistonCool::Any\nconductionCoef::Float64\nairHeat::Any\nairCool::Any\nconvectionCoef::Float64\nsurfaceHeat::Any\nsurfaceCool::Any\npowderTemp::Any\nsinterLamp::Vector{Float64}\nrecoatLamp::Vector{Float64}\nlampWidth::Int64\nlampOffset::Int64\ncarriageWidth::Int64\nprintCarriageWidth::Int64\nprintOffset::Int64\nrecoatOffset::Int64\nsurfaceTarget::Float64\nsurfaceTol::Float64\noverheadHeatupFunc::Any\noverheadLayerStep::Int64\noverheadPowerStep::Float64\noverheadMaxPower::Float64\npercentOverhead::Float64\noverheadPower::Float64: Current power input of overhead heaters, in watts\noverheadTemp::Float64: Current temperature of overhead heaters, in °C\nlastUpdatedOverhead::Int64: The last layer the overheads were updated on\ncoolStart::Float64: The time at the start of cooling loads, in seconds since the start of the build\npistonCoolStart::Float64: The offset time if the piston wasn't at max temp at start of cooling, in seconds after the start of the piston cooldown curve\nairCoolStart::Float64: The offset time if the air wasn't at max temp at start of cooling, in seconds after the start of the air cooldown curve\nsurfaceCoolStart::Float64: The offset time if the machine's internal suraface wasn't at max temp at start of cooling, in seconds after the start of the surface cooldown curve\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#No-Carriage-Loads","page":"HSS Boundary","title":"No Carriage Loads","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.loadOverheads\nHSSBound.loadCooldown","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.loadOverheads","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadOverheads","text":"loadOverheads(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns a load that represents the case where there are no carriages over top the powder bed, and the overhead and piston heaters are both on. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.OverheadsBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.loadCooldown","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadCooldown","text":"loadCooldown(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns a load that represents the case where there are no carriages over top the powder bed, and the overhead and piston heaters have both been turned off. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.OverheadsCoolBoundary and HSSBound.PistonCoolBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides. It assumes that once cooling starts it doesn't stop.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#Piston-Boundaries","page":"HSS Boundary","title":"Piston Boundaries","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.AbstractPistonBoundary\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.AbstractPistonBoundary)\nHSSBound.PistonBoundary\nHSSBound.PistonBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.PistonCoolBoundary\nHSSBound.PistonCoolBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.AbstractPistonBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.AbstractPistonBoundary","text":"abstract type AbstractPistonBoundary <: AbstractBoundary\n\nAn abstract type, all subtypes of which can use the same boundary heat transfer rate function, but can have their own constructors.\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractPistonBoundary}","page":"HSS Boundary","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(\n    T,\n    _,\n    p::HSSSimulations.HSSBound.AbstractPistonBoundary\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.PistonBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.PistonBoundary","text":"struct PistonBoundary <: HSSSimulations.HSSBound.AbstractPistonBoundary\n\nBoundary for the bottom surface of a HSS build for loads where the heater is turned on. This boudnary assumes that the piston maintains a constant temperature at after the initial heat up.\n\nFields\n\npiston::Float64: Piston temperature\nh::Float64: Contact conduction coefficient\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.PistonBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.PistonBoundary","text":"PistonBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    _::HSSSimulations.Types.LoadStep\n) -> PistonBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.PistonCoolBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.PistonCoolBoundary","text":"struct PistonCoolBoundary <: HSSSimulations.HSSBound.AbstractPistonBoundary\n\nBoundary for the bottom surface of a HSS build for cooldown loads. This boundary assumes that once cooling starts it doesn't stop.\n\nFields\n\npiston::Float64: Piston temperature\nh::Float64: Contact conduction coefficient\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.PistonCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.PistonCoolBoundary","text":"PistonCoolBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    _::HSSSimulations.Types.LoadStep\n) -> PistonCoolBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#Overhead-Boundaries","page":"HSS Boundary","title":"Overhead Boundaries","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.AbstractOverheadsBoundary\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.AbstractOverheadsBoundary)\nHSSBound.OverheadsBoundary\nHSSBound.OverheadsBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}\nHSSBound.OverheadsCoolBoundary\nHSSBound.OverheadsCoolBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.AbstractOverheadsBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.AbstractOverheadsBoundary","text":"abstract type AbstractOverheadsBoundary <: AbstractBoundary\n\nAn abstract type, all subtypes of which can use the same boundary heat transfer rate function, but can have their own constructors.\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, HSSSimulations.HSSBound.AbstractOverheadsBoundary}","page":"HSS Boundary","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(\n    T,\n    _,\n    p::HSSSimulations.HSSBound.AbstractOverheadsBoundary\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.OverheadsBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.OverheadsBoundary","text":"struct OverheadsBoundary <: HSSSimulations.HSSBound.AbstractOverheadsBoundary\n\nBoundary for the top surface of a HSS build with no lamp or print carriage movement. This boundary assumes the heater controller is the same as our HSS machine where It only updates the overhead power every overheadLayerStep number of layers, and only once on that layer.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.OverheadsBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.OverheadsBoundary","text":"OverheadsBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> OverheadsBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.OverheadsCoolBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.OverheadsCoolBoundary","text":"struct OverheadsCoolBoundary <: HSSSimulations.HSSBound.AbstractOverheadsBoundary\n\nLike the OverheadsBoundary but it sets the overhead power to 0w (turning it off). This boundary assumes that once cooling starts it doesn't stop.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.OverheadsCoolBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.OverheadsCoolBoundary","text":"OverheadsCoolBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    _::HSSSimulations.Types.LoadStep\n) -> OverheadsCoolBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#Carriage-Loads","page":"HSS Boundary","title":"Carriage Loads","text":"","category":"section"},{"location":"reference/hssbound/#Sinter-Stroke","page":"HSS Boundary","title":"Sinter Stroke","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.loadSinterStroke\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.SinterBoundary)\nHSSBound.SinterBoundary\nHSSBound.SinterBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.loadSinterStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadSinterStroke","text":"loadSinterStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with recoat/lamp carriage over the build and the sinter lamp set to sinter power. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.SinterBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, SinterBoundary}","page":"HSS Boundary","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::SinterBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.SinterBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.SinterBoundary","text":"struct SinterBoundary <: AbstractBoundary\n\nBoundary for the top surface of a HSS build for when the recoat/lamp carriage is over the build bed and the lamp is set to sinter power.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\neₗ::Array{Float64, 3}: Net absorbtivity relative to lamp\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nlamp::Vector{Float64}: Sinter lamp array\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.SinterBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.SinterBoundary","text":"SinterBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> SinterBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#Recoating-Stroke","page":"HSS Boundary","title":"Recoating Stroke","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.loadRecoatStroke\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.RecoatBoundary)\nHSSBound.RecoatBoundary\nHSSBound.RecoatBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.loadRecoatStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadRecoatStroke","text":"loadRecoatStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with the recoat/lamp carriage over the build area, the lamp set to recoat power and new powder being deposited with the movement. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.RecoatBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, RecoatBoundary}","page":"HSS Boundary","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::RecoatBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.RecoatBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.RecoatBoundary","text":"struct RecoatBoundary <: AbstractBoundary\n\nBoundary for the top surface of a HSS build with the recoat/lamp carriage over the build area, the lamp set to recoat power and new powder being deposited.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\neₗ::Array{Float64, 3}: Net absorbtivity relative to lamp\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nlamp::Vector{Float64}: Sinter lamp array\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.RecoatBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.RecoatBoundary","text":"RecoatBoundary(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> RecoatBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#Printing-Stroke","page":"HSS Boundary","title":"Printing Stroke","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.loadInkStroke\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.InkBoundary)\nHSSBound.InkBoundary\nHSSBound.InkBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.loadInkStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadInkStroke","text":"loadInkStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with the print head carriage over the build volume depositing ink. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.InkBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, InkBoundary}","page":"HSS Boundary","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::InkBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.InkBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.InkBoundary","text":"Boundary for the top surface of a HSS build with the print head carriage over the build volume depositing ink.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.InkBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.InkBoundary","text":"InkBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> InkBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#Printhead-Shadow-Only-Stroke","page":"HSS Boundary","title":"Printhead Shadow Only Stroke","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.loadBlankStroke\nHSSBound.boundaryHeatTransferRate(::Any,::Any,::HSSBound.BlankBoundary)\nHSSBound.BlankBoundary\nHSSBound.BlankBoundary(::AbstractResult,::AbstractResult,::Problem{T,Gh,Mp,R,OR,B},::Types.LoadStep) where { T<:Any,Gh<:Any,Mp<:Any,R<:Any,OR<:Any,B<:Any}","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.loadBlankStroke","page":"HSS Boundary","title":"HSSSimulations.HSSBound.loadBlankStroke","text":"loadBlankStroke(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nReturns the compleate Types.Load struct for a HSS build with the print head carriage over the build area but not on the ink deposition stroke. This assumes that a subset of the build is being simulated and the the edge boundaries can be approximated as symetrical (no heat flow).\n\nUses HSSBound.BlankBoundary for the top surface, HSSBound.PistonBoundary for the bottom surface and the default Boundary.SymetryBoundary functions for the sides.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.Types.boundaryHeatTransferRate-Tuple{Any, Any, BlankBoundary}","page":"HSS Boundary","title":"HSSSimulations.Types.boundaryHeatTransferRate","text":"boundaryHeatTransferRate(T, i, p::BlankBoundary) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.BlankBoundary","page":"HSS Boundary","title":"HSSSimulations.HSSBound.BlankBoundary","text":"struct BlankBoundary <: AbstractBoundary\n\nBoundary for the top surface of a HSS build with the print head carriage over the build area but not on the ink deposition stroke.\n\nFields\n\noverheadTemp::Float64: Temperatur of overhead heater\nsurfaceTemp::Float64: Temperatur of machine internal surface\nε::Float64: Black Body Emmissivity\nairTemp::Float64: Temperature of air above build bed\nh::Float64: Convection coefficient\nshadow::Vector{Bool}: Carriage shadow array\nPo::Float64: Weighting of overhead heaters vs raditiation loss\n\n\n\n\n\n","category":"type"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.BlankBoundary-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, HSSSimulations.Types.LoadStep}} where {T, Gh, Mp, R, OR, B}","page":"HSS Boundary","title":"HSSSimulations.HSSBound.BlankBoundary","text":"BlankBoundary(\n    _::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp, R, OR, B},\n    ls::HSSSimulations.Types.LoadStep\n) -> BlankBoundary\n\n\n\n\n\n\n","category":"method"},{"location":"reference/hssbound/#Utilities","page":"HSS Boundary","title":"Utilities","text":"","category":"section"},{"location":"reference/hssbound/","page":"HSS Boundary","title":"HSS Boundary","text":"HSSBound.lampMaker\nHSSBound.overheadTempFunc\nHSSBound.coolingStart","category":"page"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.lampMaker","page":"HSS Boundary","title":"HSSSimulations.HSSBound.lampMaker","text":"lampMaker(\n    lampVector::Vector,\n    lampWidth,\n    geometry::Geometry\n) -> Any\n\n\nReturns a vector of heat flux density coefficients representing the lamp, with the same node spacing as the simulation. The returned vector can be multiplied by the lamp power, in watts, to get a vector of heat flux densities of the lamp.\n\nArguments\n\nlampVector::Vector : A vector represeting the heat distribution of the lamp in the y axis\nlampWidth : The total width represented by the lamp vector (in the y axis, in nodes).\ngeometry::Geometry : The simulation geometry\n\nnote: Note\nIf the lamp width divided by the length of the lamp vector is not equal to the Δy then linear interpolation is used to fill in the values.\n\nwarn: Warn\nThis uses the Δx and Δy node spacings to calculate the area used to convert to heat flux density, because of this it is only applicable to the z₁ and z₂ boundaries.\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.overheadTempFunc","page":"HSS Boundary","title":"HSSSimulations.HSSBound.overheadTempFunc","text":"overheadTempFunc(\n    powerIn,\n    powerOut,\n    overheadHeatCapacity,\n    Δt,\n    prevOverheadTemp\n) -> Any\n\n\nCalculates the new temperature of a an overhead heater that has a given power output and is set to a given power (powerIn) values.\n\nArguments\n\npowerOut : A function that takes the temperatu of the heater and returns the power output\noverheadHeatCapacity : The heat capacity of the overhead heater\nprevOverheadTemp : The previous temperature of the overhead heaters\n\n\n\n\n\n","category":"function"},{"location":"reference/hssbound/#HSSSimulations.HSSBound.coolingStart","page":"HSS Boundary","title":"HSSSimulations.HSSBound.coolingStart","text":"coolingStart(tᵗ⁻¹, tᵗ, params::AbstractProblemParams)\n\n\nSets the time that the cooling starts, to be used to calculate how far into the cooling the simulation is during future time steps.\n\nIt also finds how far into the cooling curves of the different components to start based on the current temperature of that component. If the current temperature is less than any temperature in the cooling curve it will default to starting at the end of the curve.\n\nThis requires the type of pistonCool, airCool and surfaceHeat have methods for findfirst\n\n\n\n\n\n","category":"function"},{"location":"reference/adv_intro/#Advanced-API-Introduction","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"","category":"section"},{"location":"reference/adv_intro/","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"This section covers the reference documentation for all things not included in the main API, split into the package's modules. The first part of each modules documentation contains the documentation for the external 'advanced' API, these are things that are intended for use to extend customise simulations beyond the default behaviour. The second part are the internal functions not intended for external use.","category":"page"},{"location":"reference/adv_intro/","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"The external APIs are exported by their module, but not exported by the package, so to use them you will need to either use their full address:","category":"page"},{"location":"reference/adv_intro/","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"using HSSSimulations\nSolver.loadSetSolver!","category":"page"},{"location":"reference/adv_intro/","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"or by using the module it is in:","category":"page"},{"location":"reference/adv_intro/","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"using HSSSimulations\nusing .Solver\nloadSetSolver!","category":"page"},{"location":"reference/adv_intro/#Modules","page":"Advanced API Introduction","title":"Modules","text":"","category":"section"},{"location":"reference/adv_intro/","page":"Advanced API Introduction","title":"Advanced API Introduction","text":"Pages = [basename(x) for x in Main.api_pages[3:end]]\nDepth=2","category":"page"},{"location":"howtos/howto_ink/#Ink-Pattern-Recipes","page":"Ink Pattern Recipes","title":"Ink Pattern Recipes","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"EditURL = \"../../lit/material_tut.jl\"","category":"page"},{"location":"tutorials/3_material_tut/#Tutorial-3:-A-Melt-Rate-Based-Material-Model","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"using HSSSimulations","category":"page"},{"location":"tutorials/3_material_tut/#Overview","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Overview","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"This tutorial will cover how to implement the time dependent melt state model introduced in my thesis. To do this, this tutorial builds on top of the full build tutorial by adding a new material property type.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"This is a proposed solution for the poor results of the melt state results found in my thesis is to model the melt state similarly to how the default material model treats the Consolidation state, making it time dependent. This has not been implemented as the default model as I don't currently have the required data, but if you have the data then you can use this implementation (my thesis should include an idea for how to get the data).","category":"page"},{"location":"tutorials/3_material_tut/#Making-the-Material-Property-Struct","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Making the Material Property Struct","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"First up is the addition of a new material property struct and constructor. This is the same as the default one with the only change being the name (for dispatch reasons), and changing the Mᵣ and Rᵣ fields to Ṁ and Ṙ.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"struct MatPropTD{T1,T2,T3,T4,T5,T6,T7,T8,T9} <: Types.AbstractMatProp\n    ρ::T1\n    c::T2\n    κ::T3\n    \"\"\" Melting rate to temp and melt state relationship.\n    A 2d interpolation, with the first input axis being the temperature and the\n    second the current melt state. The output is the melt rate.\n    \"\"\"\n    Ḟ::T4\n    \"\"\" Crystallisation rate to temp, melt state and maximum melt state relationship.\n    A 3d interpolation, with the first input axis being the node temperature,\n    the second the current melt state and the third the maximum melt state\n    reached. The output is the recrystalisation rate.\n    \"\"\"\n    Ṙ::T5\n    Hf::T6\n    Hr::T7\n    Ċ::T8\n    eₚ::Float64\n    eᵢ::Float64\n    ε::Float64\n    name::String\n    Mₘ::T9\nend","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"As well as copying the old type, we'll also copy its constructor, to give us a more convineient way of constructing it from our experimental data. Again, this is the same as before, just with a change of name.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"function MatPropTD(ρ, c, κ, Ṁ, Ṙ, Hf, Hr, Ċ, eₚ, eᵢ, ε, name, geometry)\n    geomSize = (geometry.X, geometry.Y, geometry.Z)\n    Mₘ = zeros(geomSize)\n\n    return MatPropTD{\n        typeof(ρ),typeof(c),typeof(κ),\n        typeof(Ṁ),typeof(Ṙ),typeof(Hf),typeof(Hr),\n        typeof(Ċ),typeof(Mₘ),\n    }(\n        ρ, c, κ,\n        Ṁ, Ṙ, Hf, Hr,\n        Ċ,\n        eₚ, eᵢ, ε,\n        name, Mₘ,\n    )\nend","category":"page"},{"location":"tutorials/3_material_tut/#Adding-The-New-Logic","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Adding The New Logic","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"Now we have the new type, we can use it with julia's multiple dispatch to change what method is called when the simulation goes to update the melt state. This is done by making a new method for Material.meltUpdate that specifies our new type in place of the default MatProp type. Refer to my thesis if you would like an explanation as to what has changed here from the default method.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"function Material.meltUpdate(Mᵗ⁻¹, T, Mₘ, Δt, mp::MatPropTD)\n    ṀF = mp.Ḟ(T, Mᵗ⁻¹)\n    ṀR = mp.Ṙ(T, Mᵗ⁻¹, Mₘ)\n\n    if ṀF > -ṀR\n        ΔM = ṀF * Δt\n        ΔH = ΔM * mp.Hf\n    else\n        ΔM = ṀR * Δt\n        ΔH = ΔM * mp.Hr(Mₘ)\n    end\n    Mᵗ = clamp(Mᵗ⁻¹ + ΔM, 0, 1)\n    Mₘ = max(Mᵗ, Mₘ)\n\n    return Mᵗ, Mₘ, Δh\nend","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"If we needed more arguments to be passed in to this function, or wanted to change other properties of the material model, we could define a new method for Material.calcMatProps!. For an example of this, you can check out A Basic Material Model. Material.consUpdate is also dispatched on the material property struct, so that can also be modified sepreatly without having to rewrite the entire material model.","category":"page"},{"location":"tutorials/3_material_tut/#Making-a-New-Material","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Making a New Material","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"We'll use PA2200 as our material, using most of the values from the default type. The only changes will be our two melt rate relationship fields. To fill in the values for these fields we'll use interpolated arrays, so first lets add the interpolations package:","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"using Interpolations","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"Then we can use this to create a 2D interpolation for Ṁ that does what we said we want it to do.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"note: Note\nThe data presented here is totally fictional and should be replaced with actual data.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"To do this you will need the values corrisponding to the inputs of the data, so for example if we recorded the melt rate at temperatures of 170°C, 180°C and 190°C then we could define","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"melt_temps = [170, 180, 190]","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"And if we made those measurements at melt states of 0 and 1","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"melt_state = [0, 1]","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"We can then define the outputs, what the value of the melt rates measured for each of those states, where the x-axis of the array is the temperature and the y-axis is the melt state. So for this example, we have a melt rate of 0.03 at M=0 at a temperature of 190°C.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"melt_rate = [\n    0 0.02 0.03\n    0 0.01 0.02\n]","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"Then we can use these to make the linear interpolation that will be used in the simulation. Where the first argument is a tuple of our inputs and the second is our outputs. The key word argument defines how the values should be extrapolated if an input is given outside of the range of the inputs we've provided. Check out the Interpolations.jl docs for more info on these.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"PA_Ṁ = linear_interpolation(\n    (melt_temps, melt_state),\n    melt_rate;\n    extrapolation_bc=Flat(),\n)","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"You can test out what this does by trying to index into it with values other than those given, it should return values linearly interpolated between the ones you gave.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"PA_Ṁ[175, 0.5]","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"Then we can do a similar thing for the recrystalisation rate. Although here we need an extra input, the maximum melt state that was reached before recrystalisation began.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"recryst_temps = [150, 180]\nmelt_state = [0, 1]\nmelt_max = [0, 1]","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"And because we have an extra input, the output needs to have an extra dimension. The triple semicolon is used to concatinate in the 3rd dimension. So the 2×2 array befor the triple semicolon is the melt rate for a melt max of 0 and the one after is for a melt max of 1.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"recryst_rate = [\n    0.1 0;\n    0.5 0\n    ;;;\n    0.2 0;\n    0.8 0\n]\n\nPA_Ṙ = linear_interpolation(\n    (recryst_temps, melt_state, melt_max),\n    recryst_rate;\n    extrapolation_bc=Flat(),\n)","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"And like before, we can gives this a go.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"PA_Ṙ[160, 0.2, 0.733]","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"And finally this can all go together to make our material, but like before we need to make a geometry to pass in to the material propetry constructor.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"geometry = Geometry(\n    (0.016, 0.016, 0.0122),\n    0.001,\n    1.5e-3;\n    Δz=0.003 / 90,\n    Δh=0.0001,\n    offset=(0.0925, 0.1425),\n    buildSize=(0.200, 0.300),\n    name=\"30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers\",\n)\n\nmaterial = MatPropTD(\n    Material.PA_ρ(),\n    Material.PA_c(),\n    Material.PA_κ(),\n    PA_TD_M,\n    PA_TD_R,\n    Material.PA_Hf(),\n    Material.PA_Hr(),\n    Material.PA_Ċ,\n    Material.PA_eₚ,\n    Material.PA_eᵢ,\n    Material.PA_ε,\n    \"Time dependent PA2200\",\n    geometry,\n)","category":"page"},{"location":"tutorials/3_material_tut/#The-Rest-of-the-Setup","page":"Tutorial 3: A Melt Rate Based Material Model","title":"The Rest of the Setup","text":"","category":"section"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"From here on it's just the same as our other simulations.","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"params = HSSParams(geometry)\nloadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)\n\nsize = (geometry.X, geometry.Y, geometry.Z)\ninit = Result(size, 25.0, 0.0, 0.0)\ninitialLayer = 10\n\ninkArray = fill(material.eₚ, size)\ninkArray[5:end-4, 5:end-4, 60:end-10] .= material.eᵢ\nink = Ink(inkArray, \"Sample square\")\n\nfile = \"material_model_tutorial.jld2\"\ndescription = \"A simulation to test a time dependent melt model\"\n\nproblem = Problem(;\n    geometry=geometry,\n    matProp=material,\n    params=params,\n    preheatLoads=preheatLoads,\n    buildLoads=buildLoads,\n    cooldownLoads=cooldownLoads,\n    init=init,\n    initLay=initialLayer,\n    ink=ink,\n    file=file,\n    description=description,\n)\n\nresultFile, finalResults = problemSolver(problem)","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"","category":"page"},{"location":"tutorials/3_material_tut/","page":"Tutorial 3: A Melt Rate Based Material Model","title":"Tutorial 3: A Melt Rate Based Material Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/intro-pdf/#Tutorial-Introduction","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"","category":"section"},{"location":"tutorials/intro-pdf/#How-to-start","page":"Tutorial Introduction","title":"How to start","text":"","category":"section"},{"location":"tutorials/intro-pdf/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"There are different ways to use the tutorials:","category":"page"},{"location":"tutorials/intro-pdf/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"Reading the pdf version of the tutorials. This is the recommended way if you want rapid access to the material with no setup steps. Simply click in one of the links below.\nRunning the Jupyter notebooks locally. A working installation of Julia in the system is required.","category":"page"},{"location":"tutorials/intro-pdf/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"There are two additional ways to view the tutorials that are only available when viewing the web version of the documentation.","category":"page"},{"location":"tutorials/intro-pdf/#Tutorials","page":"Tutorial Introduction","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/intro-pdf/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"Pages = [basename(x) for x in Main.tut_pages[2:end]]\nDepth=1","category":"page"},{"location":"explanation/faqs/#FAQs","page":"FAQs","title":"FAQs","text":"","category":"section"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"Well, no-one has actually asked me questions, but I imagine this is what people might ask.","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"tip: Tip\nFor more in-depth explanations on anything, or for anything not covered here, you might be able to find more detailed answers in my thesis. Worst case, try emailing me.","category":"page"},{"location":"explanation/faqs/#Why-We-Skip-Some-Results","page":"FAQs","title":"Why We Skip Some Results","text":"","category":"section"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"The underlying solver used is an explicit time finite difference solver. This is used as it is very cheap per time step solved (and things like the complex boundaries and the material model work best with lots of time steps), however it does have the issue of requiring lots of time steps to be stable.","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"While the quantity and computational cost sort of balance out to make it take a reasonable time to solve, there is an issue that is caused by the solver choice. As there are lots of time steps, this means there are lots of results, and trying to find space for all of these is challenging.","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"To prevent the results files from filling up all your hard drive or from crashing the simulation due to a lack of available memory, a skip parameter was introduced. This parameter defines how often we want to save the results, with a value of 1 not skipping any results, 2 only saving every second result, 3 saving every third result and so on, the rest are thrown away as soon as they are done with (after the following load).","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"It might seem a little strange to throw away results from a simulation, but as long as you don't make the skip too big you will see that very little useful information is lost.","category":"page"},{"location":"explanation/faqs/#Why-Use-Explicit-Time-Finite-Difference-Method","page":"FAQs","title":"Why Use Explicit Time Finite Difference Method","text":"","category":"section"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"Yeah I know, it's not the flashiest technique ever, and originally I only used it to make a quick proof of concept as it is so easy to implement (of this entire codebase, only about 6 lines of it are the actual FDM solver).","category":"page"},{"location":"explanation/faqs/","page":"FAQs","title":"FAQs","text":"However, the more I tried to move away from it the more I realised it might actually be the best method to use.","category":"page"},{"location":"tutorials/intro/#Tutorial-Introduction","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"","category":"section"},{"location":"tutorials/intro/#How-to-start","page":"Tutorial Introduction","title":"How to start","text":"","category":"section"},{"location":"tutorials/intro/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"There are different ways to use the tutorials:","category":"page"},{"location":"tutorials/intro/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"[Recommended] Reading the html version of the tutorials. This is the recommended way if you want rapid access to the material with no setup steps. Simply click in one of the links below.\n[Recommended] Running the Jupyter notebooks locally. A working installation of Julia in the system is required.\nRunning the notebook remotely via binder. In that case, go to the desired tutorial and click the icon (Image: binder icon). No local installation of Julia needed.\nReading a non-interactive version of the notebook via nbviewer. In that case, go to the desired tutorial and click the icon (Image: nbviewer icon)","category":"page"},{"location":"tutorials/intro/#Tutorials","page":"Tutorial Introduction","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/intro/","page":"Tutorial Introduction","title":"Tutorial Introduction","text":"Pages = [basename(x) for x in Main.tut_pages[2:end]]\nDepth=1","category":"page"},{"location":"reference/api/#Main-API","page":"Main API","title":"Main API","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"DocTestSetup = quote\n    using HSSSimulations\nend","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"This page covers the basic API used for running simple simulations. Each section will also link to the relevant advanced API that can be used to further customise the behaviour of that part of the simulation. See Advanced API Introduction for more information on how to use the advanced API.","category":"page"},{"location":"reference/api/#main_api_solver","page":"Main API","title":"Solver","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"problemSolver\nProblem(; kwargs...)","category":"page"},{"location":"reference/api/#HSSSimulations.Solver.problemSolver","page":"Main API","title":"HSSSimulations.Solver.problemSolver","text":"problemSolver(problem::Problem) -> Tuple{Any, Any}\n\n\nThe main function that is called to solve a simulation and the struct that defines the problem to simulate.\n\nTakes a fully defined problem and solves it, saving the solution to disk and returning the filename where it is saved. See Problem for how to define the problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#HSSSimulations.Types.Problem-Tuple{}","page":"Main API","title":"HSSSimulations.Types.Problem","text":"Problem(\n;\n    geometry,\n    matProp,\n    params,\n    loadSets,\n    init,\n    file,\n    initLay,\n    ink,\n    description,\n    otherResults,\n    options\n)\n\n\nAssemble a problem out of its components.\n\nArguments\n\ngeometry::Geometry: See Simulation Geometry\nmatProp::AbstractMatProp: See Materials\nparams::AbstractProblemParams: See Boundary Parameters\nloadSets::Vector{AbstractLoadSet}: The list of load sets to simulate, in order   that the need simulating. See Boundary Loads\nink::Ink: The locations for ink deposition. This should be the same size as the   finial dimension of the simulation. See Ink Struct\ninit::AbstractResult: The initial results struct. This should be the same size   as the finial dimension of the simulation. See Time Step Results\ninitLay::Int: The thickness of powder deposited before the simulation starts, given in   number of layers thick. This must be greater than zero\nfile::String: The file path and name for the output file of the simulation\ndescription::String=\"\": A short description of what is being simulated\notherResults::AbstractOtherResults=OtherResults(): The struct to   save the final results to. See Other Results\noptions::Options=Options(): The options to use for the simulation. See   Settings\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Simulation-Geometry","page":"Main API","title":"Simulation Geometry","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Geometry(::Any,::Any,::Any)","category":"page"},{"location":"reference/api/#HSSSimulations.Types.Geometry-Tuple{Any, Any, Any}","page":"Main API","title":"HSSSimulations.Types.Geometry","text":"Geometry(\n    simSize, Δx, Δt;\n    Δy=Δx, Δz=Δx, name=\"NA\", Δh=0,\n    offset=(0.0, 0.0), buildSize=nothing,\n    force=false,\n)\n\nConstructor for the Geometry type that is is used to store all of the geometry information (and time step length for some reason) for a rectangular build volume of the machine being simulated (given as the buildSize). It also saves the information for the subset of the build volume to actually be simulated (of size simSize, offset form the machine origin by offset), if the full build volume is not being simulated. If no buildSize is given then it is assumed to be just big enougth to fit the simSize with the given offset.\n\nΔh is the layer height in meters. If it is given as 0 (or not given) then it is assumed that the simulation isn't representing a full build, but instead something like the preheat or cooldown phase. In this case no layer recoat logic can be run (make sure not to include a recoating Types.Load).\n\nΔt is the time step (in seconds) and Δx, Δy and Δz are the node spacing (in meters). If not given then Δy and Δz default to the same as Δx. The timestep is included in the geometry as it is tied to the node spacing when it comes to making a stable simulation for the explicit finite difference method used in this model.\n\nIf the force argement is given then the divisible errors will be suppressed, this will result in the geometry not being properly represented.\n\ndanger: Use With Caution\nUse the force argument with great caution. It was only added to allow for the creation of geometries that were blocked due to floating point math errors. If it is used when things aren't actually divisible then it will result in the geometry not being properly represented, and a disconnect between what you think you are simulating and what is actually being simulated.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Ink-Struct","page":"Main API","title":"Ink Struct","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Ink","category":"page"},{"location":"reference/api/#HSSSimulations.Types.Ink","page":"Main API","title":"HSSSimulations.Types.Ink","text":"struct Ink{T}\n\nDefines the volume of the ink placement within that (and therefore hopefully the part to be made). See Ink Pattern Recipes for some example patterns.\n\nFields\n\nnodes::Array{T, 3} where T: The emmisivity of the models nodes, set to eₚ for nodes without ink.\nname::String: Just used for future reference of results\n\nThis is the emmisivity relative to the lamp. So the emmisivity of the ink over the range of the wavelengths that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Materials","page":"Main API","title":"Materials","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"PA2200","category":"page"},{"location":"reference/api/#HSSSimulations.Material.PA2200","page":"Main API","title":"HSSSimulations.Material.PA2200","text":"PA2200(\n    geometry::Geometry\n) -> MatProp{Interpolations.Extrapolation{Float64, 2, Interpolations.ScaledInterpolation{Float64, 2, Interpolations.BSplineInterpolation{Float64, 2, Matrix{Float64}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Tuple{UnitRange{Int64}, UnitRange{Int64}}}, Interpolations.BSpline{Interpolations.Linear{Interpolations.Throw{Interpolations.OnGrid}}}, Interpolations.Flat{Nothing}}, _A, _B, _C, _D, _E, _F, typeof(PA_Ċ), Array{Float64, 3}} where {_A, _B, _C, _D, _E, _F}\n\n\nAn example material based on EOS's PA2200, using a rate of consolidation based on melt state. With eyeball correction to consolidation rate. Calling this with the Geometry struct to be used for the simulation as the only argument will return the relevant MatProp struct.\n\nThe sources of the data used are summarized in PA2200. For more details, check the material model chapter of my thesis.\n\nThis is one example material. To see how to define new materials or new material models, see Material Model.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Time-Step-Results","page":"Main API","title":"Time Step Results","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Result\nResult(::Any,::Any,::Any,::Any)\nResult(::Any,::Any,::Any,::Any,::Any)\nResult(::Any,::Any,::Any)","category":"page"},{"location":"reference/api/#HSSSimulations.Results.Result","page":"Main API","title":"HSSSimulations.Results.Result","text":"struct Result{P<:AbstractArray} <: AbstractResult\n\nThe results from a single timestep, use directly to create the initial conditions. Also created for each time step during the simulation.\n\nThis saves the data from the default material model and the heat transfer solver. For information on how to create a new result struct see Time/Load Step Results.\n\nFields\n\nT::AbstractArray: Temperature for each node\nM::AbstractArray: Melt state for each node\nC::AbstractArray: Consolidation state for each node\nt::Float64: Time of timestep, since the start of the build\ntₚ::Float64: The progress through the load step (0=start, 0.5=half way, 1=end)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.Results.Result-NTuple{4, Any}","page":"Main API","title":"HSSSimulations.Results.Result","text":"Result(geomSize, Tᵢ, Mᵢ, Cᵢ) -> Result\n\n\nCreate a result with uniform fields\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#HSSSimulations.Results.Result-NTuple{5, Any}","page":"Main API","title":"HSSSimulations.Results.Result","text":"Result(geomSize, Tᵢ, Mᵢ, Cᵢ, t) -> Result\n\n\nCreate a result with uniform fields and a given time.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#HSSSimulations.Results.Result-Tuple{Any, Any, Any}","page":"Main API","title":"HSSSimulations.Results.Result","text":"Result(geomSize, t, tₚ) -> Result\n\n\nCreate an empty result. This is used during the simulation to create the results for each time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Other-Results","page":"Main API","title":"Other Results","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"These are results that are saved once at the end of the simulation, for when","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"The default final results struct shown below saves the maximum melt state from the default material model and nothing else. For information on how to create a new result struct see End of Simulation Results.","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"OtherResults","category":"page"},{"location":"reference/api/#HSSSimulations.Types.OtherResults","page":"Main API","title":"HSSSimulations.Types.OtherResults","text":"struct OtherResults <: AbstractOtherResults\n\nThe default struct stores no additional data and only acts as a placeholder. When used, the simulation will store the maximum melt state to Results folder of the output file and no other final results (time step results are still saved each load step).\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Boundary-Loads","page":"Main API","title":"Boundary Loads","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Two functions are provided below to create loads and load sets. The basicLoad function creates a single basic load that can be used with FixedLoadSet and LayerLoadSet to make load sets for the loadSets argument of the Problem. For information on how to make more loads, see Boundary Model.","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"The HSSLoads constructor creates a full list of load sets needed to simulate a typical HSS build. For more information on these loads, see HSS Boundary.","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"basicLoad\nFixedLoadSet\nLayerLoadSet\nHSSLoads","category":"page"},{"location":"reference/api/#HSSSimulations.Boundary.basicLoad","page":"Main API","title":"HSSSimulations.Boundary.basicLoad","text":"basicLoad(\n    tₗ,\n    skip\n) -> Load{SymetryBoundary, SymetryBoundary, SymetryBoundary, SymetryBoundary}\n\n\nA basic Types.Load with a conduction boundary on the bottom surface and a convection boundary on the top. All other surfaces are symetrical boundaries.\n\nExamples\n\njulia> loadStep = basicLoad(5, 2)\n  x₁ : SymetryBoundary\n  x₂ : SymetryBoundary\n  y₁ : SymetryBoundary\n  y₂ : SymetryBoundary\n  z₁ : ConductionBoundary\n  z₂ : ConvectionBoundary\n  name : NA\n  tₗ : 5.0\n  skip : 2\n\nThis returns a single Load, for a single load step. To make a load set you will need an array of Loads.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#HSSSimulations.Solver.FixedLoadSet","page":"Main API","title":"HSSSimulations.Solver.FixedLoadSet","text":"struct FixedLoadSet <: AbstractLoadSet\n\n#Fields\n\nname::String: Name of the load set\nloads::Vector{Load}: List of loads for load set\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.Solver.LayerLoadSet","page":"Main API","title":"HSSSimulations.Solver.LayerLoadSet","text":"struct LayerLoadSet <: AbstractLoadSet\n\n#Fields\n\nname::String: Name of the load set\nfinishLayer::Int64: The last layer to deposit as part of this load set\nloads::Vector{Load}: List of loads for load set\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.HSSBound.HSSLoads","page":"Main API","title":"HSSSimulations.HSSBound.HSSLoads","text":"HSSLoads(\n    skip,\n    geometry;\n    nrPreheat,\n    lenPreheat,\n    nrCool,\n    lenCool,\n    sinterSpeed,\n    lcAndBedWidth\n) -> Vector{AbstractLoadSet}\n\n\nReturns a list of load sets, one for the preheat, build, and cooldown phases of a default build for the HSS example. The same skip is used for all load steps (See Why We Skip Some Results for more information on skip).\n\nThe loads used in these load sets are explained further below, and all assume the use of the HSSParams parameter set.\n\njulia> HSSLoads(10, Geometry((1,1,1),1,1); nrPreheat=5, lenPreheat=60.0, nrCool=5, lenCool=60.0, sinterSpeed=0.160)\n3-element Vector{AbstractLoadSet}:\n   name : Preheat\n  loads\n----------------------\n\n  Name: Overheads Only\n  For 5 loads\n\n\n\n   name : Layer\n  finishLayer : 0\n  loads\n----------------------\n\n  Name: Overheads Only\n  Name: Sintering\n  Name: Overheads Only\n  Name: Recoating\n  Name: Overheads Only\n  Name: No Inking\n  Name: Overheads Only\n  Name: Inking\n\n\n\n   name : Cooldown\n  loads\n----------------------\n\n  Name: Overheads Off\n  For 5 loads\n\nExtended help\n\nHere we will cover the details on exactly what it is that the example boundary is replicating. We will cover this one boundary at a time. As the simulation is a cuboid, it has six external surfaces, each of which must have defined boundary conditions.\n\nThe simulation is to be compared to an array of identical, symmetrical parts being printed. Assuming that this array is infinite results in a symmetrical boundary condition. This means that the four conditions representing the side walls (x₁, x₂, y₁ and y₂ in the notation used in Types.Load), can all use the default boundary condition provided by Boundary.SymetryBoundary.\n\nThe bottom boundary (z₁) is where the build bed is in contact with the piston. As the piston is one of the few consistent things on our machine, this can be simulated as a constant temperature boundary with a contact conduction coefficient. This is done using HSSBound.PistonBoundary.\n\nThe final boundary, the top surface of the powder (z₂) is by far the most complicated. It changes constantly throughout the build as new layers are added and sintered.\n\nOverhead Heaters\n\nIn the default state with nothing happening the top boundary has heat loss due to convection to the forced air draft over the surface and loss from radiation to the surrounding surfaces. In addition, there is a stationary overhead heater. During preheating (during the FixedLoadSet named Preheat) the overhead heater is set to a fixed power (Simulated using HSSBound.loadOverheads).\n\nOnce the build starts (during the LayerLoadSet named Layer), the overhead power is adjusted, starting at a set amount (usually around 60% (of a 300W heater)) and changing by a set amount (usually 1 percent of maximum power) every set number of layers (usually every 3 layers) with the goal of reaching the target temperature of the top surface (Simulated using HSSBound.loadOverheads). Once the build is finished (during the FixedLoadSet named Cooldown) the overhead is turned off (set to 0W power) and left to cool down (Simulated using HSSBound.loadCooldown).\n\nThe overhead heater boundary is implemented as a radiation boundary condition, because of this the overhead temperature is needed (not the input power, which is all we defined above). For this, the HSSBound.overheadTempFunc is used to calculate the overhead temperature based on its previous temperature and the change in temperature caused by its current input power.\n\nCarriages\n\nMost of this change comes from the movement of two carriages, the lamp carriage and the print carriage. The first contains both the powder hopper (for recoating) and the sinter lamp. The second contains the print heads used to deposit the absorptive ink.\n\nDuring each layer the following happens (described as if looking from the front of the machine, with the x-axis going front to back, and slightly confusingly the y-axis going right to left (don't ask, I regret this choice)):\n\nThe lamp carriage moves from left to right with the lamp set at sinter power   (loadSinterStroke)\nThe lamp carriage moves from right to left with the lamp set to recoat power and the powder hopper   deposits a layer of powder (loadRecoatStroke)\nThe print carriage moves from right to left whilst doing nothing special   (loadBlankStroke)\nThe print carriage moves from left to right as the print heads deposit the ink   (loadInkStroke)\n\nIn between each of the above steps are brief moments of simplicity, where the only boundary conditions are those covered in previous sections. These gaps use the aforementioned HSSBound.loadOverheads. The carriage boundaries are only actually used when the carriages are over the build bed, it is assumed that if they are moving but not over the bed then they have no impact on the boundary conditions so the HSSBound.loadOverheads can be used instead.\n\nIt is also worth noting, that when a carriage is in over the top of the build bed, the build bed is shadowed from the overheads, which is modeled in each of the four carriage loads.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Boundary-Parameters","page":"Main API","title":"Boundary Parameters","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"BasicProblemParams\nHSSParams(::Geometry)","category":"page"},{"location":"reference/api/#HSSSimulations.Boundary.BasicProblemParams","page":"Main API","title":"HSSSimulations.Boundary.BasicProblemParams","text":"A basic implementation of a Types.AbstractProblemParams struct to go along with basicLoad. For a more elaborate example see HSSParams\n\nFields\n\ncondCoef::Float64: The contact conduction coefficent for the bottom face\ncondTemp::Any: The temperature of the surface in contact with the bottom face\nconvCoef::Float64: The convection coefficent for the top face to the air above\nconvTemp::Any: The temperature of the air in contact with the top face\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.HSSBound.HSSParams-Tuple{Geometry}","page":"Main API","title":"HSSSimulations.HSSBound.HSSParams","text":"HSSParams(Geometry; kwargs...) -> HSSParams\n\nThe geometry (of type Geometry) should be the same one used for the simulation. If the piston target temperature is chaneged then the piston path will need to be changed to curves that will match the target temperature. The same applies if the preheat bed is thicker than the normal ≈3 mm.\n\nThis is intended to proved the required parameters for the load sets produced by HSSLoads.\n\nSee HSSParams for information on the fields of the created struct.\n\nArguments\n\nname = \"HSS example problem boundary\": A name for the parameter set, only used for user reference.\npistonPath = joinpath(artifact\"HSS\", \"HSS_Piston.jld2\"): Where to find the piston heat up and cool down curves data file.\nairPath = joinpath(artifact\"HSS\", \"HSS_Surface.jld2\"): Where to find the machine's internal surface heat up and cool down curves data file.\nsurfacePath = joinpath(artifact\"HSS\", \"HSS_Air.jld2\"): Where to find the machine's internal air heat up and cool down curves data file.\nconductionCoef = 7500.0: The conduction coefficient of the top surface of the bed, in W/m²k.\nlampVector = [0.0, 1, 2, 2, 2, 2, 2, 1, 0]: The y-axis distribution of the lamp power, see lampMaker for more details.\nlampWidth = 0.100: The width of the lamps power distribution, in meters.\nlampOffset = 0.175: The distance between the left edge of the lamp carriage and th left edge of the lamp's distribution, in meters.\ncarriageWidth = 0.275: The width of the lamp/recoater carriage, in meters.\nrecoatOffset = 0.045: The offset between the left edge of the recoater carriage and the left edge of the recoater, in meters.\nprintCarriageWidth = 0.180: The width of the print head carriage, in meters.\nprintOffset = 0.110: The offset between the left edge of the print head carriage and the left edge of the print nozzles.\nsurfaceTarget = 160.0: The target temperature of the top surface of the powder bed. Used to control the overhead heaters, in °C.\nsurfaceTol = 1.0: The tolerance of the bed surface temperature when compared to the target temperature, in °C.\noverheadLayerStep = 3: How often, in number of layers, to update the overhead power based on the bed surface temperature.\noverheadPercentStep = 1.0: How big of a step in overhead power to make each time they are updated, in % of total power.\noverheadTemp = 25.0: The starting temperature of the overhead heaters themselves, in °C.\noverheadPower = 0.6 * 300: The starting input power of the overhead heaters, in watts.\noverheadPowerOut = T -> (0.596T - 12.2): A function that takes the current overhead heater temperature and returns the output power of the heater.\noverheadHeatCapacity = 118.923: The heat capacity of the overhead heaters, in J/K.\noverheadMaxPower = 300.0: The maximum input power of the overhead heaters.\nconvectionCoef = 4.0: The convection coefficient of the top surface of the bed, in W/m²k.\nsinterPower = 2000.0: The output power of the sinter lamp during the sinter stroke.\nrecoatPower = 0.0: The output power of the sinter lamp during the recoat stroke.\nlastUpdatedOverhead = 0: The last layer the overhead heaters were updated on.\npercentOverhead = 0.2125: The percentage of the surfaces that the top surface of the powder bed is exposed to that is the overhead heaters, as opposed to the other internal surfaces of the machine.\npowderTempDelta = 25: The difference between the surface temperature of the machine and the temperature of the powder being deposited.\noverheadHeatupFunc: A function that takes an input power and a previous overhead heater temperature and returns the temperature for the overhead heaters for the next time step. This uses HSSBound.overheadTempFunc by default, using the function shown below:\n\noverheadHeatupFunc = function (powerIn::Float64, prevOverheadTemp::Float64, _)\n    return overheadTempFunc(\n        powerIn,\n        overheadPowerOut,\n        overheadHeatCapacity,\n        geometry.Δt,\n        prevOverheadTemp,\n    )\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/api/#Settings","page":"Main API","title":"Settings","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Options\npackage_groups","category":"page"},{"location":"reference/api/#HSSSimulations.Types.Options","page":"Main API","title":"HSSSimulations.Types.Options","text":"struct Options\n\nFields\n\ncompress::Union{Bool, TranscodingStreams.Codec}: How to compress the results file, can be set to true (to compress), false (to leave uncompressed) or to a specific compression algorithm (see the JLD2 documentation for more details)\ndebug::Union{Bool, Vector{String}}: Whether or not to log debug information, can accept a list of strings to select only some debugging groups, see package_groups\nshowProgress::Union{Bool, Float64}: Whether or not to show the progres meter, if a number is given that is used as the update interval\nnotify::Bool: If true, simulations finishing will send a system notification using Alert.jl\n\nThe debug option is passed to the logGroups option of Solver.makeLogger, check that out for more information and package_groups for what log groups are available by default.\n\nnote: Note\nDepending on settings, the debug option might log a lot of things, the log file could end up somewhere in the region of 4x the size of the compressed results file, so make sure you clean them up after you're done.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#HSSSimulations.Types.package_groups","page":"Main API","title":"HSSSimulations.Types.package_groups","text":"A list of all of the log groups used in this package. They log the following things:\n\ncore: the start of a problem, loadstep, load or timestep has started\nsolver: the fdm solver\nmat: material model\nbound: boundary condition\nb_adv: recoating and moving object boundaries\nhss: HSS example functions\n\n\n\n\n\n","category":"constant"},{"location":"reference/api/#Results-File-Structure","page":"Main API","title":"Results File Structure","text":"","category":"section"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"The last part of the API to cover is the format of the simulation results that are saved. These use the JLD2 package to save to a Hierarchical Data Format version 5 (HDF5) based format. Most of the information stored should be readable by any HDF5 compatible software or libraries, except the input problem, which requires the software to understand Julia types (the easiest way is to just use Julia, it's mostly saved in case it needs to be rerun).","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"By default, this is stored compressed using the ZlibCompressor compressor.","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"The results have the following structure:","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Tree                           Description\nResults\n│\n├─ Description                 - An overview of the problem that has been solved\n├─ Input                       - The full problem struct that has been solved\n├─ Start_Time                  - The computer's clock time at the end of the simulation\n├── Results\n│   ├─ MeltMax                 - The maximum melt state reached in the simulation\n│   │\n│   ├── Preheat-1              - List of loads run during the preheating load set\n│   │   ├─ 1\n│   │   ├─ 2\n│   │   └─ ⋯ (3 more entries)\n│   │\n│   ├── Layer-2                - 1st Layer\n│   │   ├─ 1                   - 1st Layer's 1st Load\n│   │   ├─ 2                   - 1st Layer's 2nd Load\n│   │   └─ ⋯ (6 more entries)  - And so on for the remaining loads\n│   │\n│   ├── Layer-3                - 2nd Layer\n│   │   ├─ 1 (5 entries)\n│   │   ├─ 2\n│   │   └─ ⋯ (6 more entries)\n│   │\n│   ├─ ⋯ (25 more entries)     - And so on for the remaining layers\n│   │\n│   └── Cooldown-28            - List of loads run during the cooldown load set\n│       ├─ 1\n│       ├─ 2\n│       └─ ⋯ (3 more entries)\n│\n├─ Results_Index               - A list of all load results indices within this file\n├─ Finish_Time                 - The computer's clock time at the end of the simulation\n└─ _types                      - Ignore (Used internally by JLD2)","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Where each of the loads has these fields:","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"Tree           Description\n\nLoad\n├─ name        - The load's name\n├─ time        - 1D array of the times of the load's time steps\n├─ T           - 4D array of temperatures (X, Y, Z, time step)\n├─ M           - 4D array of melt states (X, Y, Z, time step)\n└─ C           - 4D array of consolidation states (X, Y, Z, time step)","category":"page"},{"location":"reference/api/","page":"Main API","title":"Main API","text":"tip: Tip\nResults.loadStepSaver, Solver.otherResults, are the two functions used for saving simulation results to the file. so looking at their implementation might help with if anything is not covered here. Solver.startMetadata and Solver.finishMetadata are also used to save a few extra bits of metadata to the file. I'd also recommend a tool like HDFView to get an idea for the structure of the results.","category":"page"},{"location":"reference/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"reference/types/","page":"Types","title":"Types","text":"Types","category":"page"},{"location":"reference/types/#HSSSimulations.Types","page":"Types","title":"HSSSimulations.Types","text":"Contains the main types used in the simulation, along with the abstract types used to extend the simulation's functionality.\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#External","page":"Types","title":"External","text":"","category":"section"},{"location":"reference/types/","page":"Types","title":"Types","text":"Most of the types that are intended for external use (other than those in the main API) have instead been included with the modules that they are used in. The types listed here under external are often passed into functions on the public interface, so it is useful to understand their fields to know what can be accessed when making new functions for these interfaces.","category":"page"},{"location":"reference/types/","page":"Types","title":"Types","text":"Types.Geometry\nTypes.Problem\nTypes.LoadStep\nTypes.LoadTime\nTypes.Indices","category":"page"},{"location":"reference/types/#HSSSimulations.Types.Geometry","page":"Types","title":"HSSSimulations.Types.Geometry","text":"struct Geometry <: HSSSimulations.Types.AbstractSimProperty\n\nDefines the geometry of the build volume (and the simulation volume within that (if only a subset of a build is being simulated).\n\nFields\n\nx::Float64: The size of the x axis of the model in meters\ny::Float64: The size of the y axis of the model in meters\nz::Float64: The size of the z axis of the model in meters\nX::Int64: The size of the x axis of the model in nodes\nY::Int64: The size of the y axis of the model in nodes\nZ::Int64: The size of the z axis of the model in nodes\nsize::Tuple{Int64, Int64, Int64}: Tuple of the XYZ sizes\nxoffset::Float64: The x axis offset of the model from the machines datum in meters\nyoffset::Float64: The y axis offset of the model from the machines datum in meters\nX_OFFSET::Int64: The x axis offset of the model from the machines datum in nodes\nY_OFFSET::Int64: The y axis offset of the model from the machines datum in nodes\nxbuild::Float64: The total x axis size of the machine from which the subset is taken in meters\nybuild::Float64: The total y axis size of the machine from which the subset is taken in meters\nX_BUILD::Int64: The total x axis size of the machine from which the subset is taken in nodes\nY_BUILD::Int64: The total y axis size of the machine from which the subset is taken in nodes\nΔx::Float64: The spacing of the nodes in meters in the x axis\nΔy::Float64: The spacing of the nodes in meters in the y axis\nΔz::Float64: The spacing of the nodes in meters in the z axis\nΔt::Float64: The spacing of timesteps in seconds\nNₗ::Int64: The number of layers in the model\nΔh::Float64: The layer height in nodes\nΔH::Int64: The layer height in meters\nname::String: Just used for future reference of results\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#HSSSimulations.Types.Problem","page":"Types","title":"HSSSimulations.Types.Problem","text":"struct Problem{T<:AbstractArray, Gh<:AbstractArray, M<:AbstractMatProp, R<:AbstractResult, OR<:AbstractOtherResults, P<:AbstractProblemParams}\n\nAn internal struct used for passing the many variables around the different function, it is built from a given problem struct, using a constructor in the problem module. There is probably a better way of doing this, but it works.\n\nFields\n\ngeometry::Geometry: Simulation geometry. Geometry\nmatProp::AbstractMatProp: Simulation material properties. AbstractMatProp\nparams::AbstractProblemParams: Parameters used for boundary conditions. AbstractProblemParams\nloadSets::Vector{AbstractLoadSet}: List of all load sets to run. AbstractLoadSet\notherResults::AbstractOtherResults: Results struct used to save data only once at the end. AbstractOtherResults\ninit::AbstractResult: Initial results. AbstractResult\ninitLay::Int64: The thickness of powder to use for preheat loads, given in number of layers thick\nink::Ink: Matrix of final emissivities. Ink\neᵗ::AbstractArray: Matrix of current emissivities\nFx::AbstractArray: Matrix of x axis Fourier numbers\nFy::AbstractArray: Matrix of y axis Fourier numbers\nFz::AbstractArray: Matrix of z axis Fourier numbers\nκ::AbstractArray: Matrix of thermal conductivities\nTᵗ⁻¹::AbstractArray: Ghost node padded matrix of previous time step\nresultsIndex::Vector{String}: index of results file\nfile::String: File name\ndescription::String: A short description of what is being simulated. To help remember what the simulation results are about\noptions::Options: Simulation options\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#HSSSimulations.Types.LoadStep","page":"Types","title":"HSSSimulations.Types.LoadStep","text":"struct LoadStep{R<:AbstractResult}\n\nAn internal struct for the propeties that are constant within a load step.\n\nFields\n\ntime::HSSSimulations.Types.LoadTime: See LoadTime\nsize::Tuple{Int64, Int64, Int64}: The x, y and z size in number of nodes (mostly just used for the z, which may have changed from the same value in the Problem.geometry variable)\nind::HSSSimulations.Types.Indices: See Indices\nload::Load: See Load\ninit::AbstractResult: The initial results for the load. See AbstractResult\nname::String: Used for the progress meter\nlayerNum::Int64: Used for any Load functions that need the layer number. For preheat and cooldown load sets this will be the initial thickness or the finial thickness in layers respectively.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#HSSSimulations.Types.LoadTime","page":"Types","title":"HSSSimulations.Types.LoadTime","text":"struct LoadTime\n\nContains all of the time information for a LoadStep.\n\nFields\n\nΔt::Float64: Time between time steps\ntimes::Vector{Float64}: Array of all of the times in the load step\nunskipTimes::Vector{Float64}: Array of all none skipped times in the load step\ntₚ::Vector{Float64}: Array of percentage through timestep, same index as times\nutₚ::Vector{Float64}: Array of percentage through timestep, same index as unskipTimes\ntₛ::Float64: The time at the start of the load step\ntₑ::Float64: Time step end time\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#HSSSimulations.Types.Indices","page":"Types","title":"HSSSimulations.Types.Indices","text":"mutable struct Indices\n\nStores the indices of the nodes, taking into account if the node represents a volume that contains powder or not. And also stores the node pais for the boundaries.\n\niᵣ are indices of real nodes, this is all nodes that represent space where there is currently powder. This will normally include every node, however before and during the recoat load it will not include all of the top layer, as powder has not been deposited there yet. iᵢ are the indices of 'imaginary' nodes, these are nodes that represent locations that do not currently contain powder. These is the same as the indices of all of the nodes minus the indicies of the real nodes (iᵣ).\n\nFields with a subscript 1 (₁) denote the boundary at the start of that axis, and subscript 2 (₂) dentoes the end of that boundary. eg. x₂ is the boundary [end,:,:] and y₁ is [:,1,:]. z₂ is a special case where it always represents the top surface of the build, even if a layer has not been compleatly deposited yet. y₂ is another special case, where it represents its normal face, but also represents the leading edge of deposited powder.\n\nThe first element of the tuple in the boundary indices is the cartiesian index (of the array without the ghost cells) for the real node, the second is the linear index of the same point and the third element is the linear index (of the array with the ghost cells) of the matching ghost node.\n\nFields\n\niᵣ::Vector{CartesianIndex{3}}: List of currently real nodes\niᵢ::Vector{CartesianIndex{3}}: List of currently imaginary nodes\nx₁::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\nx₂::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\ny₁::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\ny₂::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}: List of real/ghost node pairs for `[:,end,:]\nz₁::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}\nz₂::Matrix{Tuple{CartesianIndex{3}, Int64, Int64}}: List of real/ghost node pairs for `[:,:,end]\niₘ::CartesianIndex{3}: The middle point of z₂, and it is currently only used for debugging/logging.\nΔH::Int64: The same as it is in Geometry, it is just copied over for convenience.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#Internal","page":"Types","title":"Internal","text":"","category":"section"},{"location":"reference/types/","page":"Types","title":"Types","text":"The methods and types listed below are only used within the simulation and should not be needed when using any of the public API, basic or advanced.","category":"page"},{"location":"reference/types/","page":"Types","title":"Types","text":"Types.AbstractSimProperty\nTypes.LoadTime(::Any,::Any,::Any,::Any)","category":"page"},{"location":"reference/types/#HSSSimulations.Types.AbstractSimProperty","page":"Types","title":"HSSSimulations.Types.AbstractSimProperty","text":"abstract type AbstractSimProperty\n\nThis is the parent type of all of the simulation property types. It exists mostly to define a show method for all of it's subtype. This just makes things nicer to look at the.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#HSSSimulations.Types.LoadTime-NTuple{4, Any}","page":"Types","title":"HSSSimulations.Types.LoadTime","text":"LoadTime(tₛ, tₗ, Δt, skip) -> HSSSimulations.Types.LoadTime\n\n\nDefault Constructor for LoadTime.\n\nArguments\n\ntₛ::Float64: The time at the start of the load step\ntₗ: The lenght of the load step\nΔt::Float64: Time between time steps\nskip: How often to save results. See Why We Skip Some Results\n\n\n\n\n\n","category":"method"},{"location":"#Modelling-of-HSS-(and-related-technologies)","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"","category":"section"},{"location":"#Introduction","page":"Modelling of HSS (and related technologies)","title":"Introduction","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"This is the package created as a part of my (Oliver Leete) PhD thesis. Its goal is as the title suggests, to create a simulation of a High Speed Sintering (HSS) build by approximating the build volume as a single solid object. This is done by having a complex material model to approximate the thermal behaviour of the powder and how it changes when the powder starts to become part of a part.","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"This documentation will try its best to follow the Diátaxis Documentation Framework.","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"If you are new to the package and want a guide on how to get started running simulations, check out the tutorials section. These tutorials are also available as notebooks in the example folder of the repo.","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Once you have a grip on the basics, you can check out the recipes section for how-to guides on making larger changes to the simulations. The top of the page should have links to the parts of the API that it's helpful to have familiarised yourself with. The examples on each page will typically build up in complexity, so if you are struggling to follow a later example, have a look at the previous ones to see if it helps.","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"The API is available in the references section, it's split into three levels. The main API contains everything required for a normal simulation. The advanced API covers functions and types that can be useful for getting some more control over your simulations (like in the ways shown in some of the recipes).","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"One major deviation from the Diátaxis framework is the explanations section. The normal contents of this section are instead partially provided in the other sections, and my thesis is provided as a contiguous explanation of what is going on. There is also a small FAQ section to provide brief explanation of some things that come up often.","category":"page"},{"location":"#Tutorials","page":"Modelling of HSS (and related technologies)","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Pages = Main.tut_pages\nDepth=1","category":"page"},{"location":"#API","page":"Modelling of HSS (and related technologies)","title":"API","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Pages = api_pages\nDepth=1","category":"page"},{"location":"#Recipes","page":"Modelling of HSS (and related technologies)","title":"Recipes","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Pages = Main.recipe_pages\nDepth=1","category":"page"},{"location":"#Other-Pages","page":"Modelling of HSS (and related technologies)","title":"Other Pages","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Pages = [\"explanation/faqs.md\", \"doc_index.md\"]\nDepth=1","category":"page"},{"location":"#Contribution","page":"Modelling of HSS (and related technologies)","title":"Contribution","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"If you are reading this I have probably finished my PhD, so it is unlikely I will be making any major improvements to this codebase. However, I will try to keep an eye on the original repository (the one on my personal GitHub account), so if you add any cool new features feel free to open a pull request there.","category":"page"},{"location":"#Readme","page":"Modelling of HSS (and related technologies)","title":"Readme","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"A package to simulate High Speed Sintering (HSS) by treating the powder bed as a bulk material, using the finite difference method and a quasi-solid material model.","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"As this is not in the Julia general registry, you will need to dev the package using:","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"using Pkg\nPkg.dev(\"https://github.com/Oliver-Leete/HSSSimulations.jl.git\")","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"If you are new to Julia, I'd recommend checking out the getting started documentation","category":"page"},{"location":"#Licence","page":"Modelling of HSS (and related technologies)","title":"Licence","text":"","category":"section"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"MIT License","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Copyright (c) 2023 Oliver Leete","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"","page":"Modelling of HSS (and related technologies)","title":"Modelling of HSS (and related technologies)","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"reference/material/#Material-Model","page":"Material Model","title":"Material Model","text":"","category":"section"},{"location":"reference/material/","page":"Material Model","title":"Material Model","text":"Material","category":"page"},{"location":"reference/material/#HSSSimulations.Material","page":"Material Model","title":"HSSSimulations.Material","text":"Contains a concrete material property type, the functions for running the material model, and an example material using this model and data collected from measuring PA2200.\n\n\n\n\n\n","category":"module"},{"location":"reference/material/#PA2200","page":"Material Model","title":"PA2200","text":"","category":"section"},{"location":"reference/material/","page":"Material Model","title":"Material Model","text":"Material.PA_κ\nMaterial.PA_ρ\nMaterial.PA_c\nMaterial.PA_Mᵣ\nMaterial.PA_Rᵣ\nMaterial.PA_Hf\nMaterial.PA_Hr\nMaterial.PA_Ċ\nMaterial.PA_eₚ\nMaterial.PA_eᵢ\nMaterial.PA_ε","category":"page"},{"location":"reference/material/#HSSSimulations.Material.PA_κ","page":"Material Model","title":"HSSSimulations.Material.PA_κ","text":"Values from Yaun 2014 used for consolidation state of 0 and 1 (at a melt state of 0). And values from Riedlbaur 2015 (I think originally from Rietzel 2011, but my German isn't good enough to confirm) used for a melt state of 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_ρ","page":"Material Model","title":"HSSSimulations.Material.PA_ρ","text":"Assumes density is constant across temperatures and at data sheet values for maximum consolidation state. For consolidation and melt state zero, the measured value of the powder in the machine is used. The melted density is based on observations while taking dilatometry measurments.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_c","page":"Material Model","title":"HSSSimulations.Material.PA_c","text":"Data taken from stepscan of PA2200, processed by perkin-elmer dsc software. Melt region is interpolated over to avoide issuse with .\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_Mᵣ","page":"Material Model","title":"HSSSimulations.Material.PA_Mᵣ","text":"A normalized cumulative integral of the energy in to a system during melting from a DSC curves.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_Rᵣ","page":"Material Model","title":"HSSSimulations.Material.PA_Rᵣ","text":"A normalized cumulative integral of the energy out of a system during recrystallization from DSC curves. With each curve taken from increasing melt states.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_Hf","page":"Material Model","title":"HSSSimulations.Material.PA_Hf","text":"The difference between the energy in to the system during melting (from a DSC curve), and an interpolated line drawn between the sections of heating outside of the melt region.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_Hr","page":"Material Model","title":"HSSSimulations.Material.PA_Hr","text":"The difference between the energy out of the system during crystallization (from a DSC curve), and an interpolated line drawn between the sections of cooling outside of the recrystallization region.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_Ċ","page":"Material Model","title":"HSSSimulations.Material.PA_Ċ","text":"Based on model from Childs and Tontowi 2001. Modified to work off of consolidation and melt states. Calibrated from dilatometry data. See Material.Ċ_maker for how to make your own.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.PA_eₚ","page":"Material Model","title":"HSSSimulations.Material.PA_eₚ","text":"Taken from near ir experiments.\n\n\n\n\n\n","category":"constant"},{"location":"reference/material/#HSSSimulations.Material.PA_eᵢ","page":"Material Model","title":"HSSSimulations.Material.PA_eᵢ","text":"Taken from near ir experiments.\n\n\n\n\n\n","category":"constant"},{"location":"reference/material/#HSSSimulations.Material.PA_ε","page":"Material Model","title":"HSSSimulations.Material.PA_ε","text":"Taken from pyrometer calibrations.\n\n\n\n\n\n","category":"constant"},{"location":"reference/material/#New-Materials-Using-the-Default-Model","page":"Material Model","title":"New Materials Using the Default Model","text":"","category":"section"},{"location":"reference/material/","page":"Material Model","title":"Material Model","text":"MatProp\nMatProp(::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any,::Any)\nMaterial.Ċ_maker","category":"page"},{"location":"reference/material/#HSSSimulations.Material.MatProp","page":"Material Model","title":"HSSSimulations.Material.MatProp","text":"struct MatProp{T1, T2, T3, T4, T5, T6, T7, T8, T9} <: AbstractMatProp\n\nThe default implementation of AbstractMatProp used by the default Material.calcMatProps! method. See PA2200 for an exmaple of a premade materials. The arguments to its constructor are the same as the matching fields. The only addition is the geometry argument, which should just be the Geometry struct of for the simulation.\n\nThe default material model behaviour can be used to simulate similar materials by simply changing the contents of this struct. The PA2200 section should provide some ideas on how to measure these values.\n\nIf the same consolidation model is used, Ċ_maker can be used to make a new consolidation rate function with new coefficients.\n\nwarning: Warning\nThe maximum melt state is never reset, so if a node goes from the melt region to the recrystalisation region more than once in a simulation, the behaviour might not be modeled properly.\n\nFields\n\nρ::Any:  Density. Two dimensional interpolations, with inputs in axis 1 = consolidation state, axis 2 = melt state.\n\nc::Any:  Specific heat capacity. One dimensional interpolations with the node's temperature as it's input.\n\nκ::Any:  Thermal conductivity. Three dimensional interpolations, with inputs in axis 1 = consolidation state, axis 2 = temperature and axis 3 = melt state.\n\nMᵣ::Any:  Melting range and temp relationship. A 1d interpolation, with the only input axis being the temperature and the output is the melt state.\n\nMₛ::Float64: The start temperature of the melt range\nMₑ::Float64: The end temperature of the melt range\nRᵣ::Any:  Crystallisation range and temp relationship. A 2d interpolation, with the first input axis being the node temperature and the second input axis being the maximum melt state reached. The output is the melt state.\n\nRₛ::Float64: The start temperature of the recrystalisation range\nRₑ::Float64: The end temperature of the recrystalisation range\nHf::Any: Total specific heat of melting\nHr::Any:  Total specific heat of fusion. A 1d Interpolation where the input is the maximum melt state reached and the output is the total heat of fusion.\n\nĊ::Any:  Consolidation rate. Either a single value representing a constant consolidation rate, or a 2d interpolation, with the first axis being the node temperature and the second being the node melt state. The output is the rate of change of sinter state.\n\neₚ::Float64:  Emmisivity of the powder. This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n\neᵢ::Float64:  Emmisivity of the powder with ink on it. This is the emmisivity relative to the lamp. So the emmisivity over the range of the wavelengths that the lamp outputs, scaled by the relative output power of the lamp at those wavelengths.\n\nε::Float64:  Black body emmisivity of the powder\nname::String: Just used for future reference\nMₘ::Any: Used by the material model to track the maximum melt state reached per node\n\n\n\n\n\n","category":"type"},{"location":"reference/material/#HSSSimulations.Material.MatProp-NTuple{13, Any}","page":"Material Model","title":"HSSSimulations.Material.MatProp","text":"MatProp(\n    ρ,\n    c,\n    κ,\n    Mᵣ,\n    Rᵣ,\n    Hf,\n    Hr,\n    Ċ,\n    eₚ,\n    eᵢ,\n    ε,\n    name,\n    geometry\n) -> MatProp\n\n\nDefault constructor for MatProp.\n\n\n\n\n\n","category":"method"},{"location":"reference/material/#HSSSimulations.Material.Ċ_maker","page":"Material Model","title":"HSSSimulations.Material.Ċ_maker","text":"Based on model from Childs and Tontowi 2001. Modified to work off of consolidation and melt states . Takes three coefficients (βₛ Aₛ nₛ) and returns a consolidation rate calculator that  . follows the equation below                                                                         .\n\ndotC = (1-C^t-1) A_s expleft(-fracE_sRT^t-1 - beta_s (1-M^t-1)^n_sright)\n\nWhere C^t-1 is the previous consolidation state, M^t-1 is the previous melt state, and T^t-1 is the previous temperature.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#Modifying-the-Current-Material-Model","page":"Material Model","title":"Modifying the Current Material Model","text":"","category":"section"},{"location":"reference/material/","page":"Material Model","title":"Material Model","text":"Material.calcMatProps!(::AbstractResult, ::AbstractResult, ::Problem{T,Gh,Mp,R,OR,B}, ::Any) where {\n    T<:Any,Gh<:Any,Mp<:AbstractMatProp,R<:Any,OR<:Any,B<:Any,\n}\nMaterial.meltUpdate\nMaterial.meltUpdate(::Any,::Any,::Any,::Any,::AbstractMatProp)\nMaterial.consUpdate\nMaterial.consUpdate(::Any,::Any,::Any,::Any,::AbstractMatProp)","category":"page"},{"location":"reference/material/#HSSSimulations.Material.calcMatProps!-Union{Tuple{B}, Tuple{OR}, Tuple{R}, Tuple{Mp}, Tuple{Gh}, Tuple{T}, Tuple{AbstractResult, AbstractResult, Problem{T, Gh, Mp, R, OR, B}, Any}} where {T, Gh, Mp<:AbstractMatProp, R, OR, B}","page":"Material Model","title":"HSSSimulations.Material.calcMatProps!","text":"calcMatProps!(\n    pts::AbstractResult,\n    cts::AbstractResult,\n    prob::Problem{T, Gh, Mp<:AbstractMatProp, R, OR, B},\n    ind\n)\n\n\nThe default material model, designed to be used with MatProp, but should work with any Types.AbstractMatProp that shares MatProp's ρ, c, κ and Mₘ fields.\n\nUpdates melt and consolidation state, and then uses those to update the density, heat capacity and conductivity. These are then used to calculate the Fourier number for each axis for this time step.\n\nThe meltUpdate and consUpdate state updater of the default material model can be modified separately from the this function itself. The default methods are meltUpdate and consUpdate. An example of this can be seen in Tutorial 3: A Melt Rate Based Material Model.\n\n\n\n\n\n","category":"method"},{"location":"reference/material/#HSSSimulations.Material.meltUpdate","page":"Material Model","title":"HSSSimulations.Material.meltUpdate","text":"meltUpdate(Mᵗ⁻¹, T, Mₘ, Δt, mp::AbstractMatProp) -> Mᵗ, Mₘ, Δh\n\nCalculates the new melt state of a single node. It is given the melt state and temperature of the node in the previous time step, the maximum melt state the node has reached so far, the duration of the current time step and the material property struct.\n\nIt should return the new melt state for the node, the new maximum melt state, and the specific enthalpy change due to fusion or recrystalisation that is associated with the change in melt state.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.meltUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}","page":"Material Model","title":"HSSSimulations.Material.meltUpdate","text":"meltUpdate(\n    Mᵗ⁻¹,\n    T,\n    Mₘ,\n    _,\n    mp::AbstractMatProp\n) -> Tuple{Any, Any, Any}\n\n\nUpdates the melt state of a node if the temperature of the node is in the melting or crystalisation termperature range if not the existing value is returned. This uses a basic time independent model that associates a single melt state to a given combination of temperature and maximum melt state reached so far.\n\n\n\n\n\n","category":"method"},{"location":"reference/material/#HSSSimulations.Material.consUpdate","page":"Material Model","title":"HSSSimulations.Material.consUpdate","text":"consUpdate(C, M, T, Δt, mp::AbstractMatProp) -> C\n\nCalculates the new consolidation state of a single node. It is given the current consolidation state, melt state and temperature of the node, the duration of the current time step and the material property struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/material/#HSSSimulations.Material.consUpdate-Tuple{Any, Any, Any, Any, AbstractMatProp}","page":"Material Model","title":"HSSSimulations.Material.consUpdate","text":"consUpdate(C, M, T, Δt, mp::AbstractMatProp) -> Any\n\n\nUpdates the consolidation state of a node by adding the change in consolidation state (rate * time) to the previous consolidation state. Only applies if the material is melted and not already fully consolidated.\n\nThis finds the consolidation rate by calling mp.Ċ with C, T and M as arguments.\n\nThe returned values maximum is limited to 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/material/#Making-a-New-Material-Model","page":"Material Model","title":"Making a New Material Model","text":"","category":"section"},{"location":"reference/material/","page":"Material Model","title":"Material Model","text":"Types.AbstractMatProp\nMaterial.calcMatProps!","category":"page"},{"location":"reference/material/#HSSSimulations.Types.AbstractMatProp","page":"Material Model","title":"HSSSimulations.Types.AbstractMatProp","text":"abstract type AbstractMatProp <: HSSSimulations.Types.AbstractSimProperty\n\nThe abstract type that any material property struct needs to be a subtype of. These are for storing the values used to define the properties of a material, and those used to calculate the changes in material properties due to the build. The default struct used is MatProp, however new subtypes can be defined and used by defining a new Material.calcMatProps! function. This allows for the simplificiation (or complication) of the material model used in the simulation to fit your needs.\n\nAny new subtype will need it's own method writen for calcMatProps! and if the example boundaries are being used some of them might need to be updated to use the new material properties. If melt state or consolidation state are beind removed from the material model then it might be worth implementing a new AbstractResult to save on memory. If an additional property that needs to be tracked is added to the material model then it will be necissary to implement a new subtype of those to track this.\n\nSee Material Model Recipes and Tutorial 3: A Melt Rate Based Material Model for more information on implementing your own.\n\n\n\n\n\n","category":"type"},{"location":"reference/material/#HSSSimulations.Material.calcMatProps!","page":"Material Model","title":"HSSSimulations.Material.calcMatProps!","text":"calcMatProps!(::AbstractResult, ::AbstractResult, <:Problem, ::Indices)\n\nUpdates any of the material properties that change, along with the Fourier number for the current time step. New methods can be defined by dispatching on Problem with a different subtype of MatProp (for more information on this, see Types.AbstractMatProp). The two main functions called by this one, meltUpdate and consUpdate, are both also dispatched on the type of the material property struct, so they can be overwritten individually for a new material property struct if the new material model only needs to change some of the behaviour.\n\nArguments\n\ncts: Current time step results\npts: Previous time step results\nind: The indicies to update\n\n\n\n\n\n","category":"function"}]
}
