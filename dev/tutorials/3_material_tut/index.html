<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 3: A Melt Rate Based Material Model · High Speed Sintering Simulations</title><meta name="title" content="Tutorial 3: A Melt Rate Based Material Model · High Speed Sintering Simulations"/><meta property="og:title" content="Tutorial 3: A Melt Rate Based Material Model · High Speed Sintering Simulations"/><meta property="twitter:title" content="Tutorial 3: A Melt Rate Based Material Model · High Speed Sintering Simulations"/><meta name="description" content="Documentation for High Speed Sintering Simulations."/><meta property="og:description" content="Documentation for High Speed Sintering Simulations."/><meta property="twitter:description" content="Documentation for High Speed Sintering Simulations."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">High Speed Sintering Simulations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Modelling of HSS (and related technologies)</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../intro/">Tutorial Introduction</a></li><li><a class="tocitem" href="../1_full_tut/">Tutorial 1: Full Build</a></li><li><a class="tocitem" href="../2_basic_tut/">Tutorial 2: Warm-up and Cool-down only</a></li><li class="is-active"><a class="tocitem" href>Tutorial 3: A Melt Rate Based Material Model</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Making-the-Material-Property-Struct"><span>Making the Material Property Struct</span></a></li><li><a class="tocitem" href="#Adding-The-New-Logic"><span>Adding The New Logic</span></a></li><li><a class="tocitem" href="#Making-a-New-Material"><span>Making a New Material</span></a></li><li><a class="tocitem" href="#The-Rest-of-the-Setup"><span>The Rest of the Setup</span></a></li></ul></li><li><a class="tocitem" href="../4_res_tut/">Tutorial 4: Saving More Results</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/api/">Main API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/adv_intro/">Advanced API Introduction</a></li><li><a class="tocitem" href="../../reference/types/">Types</a></li><li><a class="tocitem" href="../../reference/res/">Simulation Results</a></li><li><a class="tocitem" href="../../reference/material/">Material Model</a></li><li><a class="tocitem" href="../../reference/boundary/">Boundary Model</a></li><li><a class="tocitem" href="../../reference/hssbound/">HSS Boundary</a></li><li><a class="tocitem" href="../../reference/solver/">Solver</a></li><li><a class="tocitem" href="../../reference/postprocessing/">Post Processing</a></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_intro/">Recipes Introduction</a></li><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Pattern Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulating Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Material Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Model Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Result Type Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Load Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundary Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Type Recipes</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solver Recipes</a></li></ul></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li><li><a class="tocitem" href="../../doc_index/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorial 3: A Melt Rate Based Material Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial 3: A Melt Rate Based Material Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/lit/material_tut.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-3:-A-Melt-Rate-Based-Material-Model"><a class="docs-heading-anchor" href="#Tutorial-3:-A-Melt-Rate-Based-Material-Model">Tutorial 3: A Melt Rate Based Material Model</a><a id="Tutorial-3:-A-Melt-Rate-Based-Material-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-3:-A-Melt-Rate-Based-Material-Model" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/Oliver-Leete/HSSSimulations.jl/main?filepath=examples/3_material_tut.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.org/github/Oliver-Leete/HSSSimulations.jl/blob/main/examples/3_material_tut.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><pre><code class="language-julia hljs">using HSSSimulations</code></pre><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This tutorial will cover how to implement the time dependent melt state model introduced in my thesis. To do this, this tutorial builds on top of the full build tutorial by adding a new material property type.</p><p>This is a proposed solution for the poor results of the melt state results found in my thesis is to model the melt state similarly to how the default material model treats the Consolidation state, making it time dependent. This has not been implemented as the default model as I don&#39;t currently have the required data, but if you have the data then you can use this implementation (my thesis should include an idea for how to get the data).</p><h2 id="Making-the-Material-Property-Struct"><a class="docs-heading-anchor" href="#Making-the-Material-Property-Struct">Making the Material Property Struct</a><a id="Making-the-Material-Property-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#Making-the-Material-Property-Struct" title="Permalink"></a></h2><p>First up is the addition of a new material property struct and constructor. This is the same as the default one with the only change being the name (for dispatch reasons), and changing the <code>Mᵣ</code> and <code>Rᵣ</code> fields to <code>Ṁ</code> and <code>Ṙ</code>.</p><pre><code class="language-julia hljs">struct MatPropTD{T1,T2,T3,T4,T5,T6,T7,T8,T9} &lt;: Types.AbstractMatProp
    ρ::T1
    c::T2
    κ::T3
    &quot;&quot;&quot; Melting rate to temp and melt state relationship.
    A 2d interpolation, with the first input axis being the temperature and the
    second the current melt state. The output is the melt rate.
    &quot;&quot;&quot;
    Ḟ::T4
    &quot;&quot;&quot; Crystallisation rate to temp, melt state and maximum melt state relationship.
    A 3d interpolation, with the first input axis being the node temperature,
    the second the current melt state and the third the maximum melt state
    reached. The output is the recrystalisation rate.
    &quot;&quot;&quot;
    Ṙ::T5
    Hf::T6
    Hr::T7
    Ċ::T8
    eₚ::Float64
    eᵢ::Float64
    ε::Float64
    name::String
    Mₘ::T9
end</code></pre><p>As well as copying the old type, we&#39;ll also copy its constructor, to give us a more convineient way of constructing it from our experimental data. Again, this is the same as before, just with a change of name.</p><pre><code class="language-julia hljs">function MatPropTD(ρ, c, κ, Ṁ, Ṙ, Hf, Hr, Ċ, eₚ, eᵢ, ε, name, geometry)
    geomSize = (geometry.X, geometry.Y, geometry.Z)
    Mₘ = zeros(geomSize)

    return MatPropTD{
        typeof(ρ),typeof(c),typeof(κ),
        typeof(Ṁ),typeof(Ṙ),typeof(Hf),typeof(Hr),
        typeof(Ċ),typeof(Mₘ),
    }(
        ρ, c, κ,
        Ṁ, Ṙ, Hf, Hr,
        Ċ,
        eₚ, eᵢ, ε,
        name, Mₘ,
    )
end</code></pre><h2 id="Adding-The-New-Logic"><a class="docs-heading-anchor" href="#Adding-The-New-Logic">Adding The New Logic</a><a id="Adding-The-New-Logic-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-The-New-Logic" title="Permalink"></a></h2><p>Now we have the new type, we can use it with julia&#39;s multiple dispatch to change what method is called when the simulation goes to update the melt state. This is done by making a new method for <a href="../../reference/material/#HSSSimulations.Material.meltUpdate"><code>Material.meltUpdate</code></a> that specifies our new type in place of the default <a href="../../reference/material/#HSSSimulations.Material.MatProp"><code>MatProp</code></a> type. Refer to my thesis if you would like an explanation as to what has changed here from the default method.</p><pre><code class="language-julia hljs">function Material.meltUpdate(Mᵗ⁻¹, T, Mₘ, Δt, mp::MatPropTD)
    ṀF = mp.Ḟ(T, Mᵗ⁻¹)
    ṀR = mp.Ṙ(T, Mᵗ⁻¹, Mₘ)

    if ṀF &gt; -ṀR
        ΔM = ṀF * Δt
        ΔH = ΔM * mp.Hf
    else
        ΔM = ṀR * Δt
        ΔH = ΔM * mp.Hr(Mₘ)
    end
    Mᵗ = clamp(Mᵗ⁻¹ + ΔM, 0, 1)
    Mₘ = max(Mᵗ, Mₘ)

    return Mᵗ, Mₘ, Δh
end</code></pre><p>If we needed more arguments to be passed in to this function, or wanted to change other properties of the material model, we could define a new method for <a href="../../reference/material/#HSSSimulations.Material.calcMatProps!"><code>Material.calcMatProps!</code></a>. For an example of this, you can check out <a href="../../howtos/howto_matprop/#A-Basic-Material-Model">A Basic Material Model</a>. <a href="../../reference/material/#HSSSimulations.Material.consUpdate"><code>Material.consUpdate</code></a> is also dispatched on the material property struct, so that can also be modified sepreatly without having to rewrite the entire material model.</p><h2 id="Making-a-New-Material"><a class="docs-heading-anchor" href="#Making-a-New-Material">Making a New Material</a><a id="Making-a-New-Material-1"></a><a class="docs-heading-anchor-permalink" href="#Making-a-New-Material" title="Permalink"></a></h2><p>We&#39;ll use PA2200 as our material, using most of the values from the default type. The only changes will be our two melt rate relationship fields. To fill in the values for these fields we&#39;ll use interpolated arrays, so first lets add the interpolations package:</p><pre><code class="language-julia hljs">using Interpolations</code></pre><p>Then we can use this to create a 2D interpolation for <code>Ṁ</code> that does what we said we want it to do.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The data presented here is totally fictional and should be replaced with actual data.</p></div></div><p>To do this you will need the values corrisponding to the inputs of the data, so for example if we recorded the melt rate at temperatures of 170°C, 180°C and 190°C then we could define</p><pre><code class="language-julia hljs">melt_temps = [170, 180, 190]</code></pre><p>And if we made those measurements at melt states of 0 and 1</p><pre><code class="language-julia hljs">melt_state = [0, 1]</code></pre><p>We can then define the outputs, what the value of the melt rates measured for each of those states, where the x-axis of the array is the temperature and the y-axis is the melt state. So for this example, we have a melt rate of <code>0.03</code> at <code>M=0</code> at a temperature of 190°C.</p><pre><code class="language-julia hljs">melt_rate = [
    0 0.02 0.03
    0 0.01 0.02
]</code></pre><p>Then we can use these to make the linear interpolation that will be used in the simulation. Where the first argument is a tuple of our inputs and the second is our outputs. The key word argument defines how the values should be extrapolated if an input is given outside of the range of the inputs we&#39;ve provided. Check out <a href="https://juliamath.github.io/Interpolations.jl/latest/extrapolation/">the Interpolations.jl docs</a> for more info on these.</p><pre><code class="language-julia hljs">PA_Ṁ = linear_interpolation(
    (melt_temps, melt_state),
    melt_rate;
    extrapolation_bc=Flat(),
)</code></pre><p>You can test out what this does by trying to index into it with values other than those given, it should return values linearly interpolated between the ones you gave.</p><pre><code class="language-julia hljs">PA_Ṁ[175, 0.5]</code></pre><p>Then we can do a similar thing for the recrystalisation rate. Although here we need an extra input, the maximum melt state that was reached before recrystalisation began.</p><pre><code class="language-julia hljs">recryst_temps = [150, 180]
melt_state = [0, 1]
melt_max = [0, 1]</code></pre><p>And because we have an extra input, the output needs to have an extra dimension. The triple semicolon is used to concatinate in the 3rd dimension. So the 2×2 array befor the triple semicolon is the melt rate for a melt max of 0 and the one after is for a melt max of 1.</p><pre><code class="language-julia hljs">recryst_rate = [
    0.1 0;
    0.5 0
    ;;;
    0.2 0;
    0.8 0
]

PA_Ṙ = linear_interpolation(
    (recryst_temps, melt_state, melt_max),
    recryst_rate;
    extrapolation_bc=Flat(),
)</code></pre><p>And like before, we can gives this a go.</p><pre><code class="language-julia hljs">PA_Ṙ[160, 0.2, 0.733]</code></pre><p>And finally this can all go together to make our material, but like before we need to make a geometry to pass in to the material propetry constructor.</p><pre><code class="language-julia hljs">geometry = Geometry(
    (0.016, 0.016, 0.0122),
    0.001,
    1.5e-3;
    Δz=0.003 / 90,
    Δh=0.0001,
    offset=(0.0925, 0.1425),
    buildSize=(0.200, 0.300),
    name=&quot;30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers&quot;,
)

material = MatPropTD(
    Material.PA_ρ(),
    Material.PA_c(),
    Material.PA_κ(),
    PA_TD_M,
    PA_TD_R,
    Material.PA_Hf(),
    Material.PA_Hr(),
    Material.PA_Ċ,
    Material.PA_eₚ,
    Material.PA_eᵢ,
    Material.PA_ε,
    &quot;Time dependent PA2200&quot;,
    geometry,
)</code></pre><h2 id="The-Rest-of-the-Setup"><a class="docs-heading-anchor" href="#The-Rest-of-the-Setup">The Rest of the Setup</a><a id="The-Rest-of-the-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#The-Rest-of-the-Setup" title="Permalink"></a></h2><p>From here on it&#39;s just the same as our other simulations.</p><pre><code class="language-julia hljs">params = HSSParams(geometry)
loadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)

size = (geometry.X, geometry.Y, geometry.Z)
init = Result(size, 25.0, 0.0, 0.0)
initialLayer = 10

inkArray = fill(material.eₚ, size)
inkArray[5:end-4, 5:end-4, 60:end-10] .= material.eᵢ
ink = Ink(inkArray, &quot;Sample square&quot;)

file = &quot;material_model_tutorial.jld2&quot;
description = &quot;A simulation to test a time dependent melt model&quot;

problem = Problem(;
    geometry=geometry,
    matProp=material,
    params=params,
    preheatLoads=preheatLoads,
    buildLoads=buildLoads,
    cooldownLoads=cooldownLoads,
    init=init,
    initLay=initialLayer,
    ink=ink,
    file=file,
    description=description,
)

resultFile, finalResults = problemSolver(problem)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2_basic_tut/">« Tutorial 2: Warm-up and Cool-down only</a><a class="docs-footer-nextpage" href="../4_res_tut/">Tutorial 4: Saving More Results »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 28 February 2024 23:46">Wednesday 28 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
