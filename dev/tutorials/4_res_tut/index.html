<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 Saving More Results · Powder Model Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Powder Model Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../1_full_tut/">1 Full Build</a></li><li><a class="tocitem" href="../2_basic_tut/">2 Warm-up and Cool-down only</a></li><li><a class="tocitem" href="../3_material_tut/">3 A Melt Rate Based Material Model</a></li><li class="is-active"><a class="tocitem" href>4 Saving More Results</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Setting-Up-the-Time-Step-Results"><span>Setting Up the Time Step Results</span></a></li><li><a class="tocitem" href="#Recording-the-Time-Step-Results"><span>Recording the Time Step Results</span></a></li><li><a class="tocitem" href="#Saving-Results-at-the-End"><span>Saving Results at the End</span></a></li><li><a class="tocitem" href="#The-Rest-of-the-Setup"><span>The Rest of the Setup</span></a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/api/">Main API</a></li><li><a class="tocitem" href="../../reference/api_adv/">Advanced API</a></li><li><a class="tocitem" href="../../reference/BoundaryExamples/">HSS Boundary</a></li><li><a class="tocitem" href="../../reference/PostProcessing/">Post proccessing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/internal_api/">Internal APIs</a></li><li><a class="tocitem" href="../../reference/internals/">Private Internals</a></li></ul></li></ul></li><li><span class="tocitem">Recipes</span><ul><li><a class="tocitem" href="../../howtos/howto_ink/">Ink Patterns</a></li><li><a class="tocitem" href="../../howtos/howto_subsets/">Simulate Subsets of a Build</a></li><li><a class="tocitem" href="../../howtos/howto_mat/">Materials</a></li><li><a class="tocitem" href="../../howtos/howto_matprop/">Material Models</a></li><li><a class="tocitem" href="../../howtos/howto_result/">Results</a></li><li><a class="tocitem" href="../../howtos/howto_load/">Loads and Load Sets</a></li><li><a class="tocitem" href="../../howtos/howto_bound/">Boundaries</a></li><li><a class="tocitem" href="../../howtos/howto_param/">Problem Parameters</a></li><li><a class="tocitem" href="../../howtos/howto_loadset/">Load Set Types</a></li><li><a class="tocitem" href="../../howtos/howto_problem/">Problem Solvers</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/HSSBoundary/">HSS Boundary</a></li><li><a class="tocitem" href="../../reference/MaterialExamples/">Material examples</a></li><li><a class="tocitem" href="../../explanation/faqs/">FAQs</a></li></ul></li><li><a class="tocitem" href="../../doc_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>4 Saving More Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4 Saving More Results</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Oliver-Leete/HSSSimulations.jl/blob/main/docs/lit/res_tut.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-4:-Saving-More-Results"><a class="docs-heading-anchor" href="#Tutorial-4:-Saving-More-Results">Tutorial 4: Saving More Results</a><a id="Tutorial-4:-Saving-More-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-4:-Saving-More-Results" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/Oliver-Leete/HSSSimulations.jl/gh-pages?filepath=dev/../examples/4_res_tut.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/Oliver-Leete/HSSSimulations.jl/blob/gh-pages/dev/../examples/4_res_tut.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><pre><code class="language-julia hljs">using HSSSimulations
using .Types
using .Res
using .HSSBound</code></pre><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This tutorial will go over both of the ways to save data from the simulation. One method saves results for every time step (well, the ones that the results aren&#39;t skipped for) of the simulation. The other, simpler, method saves some results at the end of the simulation.</p><p>For this tutorial we will save some of the information about the overhead heaters. The temperature of the heaters will be saved at every time step. And a list of layers where the power was updated will be saved (along) with every layer that they&#39;re saved for.</p><h2 id="Setting-Up-the-Time-Step-Results"><a class="docs-heading-anchor" href="#Setting-Up-the-Time-Step-Results">Setting Up the Time Step Results</a><a id="Setting-Up-the-Time-Step-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up-the-Time-Step-Results" title="Permalink"></a></h2><p>To store results for each time step we will need to make a new <a href="../../reference/api_adv/#HSSSimulations.Types.AbstractResult"><code>AbstractResult</code></a> type. This is very similar to the built in <a href="../../reference/api/#HSSSimulations.Res.Result"><code>Result</code></a> type, with the addition of the <code>O</code> field, where we&#39;ll store the overhead heater temperature. This has to be an array of some kind instead of just a float64 to allow for the value to be mutable (so we can update it once it has been calculated).</p><pre><code class="language-julia hljs">struct OverheadResult{P&lt;:AbstractArray,V&lt;:AbstractArray} &lt;: AbstractResult
    &quot;Temperature&quot;
    T::P
    &quot;Melt state&quot;
    M::P
    &quot;Consolidation state&quot;
    C::P
    &quot;Overhead Heater Temperature&quot;
    O::V
    &quot;Time of timestep&quot;
    t::Float64
    &quot;The progress through the load step (0=start, 1=end)&quot;
    tₚ::Float64
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As this struct is what stores the data during the simulation, all subtypes <strong>MUST</strong> have the <code>T</code>, <code>t</code> and <code>tₚ</code> fields, and if you want to use it with the default material model it will also need the <code>M</code> and <code>C</code> fields.</p></div></div><p>In addition, we&#39;ll also need some constructors for our new type, one empty one that is used in the simulation code:</p><pre><code class="language-julia hljs">function OverheadResult(geomSize, t, tₚ)
    T = Array{Float64}(undef, geomSize...)
    M = Array{Float64}(undef, geomSize...)
    C = Array{Float64}(undef, geomSize...)
    O = Vector{Float64}(undef, 1)
    return OverheadResult{typeof(T),typeof(O)}(T, M, C, O, t, tₚ)
end</code></pre><p>And one to create one filled with given values, that we&#39;ll use to create our initial conditions result:</p><pre><code class="language-julia hljs">function OverheadResult(geomSize, Tᵢ, Mᵢ, Cᵢ, t, tₚ)
    T = fill(Tᵢ, geomSize)
    M = fill(Mᵢ, geomSize)
    C = fill(Cᵢ, geomSize)
    O = Vector{Float64}(undef, 1)
    return OverheadResult{typeof(T),typeof(O)}(T, M, C, O, t, tₚ)
end</code></pre><h2 id="Recording-the-Time-Step-Results"><a class="docs-heading-anchor" href="#Recording-the-Time-Step-Results">Recording the Time Step Results</a><a id="Recording-the-Time-Step-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-the-Time-Step-Results" title="Permalink"></a></h2><p>We have the new types ready to store the data, so now we can update some functions to actually fill them with data. The function we care about is the one that finds the new temperature for the overhead heaters, which conveniently is just one of the arguments to HSSParams. So we can just make a function that we&#39;ll pass in when calling <a href="../../reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSParams"><code>HSSParams</code></a>. This is basically just the default function, but with the added step <code>cts.O[1] = oveheadTemp</code> to save our result.</p><pre><code class="language-julia hljs">function overheadHeatupFunc(powerIn::Float64, prevOverheadTemp::Float64, cts)
    overheadTemp = HSSBound.overheadTempFunc(
        powerIn,
        x -&gt; (0.596x - 12.2),
        118.923,
        geometry.Δt,
        prevOverheadTemp,
    )
    cts.O[1] = overheadTemp
    return overheadTemp
end</code></pre><p>As well as recording the results, we also need to save them. This is done with the <a href="../../reference/api_adv/#HSSSimulations.Res.loadStepSaver"><code>Res.loadStepSaver</code></a> function. We can create a method for this function that uses our <code>OverheadResult</code> type. Although it can&#39;t be dispatched on directly, instead we dispatch on a type from the <code>StructArrays</code> package, with our type as its type parameter. This is handily rexported by the Res module, so we can use it from there.</p><p>The <a href="../../reference/api_adv/#HSSSimulations.Res.loadStepSaver"><code>Res.loadStepSaver</code></a> function is given a folder of the output file that we can then save the contents of <code>loadResults</code> to. <code>loadResults</code> is acts as a struct who&#39;s fields are vectors of the fields of our <code>OverheadResult</code> struct. But we can use <code>stack</code> to turn the vectors of arrays into higher dimension arrays before saving them. This will make them the right format to work with the built in post processing functions.</p><pre><code class="language-julia hljs">function Res.loadStepSaver(
    loadResultsFolder,
    loadResults::Res.StructVector{T},
) where {T&lt;:OverheadResult}
    loadResultsFolder[&quot;time&quot;] = loadResults.t
    loadResultsFolder[&quot;T&quot;] = stack(loadResults.T)
    loadResultsFolder[&quot;M&quot;] = stack(loadResults.M)
    loadResultsFolder[&quot;C&quot;] = stack(loadResults.C)
    loadResultsFolder[&quot;O&quot;] = stack(loadResults.O)
    return
end</code></pre><p>Before this function is called, the name of the load has already been saved to the name field, so we don&#39;t have to worry about that here (just don&#39;t try and save something else to the name field here, it will error).</p><h2 id="Saving-Results-at-the-End"><a class="docs-heading-anchor" href="#Saving-Results-at-the-End">Saving Results at the End</a><a id="Saving-Results-at-the-End-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-Results-at-the-End" title="Permalink"></a></h2><p>Compared to saving results for every time step, saving results at the end is much easier. The downside is that we can only save things that we have access to at the end. And the only things we have access to at the end are the contents of <a href="../../reference/internal_api/#HSSSimulations.Types.GVars"><code>GVars</code></a>. Luckely, there is a placeholder field in GVars called <code>otherResults</code>. To use this we can make an <a href="../../reference/api_adv/#HSSSimulations.Types.AbstractOtherResults"><code>AbstractOtherResults</code></a> that stores whatever data we want. For this we&#39;ll make one that stores some information about the overhead heater controller.</p><p>We&#39;ll store a list of layers that caused the overhead heater to update, along with the time of the update and the new power.</p><pre><code class="language-julia hljs">struct OverheadContRes &lt;: AbstractOtherResults
    layerChanged::Vector{Int}
    timeChanged::Vector{Float64}
    newPower::Vector{Float64}
end</code></pre><p>To save this data we will use the HSSBound module and make a new version of the constructor for <a href="../../reference/api_adv/#HSSSimulations.HSSBound.OverheadsBoundary"><code>HSSBound.OverheadsBoundary</code></a> that dispatches on our new type. This is just the same as the default method, but with three <code>push!</code> statements added.</p><pre><code class="language-julia hljs">function HSSBound.OverheadsBoundary(
    pts::AbstractResult,
    cts::AbstractResult,
    G::GVars{T,Gh,Mp,R,OR,B},
    ls::LoadStep,
) where {T&lt;:Any,Gh&lt;:Any,Mp&lt;:Any,R&lt;:Any,OR&lt;:OverheadContRes,B&lt;:Any}
    param = G.params</code></pre><p>Overhead update logic</p><pre><code class="language-julia hljs">    if ls.layerNum - param.overheadLayerStep &gt;= param.lastUpdatedOverhead
        param.lastUpdatedOverhead = ls.layerNum
        surfaceCurrent = pts.T[ls.ind.z₂[1][1]]
        if surfaceCurrent &gt; (param.surfaceTarget + param.surfaceTol)
            overheadPower = param.overheadPower - param.overheadPowerStep
        elseif surfaceCurrent &lt; (param.surfaceTarget - param.surfaceTol)
            overheadPower = param.overheadPower + param.overheadPowerStep
        else
            overheadPower = param.overheadPower
        end
        param.overheadPower = min(max(overheadPower, 0), param.overheadMaxPower)

        push!(G.otherResults.layerChanged, ls.layerNum)
        push!(G.otherResults.timeChanged, cts.t)
        push!(G.otherResults.newPower, param.overheadPower)

        @debug &quot;Overhead Power updated&quot; _group = &quot;hss&quot; surfaceCurrent overheadPower
    end
    overheadTemp = param.overheadHeatupFunc(param.overheadPower, param.overheadTemp, cts)
    param.overheadTemp = overheadTemp

    airTemp = param.airHeat(cts.t)
    surfaceTemp = param.surfaceHeat(cts.t)
    ε = G.matProp.ε
    h = param.convectionCoef
    Po = param.percentOverhead

    @debug &quot;OverheadsBoundary&quot; _group = &quot;hss&quot; cts.tₚ overheadTemp surfaceTemp airTemp
    return OverheadsBoundary(overheadTemp, surfaceTemp, ε, airTemp, h, Po)
end</code></pre><p>Also, the other contents of a few of GVars&#39;s fields can be customised by us, the <code>matProp</code> field contains the <a href="../../reference/api_adv/#HSSSimulations.Types.AbstractMatProp"><code>AbstractMatProp</code></a> struct for the simulation, and the <code>params</code> field contains the simulation&#39;s <a href="../../reference/api_adv/#HSSSimulations.Types.AbstractProblemParams"><code>AbstractProblemParams</code></a> struct. So if we were making a new material model then we could use it&#39;s struct to store something and then save it all at the end, or the same for boundary conditions with the parameters struct.</p><p>In addition to our <code>otherResults</code> struct, we will also save a couple of things that are already available from the default structs. The maximum melt state is from the <a href="../../reference/api_adv/#HSSSimulations.Material.MatProp"><code>MatProp</code></a> struct (and is normally saved by this function anyway), and <code>coolStart</code> is from the <a href="../../reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSParams"><code>HSSParams</code></a> struct (and is not normally saved).</p><p>We&#39;ll make a method for <a href="../../reference/api_adv/#HSSSimulations.Res.otherResults"><code>otherResults</code></a> that dispatches on our <code>OverheadContRes</code> struct. This method saves <code>MeltMax</code> and <code>CoolStart</code> to the top level results folder of the output file, and all of our overhead controller stuff to its own subfolder of the results.</p><pre><code class="language-julia hljs">function Res.otherResults(
    G::Types.GVars{T,Gh,Mp,R,OR,B},
    file,
) where {T&lt;:Any,Gh&lt;:Any,Mp&lt;:Any,R&lt;:Any,OR&lt;:OverheadContRes,B&lt;:Any}
    file[&quot;MeltMax&quot;] = G.matProp.Mₘ
    file[&quot;CoolStart&quot;] = G.params.coolStart
    file[&quot;Overheads/layerChanged&quot;] = G.otherResults.layerChanged
    file[&quot;Overheads/timeChanged&quot;] = G.otherResults.timeChanged
    file[&quot;Overheads/newPower&quot;] = G.otherResults.newPower
    return
end</code></pre><p>If we didn&#39;t want to store any data outside of what is incleded anyway from the material property or parameters struct, then we could have just made our new <code>AbstractOtherResults</code> struct empty and still used it to dispatch a method for <a href="../../reference/api_adv/#HSSSimulations.Res.otherResults"><code>Res.otherResults</code></a>.</p><p>In fact, as the default <a href="../../reference/api_adv/#HSSSimulations.Res.OtherResults"><code>OtherResults</code></a> struct is empty and isn&#39;t used, you can replace it with an empty struct of your own to use to dispatch methods of other functions. So if you wanted to change the behavour of one of the boundaries, or of the material model, but don&#39;t want to have to replace those structs, then just use the <code>otherResults</code>. I&#39;ll leave it as an exercise for the reader to rewrite the previous tutorial using this method to make things shorter.</p><h2 id="The-Rest-of-the-Setup"><a class="docs-heading-anchor" href="#The-Rest-of-the-Setup">The Rest of the Setup</a><a id="The-Rest-of-the-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#The-Rest-of-the-Setup" title="Permalink"></a></h2><p>From here on it&#39;s similar to our other simulations. The one exceptions being the fact that we need to pass our <code>overheadHeatupFunc</code> into <a href="../../reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSParams"><code>HSSParams</code></a> and the fact that we need to pass an empty <code>OverheadContRes</code> into the problem. Creating a <a href="../../reference/internal_api/#HSSSimulations.Types.Geometry"><code>Geometry</code></a> first to feed into the <a href="../../reference/BoundaryExamples/#HSSSimulations.HSSBound.HSSParams"><code>HSSParams</code></a>. We&#39;ll also change some of the settings of the geometry so that it goes a bit faster but be less accurate, if you want to try this out on a full simulation feel free to use the geometry from the full build tutorial.</p><pre><code class="language-julia hljs">geometry = Geometry(
    (0.016, 0.016, 0.0122),
    0.001,
    1e-2;
    Δz=0.003 / 30,
    Δh=0.0001,
    offset=(0.0925, 0.1425),
    buildSize=(0.200, 0.300),
    name=&quot;30 layers preheat, 50 pre square pad layers 32 layer thich square and 10 post square padding layers&quot;,
)</code></pre><p>Then the new stuff</p><pre><code class="language-julia hljs">params = HSSParams(geometry; overheadHeatupFunc=overheadHeatupFunc)
otherResults = OverheadContRes(Vector{Int}(), Vector{Float64}(), Vector{Float64}())</code></pre><p>We also need to make sure to use our new results struct for our initial conditions, this will tell the simulation to use it for the rest of the time steps.</p><pre><code class="language-julia hljs">init = OverheadResult((geometry.X, geometry.Y, geometry.Z), 25.0, 0.0, 0.0, 0.0, 0)</code></pre><p>And the rest of it</p><pre><code class="language-julia hljs">loadSets = HSSLoads(4, geometry; nrPreheat=90, lenPreheat=10.0, nrCool=90, lenCool=10.0)
material = PA2200(geometry)

initialLayer = 30

inkArray = fill(material.eₚ, (geometry.X, geometry.Y, geometry.Z))
inkArray[5:end-4, 5:end-4, 60:end-10] .= material.eᵢ
ink = Ink(inkArray, &quot;Sample square&quot;)

file = &quot;results_tutorial.jld2&quot;
description = &quot;A simulation to test out saving overhead heater results&quot;

problem = Problem(;
    geometry=geometry,
    matProp=material,
    params=params,
    loadSets=loadSets,
    init=init,
    initLay=initialLayer,
    ink=ink,
    file=file,
    otherResults=otherResults,
    description=description,
)

resultFile, finalResults = problemSolver(problem)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3_material_tut/">« 3 A Melt Rate Based Material Model</a><a class="docs-footer-nextpage" href="../../reference/api/">Main API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 19 June 2023 14:40">Monday 19 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
